# Multi-Stage Implementation Plan: F1GP Modern Port

**Document Type:** Implementation Plan (PLN)
**Version:** 1.0
**Date:** 2025.11.14
**Project:** F1GP Modern Port - Native Windows/Cross-Platform Port
**Status:** Draft

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Project Overview](#project-overview)
3. [Technical Architecture](#technical-architecture)
4. [Implementation Philosophy](#implementation-philosophy)
5. [Stage Dependencies](#stage-dependencies)
6. [Detailed Stage Breakdown](#detailed-stage-breakdown)
7. [Risk Assessment & Mitigation](#risk-assessment--mitigation)
8. [Quality Gates](#quality-gates)
9. [Resource Requirements](#resource-requirements)
10. [Timeline & Milestones](#timeline--milestones)
11. [Testing Strategy](#testing-strategy)
12. [Appendices](#appendices)

---

## Executive Summary

This document outlines a comprehensive plan to port the classic F1GP (Formula One Grand Prix) racing simulator from DOS to modern platforms using Rust. The project takes a **hybrid approach**: leveraging existing reverse engineering efforts while reimplementing the game in a modern, maintainable language.

**Total Estimated Duration:** 16-20 weeks (4-5 months)
**Total Stages:** 18 stages across 5 major phases
**Target Platforms:** Windows (primary), Linux, macOS (secondary)
**Key Milestones:** 7

### Implementation Approach
- **Incremental:** Extract data, understand algorithms, reimplement step-by-step
- **Hybrid:** Use original game data files with modern code
- **Cross-platform:** Rust + SDL2/wgpu for platform independence
- **Community-driven:** Build on existing reverse engineering work
- **Quality-first:** Each stage includes verification against original game

### Success Criteria
- Playable racing simulation matching original game behavior
- Native performance on modern systems (60+ FPS)
- Cross-platform support
- Maintainable, documented codebase
- Extensible for future enhancements

---

## Project Overview

### Background

**Formula One Grand Prix** (1991, MicroProse, designed by Geoff Crammond) is widely regarded as one of the greatest racing simulators ever created. It featured:
- Revolutionary 3D graphics for the era
- Realistic physics and handling
- All 16 circuits from the 1991 F1 season
- Sophisticated AI opponents
- Comprehensive car setup options

### Current State

- **Original Platform:** MS-DOS, x86 16-bit assembly
- **Graphics:** VGA Mode 13h (320×200, 256 colors)
- **Audio:** PC Speaker, AdLib, Sound Blaster
- **Input:** Keyboard, joystick via BIOS
- **Community:** Active modding community, partial reverse engineering completed

### Project Goals

**Primary Goals:**
1. Port F1GP to run natively on modern Windows (10/11)
2. Maintain original game physics and behavior
3. Modernize graphics (higher resolution, 3D acceleration)
4. Modernize audio (digital audio, modern sound cards)
5. Create maintainable codebase for future development

**Secondary Goals:**
1. Cross-platform support (Linux, macOS)
2. Gamepad support (Xbox, PlayStation controllers)
3. Online multiplayer capabilities
4. VR support (future enhancement)
5. Modding tools and documentation

**Non-Goals:**
1. Exact pixel-perfect graphics reproduction
2. DOS emulation layer
3. Supporting all original game bugs
4. Backward compatibility with original save files (initially)

---

## Technical Architecture

### Technology Stack

#### Core Language: Rust
- **Version:** Rust 1.75+ (2024 stable)
- **Edition:** 2021
- **Justification:** Memory safety, performance, cross-platform, modern tooling

#### Graphics Options (Choose One)

**Option A: SDL2 (Recommended for Phase 1)**
```toml
sdl2 = "0.37"
```
- Proven, stable, cross-platform
- Software and hardware rendering
- Built-in audio, input handling
- Easier learning curve
- Good for rapid prototyping

**Option B: wgpu (Future upgrade)**
```toml
wgpu = "0.20"
winit = "0.30"
```
- Modern GPU acceleration (Vulkan/DX12/Metal)
- Better performance for 3D graphics
- More complex but future-proof
- Can migrate from SDL2 later

#### Audio
```toml
rodio = "0.19"          # High-level audio playback
cpal = "0.15"           # Low-level audio (alternative)
```

#### Core Dependencies
```toml
bytemuck = "1.14"       # Safe binary data conversion
memmap2 = "0.9"         # Memory-mapped file I/O
serde = { version = "1.0", features = ["derive"] }
bincode = "1.3"         # Binary serialization
anyhow = "1.0"          # Error handling
thiserror = "1.0"       # Custom error types
log = "0.4"             # Logging
env_logger = "0.11"     # Logger implementation

# Game math
glam = "0.28"           # Fast SIMD math (vec3, mat4, etc.)
nalgebra = "0.33"       # Alternative: more features

# Data structures
dashmap = "5.5"         # Concurrent HashMap
parking_lot = "0.12"    # Better synchronization primitives

# Development
criterion = "0.5"       # Benchmarking
proptest = "1.4"        # Property-based testing
```

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                     Application Layer                       │
│  ┌────────────┐  ┌─────────────┐  ┌──────────────────────┐ │
│  │    Menu    │  │   Race UI   │  │   Setup/Options UI   │ │
│  └────────────┘  └─────────────┘  └──────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                      Game Logic Layer                       │
│  ┌────────────┐  ┌─────────────┐  ┌──────────────────────┐ │
│  │   Race     │  │   Session   │  │   Championship       │ │
│  │  Manager   │  │   Manager   │  │      Manager         │ │
│  └────────────┘  └─────────────┘  └──────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                    Simulation Layer                         │
│  ┌────────────┐  ┌─────────────┐  ┌──────────────────────┐ │
│  │  Physics   │  │     AI      │  │   Collision          │ │
│  │   Engine   │  │   Engine    │  │   Detection          │ │
│  └────────────┘  └─────────────┘  └──────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                      Data Layer                             │
│  ┌────────────┐  ┌─────────────┐  ┌──────────────────────┐ │
│  │   Track    │  │     Car     │  │   Driver/Team        │ │
│  │   Loader   │  │    Loader   │  │      Loader          │ │
│  └────────────┘  └─────────────┘  └──────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                  Platform Abstraction Layer                 │
│  ┌────────────┐  ┌─────────────┐  ┌──────────────────────┐ │
│  │  Graphics  │  │    Audio    │  │       Input          │ │
│  │   (SDL2)   │  │   (rodio)   │  │      (SDL2)          │ │
│  └────────────┘  └─────────────┘  └──────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### Module Structure

```
f1gp-port/
├── Cargo.toml
├── Cargo.lock
├── README.md
├── LICENSE
├── .gitignore
│
├── src/
│   ├── main.rs                 # Entry point
│   ├── lib.rs                  # Library root
│   │
│   ├── platform/               # Platform abstraction
│   │   ├── mod.rs
│   │   ├── graphics.rs         # Graphics backend abstraction
│   │   ├── audio.rs            # Audio backend abstraction
│   │   └── input.rs            # Input backend abstraction
│   │
│   ├── data/                   # Data loading & parsing
│   │   ├── mod.rs
│   │   ├── loader.rs           # Generic file loader
│   │   ├── track.rs            # Track data structures & loader
│   │   ├── car.rs              # Car data structures & loader
│   │   ├── driver.rs           # Driver/team data
│   │   ├── setup.rs            # Car setup data
│   │   └── formats/            # Original file format parsers
│   │       ├── mod.rs
│   │       ├── f1ct.rs         # Track format
│   │       ├── f1car.rs        # Car format
│   │       └── palette.rs      # Color palette
│   │
│   ├── physics/                # Physics simulation
│   │   ├── mod.rs
│   │   ├── car.rs              # Car physics state
│   │   ├── engine.rs           # Physics engine
│   │   ├── tire.rs             # Tire model
│   │   ├── aerodynamics.rs     # Aero model
│   │   ├── suspension.rs       # Suspension model
│   │   └── collision.rs        # Collision detection
│   │
│   ├── ai/                     # AI system
│   │   ├── mod.rs
│   │   ├── driver.rs           # AI driver behavior
│   │   ├── racing_line.rs      # Optimal racing line calculation
│   │   ├── overtaking.rs       # Overtaking logic
│   │   └── strategy.rs         # Race strategy (pit stops, etc.)
│   │
│   ├── game/                   # Game logic
│   │   ├── mod.rs
│   │   ├── race.rs             # Race session management
│   │   ├── session.rs          # Practice/Qualifying/Race
│   │   ├── championship.rs     # Championship progression
│   │   ├── weather.rs          # Weather system
│   │   └── rules.rs            # F1 rules & regulations
│   │
│   ├── render/                 # Rendering system
│   │   ├── mod.rs
│   │   ├── renderer.rs         # Main renderer
│   │   ├── camera.rs           # Camera system
│   │   ├── track_renderer.rs   # Track rendering
│   │   ├── car_renderer.rs     # Car rendering
│   │   ├── ui_renderer.rs      # UI rendering
│   │   └── shaders/            # Shader code (if using wgpu)
│   │
│   ├── audio/                  # Audio system
│   │   ├── mod.rs
│   │   ├── engine_sound.rs     # Engine sound synthesis
│   │   ├── effects.rs          # Sound effects
│   │   └── music.rs            # Background music
│   │
│   ├── ui/                     # User interface
│   │   ├── mod.rs
│   │   ├── menu.rs             # Main menu
│   │   ├── hud.rs              # In-game HUD
│   │   ├── setup_screen.rs     # Car setup UI
│   │   └── results.rs          # Race results screen
│   │
│   └── utils/                  # Utilities
│       ├── mod.rs
│       ├── math.rs             # Math utilities
│       ├── config.rs           # Configuration management
│       └── profiler.rs         # Performance profiling
│
├── assets/                     # Game assets
│   ├── original/               # Extracted original assets
│   │   ├── tracks/
│   │   ├── cars/
│   │   └── palettes/
│   ├── textures/               # New textures
│   ├── sounds/                 # Sound files
│   └── shaders/                # Shader files
│
├── tools/                      # Development tools
│   ├── extract_iso.rs          # ISO extraction tool
│   ├── track_viewer.rs         # Track data viewer
│   └── data_converter.rs       # Data format converter
│
├── tests/                      # Integration tests
│   ├── physics_tests.rs
│   ├── data_loader_tests.rs
│   └── fixtures/
│
├── benches/                    # Benchmarks
│   ├── physics_bench.rs
│   └── rendering_bench.rs
│
└── docs/                       # Documentation
    ├── file_formats.md         # Original file format docs
    ├── physics.md              # Physics model documentation
    ├── algorithms.md           # Reverse-engineered algorithms
    └── architecture.md         # Architecture documentation
```

---

## Implementation Philosophy

### Core Principles

1. **Understand Before Rewriting**
   - Thoroughly reverse engineer and document original behavior
   - Create test cases based on original game
   - Verify each reimplemented component against original

2. **Incremental Development**
   - Each stage produces working, testable code
   - Build from data layer up to game logic
   - Frequent testing against original game behavior

3. **Preserve Authentic Feel**
   - Match original physics behavior exactly
   - Preserve AI characteristics
   - Maintain game balance and difficulty

4. **Modern Best Practices**
   - Clean, documented, maintainable code
   - Comprehensive testing
   - Performance profiling
   - Version control with meaningful commits

5. **Community Engagement**
   - Leverage existing reverse engineering work
   - Document findings for community
   - Open source development
   - Accept community contributions

### Development Standards

**Code Quality:**
- All code compiles without warnings
- Clippy passes with no warnings (pedantic mode)
- rustfmt formatting enforced
- Comprehensive doc comments for public APIs
- Unit tests for all algorithms
- Integration tests for major systems

**Performance:**
- 60 FPS minimum at 1080p
- < 100ms frame time at 4K
- Efficient memory usage (< 500MB RAM)
- Fast load times (< 5s)

**Documentation:**
- All file formats documented
- Algorithm descriptions with references to original
- Architecture diagrams
- API documentation
- User documentation

---

## Stage Dependencies

```
Stage 1.1: Project Setup
    ↓
Stage 1.2: ISO Extraction & Analysis ──────┐
    ↓                                      │
Stage 1.3: File Format Documentation    ←──┘
    ↓
Stage 1.4: Data Structure Definition
    ↓
Stage 1.5: Track Data Loader
    ↓
═════════════════════ MILESTONE 1: Data Extraction ══════════════════════
    ↓
Stage 2.1: Graphics Foundation (SDL2)
    ↓
Stage 2.2: Track Renderer (2D) ─────────────┐
    ↓                                       │
Stage 2.3: Car Data Loader               ←──┘
    ↓
Stage 2.4: Car Renderer (2D)
    ↓
═════════════════════ MILESTONE 2: Visual Prototype ═════════════════════
    ↓
Stage 3.1: Physics Engine Core
    ↓
Stage 3.2: Car Physics Implementation ──────┐
    ↓                                       │
Stage 3.3: Track Collision System        ←──┘
    ↓
Stage 3.4: Input Handling
    ↓
Stage 3.5: Basic Playable Game
    ↓
═════════════════════ MILESTONE 3: Playable Demo ════════════════════════
    ↓
Stage 4.1: AI System Foundation
    ↓
Stage 4.2: AI Racing Line & Behavior
    ↓
Stage 4.3: Race Session Management ─────────┐
    ↓                                       │
Stage 4.4: Audio System                  ←──┘
    ↓
═════════════════════ MILESTONE 4: Complete Race ════════════════════════
    ↓
Stage 5.1: Championship Mode
    ↓
Stage 5.2: Car Setup System
    ↓
Stage 5.3: UI/Menus Polish ──────────────────┐
    ↓                                        │
Stage 5.4: Performance Optimization       ←──┘
    ↓
Stage 5.5: Testing & Bug Fixes
    ↓
═════════════════════ MILESTONE 5: Feature Complete ═════════════════════
    ↓
Stage 6.1: Cross-Platform Support
    ↓
Stage 6.2: Advanced Features (Multiplayer, etc.)
    ↓
═════════════════════ MILESTONE 6: Production Release ═══════════════════
```

---

## Detailed Stage Breakdown

## Phase 1: Foundation & Data Extraction (Weeks 1-3)

**Goal:** Extract and understand original game data, set up development infrastructure

---

### Stage 1.1: Project Setup & Infrastructure

**Duration:** 2 days
**Priority:** P0 (Critical)
**Dependencies:** None

#### Objectives
- Initialize Rust project with proper structure
- Configure development environment
- Set up CI/CD pipeline
- Establish documentation framework
- Configure version control

#### Tasks

**1. Initialize Cargo Project** (2 hours)
```bash
cargo new f1gp-port --lib
cd f1gp-port
cargo init --bin tools/extract_iso
```
- [ ] Create workspace structure
- [ ] Configure Cargo.toml with dependencies
- [ ] Set up workspace members
- [ ] Configure release profiles for optimization

**2. Configure Development Environment** (3 hours)
- [ ] Create .gitignore (Rust, IDE, assets)
- [ ] Set up rustfmt.toml with project code style
- [ ] Configure clippy.toml (enable pedantic lints)
- [ ] Create .github/workflows/ci.yml for GitHub Actions
- [ ] Set up pre-commit hooks (format, lint, test)

**3. Project Structure Creation** (2 hours)
- [ ] Create all module directories (src/data, src/physics, etc.)
- [ ] Create placeholder mod.rs files
- [ ] Create tools/ directory for utilities
- [ ] Create docs/ directory for documentation
- [ ] Create assets/ directory for game data

**4. Documentation Framework** (2 hours)
- [ ] Create comprehensive README.md
- [ ] Create CONTRIBUTING.md guidelines
- [ ] Create LICENSE file (GPL-3.0 or MIT)
- [ ] Set up mdBook for documentation
- [ ] Create initial architecture.md

**5. Dependencies Configuration** (1 hour)
```toml
[dependencies]
sdl2 = "0.37"
bytemuck = "1.14"
memmap2 = "0.9"
serde = { version = "1.0", features = ["derive"] }
anyhow = "1.0"
thiserror = "1.0"
log = "0.4"
env_logger = "0.11"
glam = "0.28"

[dev-dependencies]
criterion = "0.5"
proptest = "1.4"
```

#### Deliverables
- ✅ Compiling Rust workspace
- ✅ CI/CD pipeline running
- ✅ Documentation framework
- ✅ Development environment ready

#### Success Criteria
- [ ] `cargo build` succeeds
- [ ] `cargo test` runs (no tests yet)
- [ ] `cargo clippy` passes
- [ ] CI builds successfully on GitHub
- [ ] Documentation builds with mdBook

---

### Stage 1.2: ISO Extraction & Analysis

**Duration:** 3 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 1.1

#### Objectives
- Extract all files from F1GP ISO
- Analyze file structure and organization
- Identify critical game files
- Document file inventory

#### Tasks

**1. ISO Extraction Tool** (4 hours)
- [ ] Research ISO 9660 format
- [ ] Implement ISO reader or find library
- [ ] Create extraction tool in tools/extract_iso.rs
- [ ] Extract all files preserving directory structure
- [ ] Verify extracted file integrity

**2. File Analysis** (6 hours)
- [ ] Catalog all extracted files
- [ ] Identify file types by extension and magic numbers
- [ ] Group files by purpose (tracks, cars, graphics, audio)
- [ ] Document file sizes and relationships
- [ ] Create file inventory spreadsheet

**3. Hex Editor Analysis** (4 hours)
- [ ] Install hex editor (HxD, ImHex, or 010 Editor)
- [ ] Examine key files (track data, car data)
- [ ] Look for patterns and structures
- [ ] Identify compressed/encoded sections
- [ ] Document initial findings

**4. Research Existing Tools** (4 hours)
- [ ] Clone f1gp-utils repository
- [ ] Study existing file format parsers
- [ ] Test utilities on extracted files
- [ ] Document which formats are already understood
- [ ] Note gaps in existing knowledge

**5. Initial Documentation** (4 hours)
- [ ] Create docs/file_inventory.md
- [ ] Document directory structure
- [ ] List all file types found
- [ ] Create initial file format notes
- [ ] Document unknowns and questions

#### Deliverables
- ✅ All files extracted from ISO
- ✅ File inventory documented
- ✅ Extraction tool working
- ✅ Initial analysis complete

#### Success Criteria
- [ ] All files extracted successfully
- [ ] File inventory is comprehensive
- [ ] File purposes identified (at least 80%)
- [ ] Existing tools tested and documented
- [ ] Foundation for format reverse engineering laid

---

### Stage 1.3: File Format Documentation

**Duration:** 5 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 1.2

#### Objectives
- Reverse engineer critical file formats
- Document track file format (.F1CT or similar)
- Document car file format
- Document palette/graphics formats
- Create format specifications

#### Tasks

**1. Track File Format Reverse Engineering** (10 hours)
- [ ] Analyze track files from multiple circuits
- [ ] Identify header structure
- [ ] Map track segment data
- [ ] Understand coordinate system
- [ ] Document elevation/banking data
- [ ] Understand AI racing line data
- [ ] Decode scenery/object data
- [ ] Test findings with track viewer tool

**2. Car File Format Analysis** (6 hours)
- [ ] Analyze car/team data files
- [ ] Identify performance parameters
- [ ] Map engine characteristics
- [ ] Understand aerodynamics values
- [ ] Document tire models
- [ ] Decode livery/color data

**3. Graphics Format Analysis** (6 hours)
- [ ] Understand VGA palette format
- [ ] Analyze car sprite data
- [ ] Decode track texture data
- [ ] Understand 3D model data (if any)
- [ ] Document compression methods

**4. Create Format Parsers** (8 hours)
- [ ] Implement track format parser (basic)
- [ ] Implement car format parser (basic)
- [ ] Implement palette parser
- [ ] Add validation and error handling
- [ ] Write unit tests for parsers

**5. Documentation** (6 hours)
- [ ] Create docs/formats/track_format.md
- [ ] Create docs/formats/car_format.md
- [ ] Create docs/formats/graphics_format.md
- [ ] Include hex dumps with annotations
- [ ] Document offset tables
- [ ] Add C-style struct definitions
- [ ] Create Rust struct definitions

#### Deliverables
- ✅ Track format specification
- ✅ Car format specification
- ✅ Graphics format specification
- ✅ Working parsers in Rust
- ✅ Comprehensive documentation

#### Success Criteria
- [ ] Can parse all track files successfully
- [ ] Can parse all car files successfully
- [ ] Can load and display palette data
- [ ] Documentation is clear and complete
- [ ] Parsers have test coverage > 80%
- [ ] Validation against original game data

---

### Stage 1.4: Data Structure Definition

**Duration:** 3 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 1.3

#### Objectives
- Define Rust data structures for game data
- Create clean, modern representations
- Add serialization/deserialization
- Establish data validation
- Create conversion from original formats

#### Tasks

**1. Track Data Structures** (6 hours)
```rust
// src/data/track.rs
pub struct Track {
    pub name: String,
    pub length: f32,           // meters
    pub segments: Vec<TrackSegment>,
    pub elevation_map: Vec<f32>,
    pub racing_line: RacingLine,
    pub scenery: Vec<SceneryObject>,
}

pub struct TrackSegment {
    pub position: Vec3,
    pub width: f32,
    pub banking: f32,          // radians
    pub surface: SurfaceType,
}
```
- [ ] Define Track structure
- [ ] Define TrackSegment structure
- [ ] Define RacingLine structure
- [ ] Define SceneryObject structure
- [ ] Add serde derives
- [ ] Add validation methods

**2. Car Data Structures** (6 hours)
```rust
// src/data/car.rs
pub struct CarSpec {
    pub name: String,
    pub team: String,
    pub engine: EngineSpec,
    pub aerodynamics: AeroSpec,
    pub mass: f32,             // kg
    pub dimensions: CarDimensions,
}

pub struct EngineSpec {
    pub power_curve: Vec<(f32, f32)>,  // (rpm, power_kw)
    pub max_rpm: f32,
    pub torque_curve: Vec<(f32, f32)>,
}
```
- [ ] Define CarSpec structure
- [ ] Define EngineSpec structure
- [ ] Define AeroSpec structure
- [ ] Define performance characteristics
- [ ] Add serde derives
- [ ] Add builder pattern

**3. Driver/Team Structures** (4 hours)
- [ ] Define Driver structure
- [ ] Define Team structure
- [ ] Define driver skill ratings
- [ ] Add championship data
- [ ] Add serde derives

**4. Runtime Physics Structures** (6 hours)
```rust
// src/physics/car.rs
pub struct CarState {
    pub position: Vec3,
    pub velocity: Vec3,
    pub acceleration: Vec3,
    pub orientation: Quat,
    pub angular_velocity: Vec3,
    pub wheel_speeds: [f32; 4],
    pub engine_rpm: f32,
    pub gear: i8,
    pub throttle: f32,
    pub brake: f32,
    pub steering: f32,
}
```
- [ ] Define CarState structure
- [ ] Define PhysicsState structure
- [ ] Define control inputs
- [ ] Add debug visualization helpers

**5. Testing & Documentation** (4 hours)
- [ ] Write unit tests for all structures
- [ ] Add doc comments with examples
- [ ] Create data structure diagram
- [ ] Document design decisions

#### Deliverables
- ✅ Complete data model in Rust
- ✅ Serialization support
- ✅ Validation methods
- ✅ Comprehensive tests
- ✅ Documentation

#### Success Criteria
- [ ] All structures compile without warnings
- [ ] Serde serialization works correctly
- [ ] Validation catches malformed data
- [ ] Test coverage > 90%
- [ ] Documentation is clear

---

### Stage 1.5: Track Data Loader

**Duration:** 4 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 1.4

#### Objectives
- Implement complete track loader
- Convert original format to modern structures
- Validate loaded data
- Create track viewer tool
- Load all 16 original circuits

#### Tasks

**1. Track Loader Implementation** (8 hours)
```rust
// src/data/loader.rs
pub struct TrackLoader {
    // Implementation
}

impl TrackLoader {
    pub fn load_from_file(&self, path: &Path) -> Result<Track> {
        // Load and parse track file
        // Convert to Track structure
        // Validate data
    }
}
```
- [ ] Implement binary file reader
- [ ] Parse track header
- [ ] Load track segments
- [ ] Load elevation data
- [ ] Load racing line
- [ ] Load scenery objects
- [ ] Add error handling
- [ ] Add progress reporting for large files

**2. Data Conversion** (6 hours)
- [ ] Convert coordinate systems
- [ ] Convert units (if necessary)
- [ ] Normalize data ranges
- [ ] Build spatial index for track segments
- [ ] Precompute track properties (length, etc.)

**3. Track Validation** (4 hours)
- [ ] Validate track continuity
- [ ] Check for data corruption
- [ ] Verify coordinate bounds
- [ ] Ensure racing line is valid
- [ ] Report warnings for unusual data

**4. Track Viewer Tool** (10 hours)
```rust
// tools/track_viewer.rs
// Simple SDL2 app to visualize loaded tracks
```
- [ ] Create simple SDL2 window
- [ ] Implement 2D track renderer
- [ ] Draw track outline
- [ ] Draw racing line
- [ ] Show track info (name, length)
- [ ] Add camera pan/zoom
- [ ] Add track selection menu

**5. Load All Circuits** (4 hours)
- [ ] Test loading all 16 original tracks
- [ ] Verify each track renders correctly
- [ ] Document any issues or oddities
- [ ] Create track comparison screenshots
- [ ] Validate against original game appearance

#### Deliverables
- ✅ Working track loader
- ✅ Track viewer tool
- ✅ All 16 circuits loaded successfully
- ✅ Validation system
- ✅ Documentation

#### Success Criteria
- [ ] All 16 tracks load without errors
- [ ] Track viewer displays recognizable circuits
- [ ] Data validation catches errors
- [ ] Loading is reasonably fast (< 1s per track)
- [ ] Visual comparison shows accuracy

---

### Phase 1 Milestone: Data Extraction Complete

**Deliverables:**
- ✅ All original game data extracted
- ✅ File formats documented
- ✅ Track loader working
- ✅ Track viewer tool functional
- ✅ 16 circuits loading correctly

**Success Criteria:**
- [ ] Can load and visualize all tracks
- [ ] File format documentation is comprehensive
- [ ] Code is clean and well-tested
- [ ] Foundation for further development solid

**Demo:**
```bash
# Extract ISO
cargo run --bin extract_iso -- \
  --input f1gp-orig/Formula\ One\ Grand\ Prix\ \(1996\)\(Microprose\).iso \
  --output assets/original/

# View a track
cargo run --bin track_viewer -- \
  --track assets/original/tracks/monaco.f1ct
```

---

## Phase 2: Graphics & Rendering (Weeks 4-6)

**Goal:** Create rendering system, display tracks and cars visually

---

### Stage 2.1: Graphics Foundation (SDL2)

**Duration:** 3 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 1.5

#### Objectives
- Set up SDL2 rendering system
- Create window management
- Implement basic 2D rendering
- Set up coordinate systems
- Create rendering abstractions

#### Tasks

**1. SDL2 Setup** (4 hours)
- [ ] Add SDL2 dependency
- [ ] Initialize SDL2 context
- [ ] Create window with OpenGL context
- [ ] Set up event loop
- [ ] Handle window resize
- [ ] Implement clean shutdown

**2. Rendering Abstraction** (6 hours)
```rust
// src/platform/graphics.rs
pub trait Renderer {
    fn clear(&mut self, color: Color);
    fn present(&mut self);
    fn draw_line(&mut self, start: Vec2, end: Vec2, color: Color);
    fn draw_rect(&mut self, rect: Rect, color: Color);
    fn draw_filled_rect(&mut self, rect: Rect, color: Color);
    fn draw_sprite(&mut self, sprite: &Sprite, pos: Vec2);
}

pub struct SdlRenderer {
    // SDL2 implementation
}
```
- [ ] Define Renderer trait
- [ ] Implement SdlRenderer
- [ ] Add color management
- [ ] Add sprite support
- [ ] Add text rendering (SDL2_ttf)

**3. Camera System** (6 hours)
```rust
// src/render/camera.rs
pub struct Camera {
    pub position: Vec3,
    pub target: Vec3,
    pub zoom: f32,
    pub viewport: Rect,
}

impl Camera {
    pub fn world_to_screen(&self, world_pos: Vec3) -> Vec2;
    pub fn screen_to_world(&self, screen_pos: Vec2) -> Vec3;
}
```
- [ ] Implement Camera structure
- [ ] Add view/projection matrices
- [ ] Implement world-to-screen conversion
- [ ] Add camera movement (pan, zoom)
- [ ] Support multiple camera modes

**4. Resource Management** (4 hours)
- [ ] Implement texture loader
- [ ] Create resource cache
- [ ] Add sprite atlas support
- [ ] Implement resource unloading

**5. Testing** (4 hours)
- [ ] Create test window
- [ ] Draw simple shapes
- [ ] Test camera transformations
- [ ] Verify coordinate conversions
- [ ] Test resource loading

#### Deliverables
- ✅ SDL2 rendering system
- ✅ Camera system
- ✅ Resource management
- ✅ Rendering abstractions
- ✅ Test application

#### Success Criteria
- [ ] Window opens at 1080p
- [ ] Can draw basic shapes
- [ ] Camera pan/zoom works smoothly
- [ ] Frame rate is stable (60 FPS)
- [ ] Clean shutdown on exit

---

### Stage 2.2: Track Renderer (2D)

**Duration:** 4 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 2.1

#### Objectives
- Render tracks from loaded data
- Draw track outline and surface
- Visualize racing line
- Add trackside objects
- Optimize rendering performance

#### Tasks

**1. Basic Track Rendering** (6 hours)
```rust
// src/render/track_renderer.rs
pub struct TrackRenderer {
    // Cached rendering data
    track_mesh: Vec<Vertex>,
    racing_line_mesh: Vec<Vertex>,
}

impl TrackRenderer {
    pub fn new(track: &Track) -> Self;
    pub fn render(&self, renderer: &mut dyn Renderer, camera: &Camera);
}
```
- [ ] Generate track mesh from segments
- [ ] Render track surface
- [ ] Draw track boundaries
- [ ] Add proper depth sorting
- [ ] Optimize with batching

**2. Racing Line Visualization** (3 hours)
- [ ] Draw racing line as colored path
- [ ] Show braking zones
- [ ] Visualize acceleration zones
- [ ] Add speed hints (color-coded)

**3. Track Details** (6 hours)
- [ ] Draw kerbs (alternating colors)
- [ ] Add run-off areas
- [ ] Draw pit lane
- [ ] Add grid positions
- [ ] Render start/finish line

**4. Scenery Objects** (6 hours)
- [ ] Place grandstands
- [ ] Add barriers/walls
- [ ] Place trees/buildings
- [ ] Add sponsor boards
- [ ] Optimize culling (only draw visible objects)

**5. Visual Polish** (4 hours)
- [ ] Add shadows
- [ ] Improve colors/textures
- [ ] Add track surface detail
- [ ] Implement LOD (level of detail)
- [ ] Smooth rendering at high zoom

#### Deliverables
- ✅ Complete track renderer
- ✅ Racing line visualization
- ✅ Trackside scenery
- ✅ Performance optimizations
- ✅ Visual polish

#### Success Criteria
- [ ] All 16 tracks render correctly
- [ ] Tracks are recognizable
- [ ] 60 FPS at 1080p
- [ ] Racing line is accurate
- [ ] Scenery adds realism

---

### Stage 2.3: Car Data Loader

**Duration:** 3 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 1.4

#### Objectives
- Load car specifications from original files
- Parse team/driver data
- Load performance characteristics
- Create car database
- Validate data

#### Tasks

**1. Car File Parser** (6 hours)
```rust
// src/data/formats/f1car.rs
pub fn parse_car_file(data: &[u8]) -> Result<CarSpec> {
    // Parse binary car data
}
```
- [ ] Parse car header
- [ ] Extract performance data
- [ ] Load engine specifications
- [ ] Parse aerodynamic data
- [ ] Extract visual data (livery)

**2. Team/Driver Loader** (4 hours)
- [ ] Parse team names
- [ ] Load driver names
- [ ] Extract driver numbers
- [ ] Load team colors
- [ ] Parse driver skill ratings

**3. Car Database** (4 hours)
```rust
// src/data/car.rs
pub struct CarDatabase {
    cars: HashMap<String, CarSpec>,
    teams: HashMap<String, Team>,
    drivers: HashMap<String, Driver>,
}

impl CarDatabase {
    pub fn load_from_directory(path: &Path) -> Result<Self>;
    pub fn get_car(&self, name: &str) -> Option<&CarSpec>;
}
```
- [ ] Create database structure
- [ ] Implement loading all cars
- [ ] Add query methods
- [ ] Cache loaded data
- [ ] Add validation

**4. Data Validation** (3 hours)
- [ ] Validate performance ranges
- [ ] Check for missing data
- [ ] Verify team/driver relationships
- [ ] Compare to known values
- [ ] Report inconsistencies

**5. Documentation** (3 hours)
- [ ] Document car parameters
- [ ] Explain performance values
- [ ] Create car comparison charts
- [ ] Document loading process

#### Deliverables
- ✅ Car data loader
- ✅ Car database
- ✅ Team/driver data
- ✅ Validation system
- ✅ Documentation

#### Success Criteria
- [ ] All cars load successfully
- [ ] Performance data is reasonable
- [ ] Team/driver data is complete
- [ ] Validation catches errors
- [ ] Documentation is clear

---

### Stage 2.4: Car Renderer (2D)

**Duration:** 3 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 2.2, Stage 2.3

#### Objectives
- Render cars on track
- Show car liveries
- Animate car movement
- Add visual effects
- Optimize rendering

#### Tasks

**1. Car Sprite System** (6 hours)
- [ ] Extract original car sprites
- [ ] Convert to modern format
- [ ] Create sprite rotations (8-16 directions)
- [ ] Add team liveries
- [ ] Implement sprite caching

**2. Car Renderer** (6 hours)
```rust
// src/render/car_renderer.rs
pub struct CarRenderer {
    sprites: HashMap<String, CarSprites>,
}

impl CarRenderer {
    pub fn render_car(
        &self,
        renderer: &mut dyn Renderer,
        car: &CarState,
        camera: &Camera
    );
}
```
- [ ] Implement car rendering
- [ ] Select correct sprite for angle
- [ ] Apply team colors
- [ ] Handle sprite scaling
- [ ] Add depth sorting

**3. Visual Effects** (4 hours)
- [ ] Add tire smoke when sliding
- [ ] Show dust/debris
- [ ] Add sparks (if bottoming out)
- [ ] Implement exhaust effects
- [ ] Add damage visual indicators

**4. UI Elements** (4 hours)
- [ ] Draw driver names above cars
- [ ] Show position numbers
- [ ] Add tire compound indicators
- [ ] Display damage indicators
- [ ] Show pit status

**5. Performance** (3 hours)
- [ ] Batch render all cars
- [ ] Implement frustum culling
- [ ] Optimize sprite lookups
- [ ] Profile rendering pipeline

#### Deliverables
- ✅ Car rendering system
- ✅ Car sprites/liveries
- ✅ Visual effects
- ✅ UI overlays
- ✅ Performance optimization

#### Success Criteria
- [ ] Cars render correctly on track
- [ ] Liveries are recognizable
- [ ] Rotation looks smooth
- [ ] Effects enhance realism
- [ ] 60 FPS with 26 cars on track

---

### Phase 2 Milestone: Visual Prototype

**Deliverables:**
- ✅ Track rendering working
- ✅ Car rendering working
- ✅ Basic camera system
- ✅ Visual prototype of race

**Success Criteria:**
- [ ] Can view any track
- [ ] Can see cars on track
- [ ] Rendering is smooth (60 FPS)
- [ ] Visuals are recognizable

**Demo:**
```bash
# Run visual prototype
cargo run --release -- \
  --track monaco \
  --mode prototype \
  --cars 26
```

---

## Phase 3: Physics & Gameplay (Weeks 7-10)

**Goal:** Implement physics engine and make the game playable

---

### Stage 3.1: Physics Engine Core

**Duration:** 5 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 2.4

#### Objectives
- Design physics engine architecture
- Implement numerical integration
- Create physics world
- Add collision detection framework
- Establish physics update loop

#### Tasks

**1. Physics Engine Design** (4 hours)
```rust
// src/physics/engine.rs
pub struct PhysicsEngine {
    world: PhysicsWorld,
    dt: f32,  // Fixed timestep
    accumulator: f32,
}

impl PhysicsEngine {
    pub fn new(dt: f32) -> Self;
    pub fn step(&mut self, dt: f32);
    pub fn add_car(&mut self, car: Car) -> CarHandle;
    pub fn update_car(&mut self, handle: CarHandle, inputs: &Inputs);
}
```
- [ ] Design engine architecture
- [ ] Define update loop structure
- [ ] Choose integration method (RK4 or semi-implicit Euler)
- [ ] Plan collision detection strategy
- [ ] Design state management

**2. Numerical Integration** (6 hours)
```rust
// src/physics/integrator.rs
pub fn integrate_rk4(
    state: &CarState,
    derivative: impl Fn(&CarState) -> Derivative,
    dt: f32
) -> CarState;
```
- [ ] Implement RK4 integrator
- [ ] Test with simple systems
- [ ] Verify stability
- [ ] Add adaptive timestep (optional)
- [ ] Profile performance

**3. Physics World** (6 hours)
- [ ] Implement spatial partitioning
- [ ] Add broad-phase collision detection
- [ ] Create entity management
- [ ] Implement update loop
- [ ] Add debug visualization

**4. Coordinate Systems** (4 hours)
- [ ] Define world coordinates
- [ ] Define car-local coordinates
- [ ] Implement transformations
- [ ] Add helper functions
- [ ] Document conventions

**5. Testing** (6 hours)
- [ ] Create unit tests for integration
- [ ] Test coordinate transformations
- [ ] Verify physics timestep
- [ ] Create simple physics scenarios
- [ ] Profile performance

#### Deliverables
- ✅ Physics engine core
- ✅ Integration system
- ✅ Physics world
- ✅ Coordinate systems
- ✅ Comprehensive tests

#### Success Criteria
- [ ] Physics engine compiles and runs
- [ ] Integration is numerically stable
- [ ] Tests pass
- [ ] Performance is acceptable (< 1ms per car update)
- [ ] Architecture is extensible

---

### Stage 3.2: Car Physics Implementation

**Duration:** 7 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 3.1

#### Objectives
- Implement car dynamics model
- Add tire model (grip, slip)
- Implement aerodynamics
- Add suspension model
- Match original game behavior

#### Tasks

**1. Tire Model** (10 hours)
```rust
// src/physics/tire.rs
pub struct TireModel {
    // Pacejka Magic Formula parameters
    // or simpler brush model
}

impl TireModel {
    pub fn calculate_force(
        &self,
        slip_angle: f32,
        slip_ratio: f32,
        normal_force: f32,
        camber: f32
    ) -> Vec2;  // Lateral and longitudinal forces
}
```
- [ ] Research F1GP tire model (reverse engineer from game)
- [ ] Implement tire force calculation
- [ ] Add slip angle/ratio calculation
- [ ] Model load sensitivity
- [ ] Add temperature effects (if in original)
- [ ] Test tire behavior curves
- [ ] Validate against original game

**2. Aerodynamics** (6 hours)
```rust
// src/physics/aerodynamics.rs
pub struct AeroModel {
    pub front_downforce: f32,
    pub rear_downforce: f32,
    pub drag_coefficient: f32,
}

impl AeroModel {
    pub fn calculate_forces(&self, velocity: Vec3, setup: &CarSetup) -> (Vec3, Vec3);
}
```
- [ ] Implement downforce calculation
- [ ] Add drag forces
- [ ] Model ground effect
- [ ] Account for car setup (wings)
- [ ] Test at various speeds

**3. Suspension Model** (8 hours)
```rust
// src/physics/suspension.rs
pub struct Suspension {
    spring_rate: f32,
    damper_rate: f32,
    ride_height: f32,
    travel: f32,
}

impl Suspension {
    pub fn calculate_force(&self, compression: f32, velocity: f32) -> f32;
}
```
- [ ] Implement spring/damper model
- [ ] Add anti-roll bars
- [ ] Model weight transfer
- [ ] Calculate wheel loads
- [ ] Test bump response

**4. Engine & Drivetrain** (6 hours)
```rust
// src/physics/engine.rs
pub struct Engine {
    power_curve: Vec<(f32, f32)>,
    current_rpm: f32,
}

impl Engine {
    pub fn calculate_torque(&self, rpm: f32, throttle: f32) -> f32;
    pub fn update(&mut self, dt: f32, wheel_speed: f32, gear: i8);
}
```
- [ ] Implement engine model
- [ ] Add gear ratios
- [ ] Model clutch
- [ ] Add transmission
- [ ] Calculate wheel torque

**5. Complete Car Dynamics** (10 hours)
```rust
// src/physics/car.rs
impl Car {
    pub fn calculate_forces(&self, inputs: &Inputs) -> Forces {
        // Combine all forces: tires, aero, gravity, etc.
    }

    pub fn update(&mut self, dt: f32, inputs: &Inputs) {
        // Apply forces and integrate
    }
}
```
- [ ] Integrate all subsystems
- [ ] Calculate total forces and moments
- [ ] Update car state
- [ ] Handle edge cases (airborne, collision, etc.)
- [ ] Add telemetry output

**6. Validation** (8 hours)
- [ ] Compare to original game behavior
- [ ] Test cornering speeds
- [ ] Verify braking distances
- [ ] Check top speeds
- [ ] Validate lap times
- [ ] Adjust parameters to match original

#### Deliverables
- ✅ Complete car physics model
- ✅ Tire model
- ✅ Aerodynamics
- ✅ Suspension
- ✅ Engine/drivetrain
- ✅ Validated against original

#### Success Criteria
- [ ] Car behaves realistically
- [ ] Physics match original game
- [ ] Lap times are comparable
- [ ] Car handling feels authentic
- [ ] Performance is good (60 FPS)

---

### Stage 3.3: Track Collision System

**Duration:** 4 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 3.2

#### Objectives
- Implement track collision detection
- Keep cars on track
- Handle barriers and walls
- Add gravel/grass physics
- Implement damage system

#### Tasks

**1. Track Bounds Collision** (6 hours)
```rust
// src/physics/collision.rs
pub struct TrackCollision {
    track: Arc<Track>,
    spatial_index: KdTree,
}

impl TrackCollision {
    pub fn check_collision(&self, car: &CarState) -> Option<CollisionInfo>;
    pub fn resolve_collision(&self, car: &mut CarState, collision: &CollisionInfo);
}
```
- [ ] Build spatial index for track
- [ ] Implement point-in-polygon test
- [ ] Detect off-track excursions
- [ ] Calculate penetration depth
- [ ] Resolve collisions (push car back)

**2. Wall/Barrier Collision** (6 hours)
- [ ] Detect car-wall collisions
- [ ] Calculate collision normal
- [ ] Apply impulse-based response
- [ ] Add energy loss (damage)
- [ ] Handle corner cases (car stuck)

**3. Surface Properties** (4 hours)
```rust
pub enum SurfaceType {
    Asphalt { grip: f32 },
    Grass { grip: f32 },
    Gravel { grip: f32 },
    Kerb { grip: f32 },
}
```
- [ ] Define surface types
- [ ] Modify tire grip per surface
- [ ] Add surface-specific effects
- [ ] Test on different surfaces

**4. Damage System** (4 hours)
```rust
pub struct Damage {
    pub front_wing: f32,     // 0.0 - 1.0
    pub suspension: f32,
    pub engine: f32,
    pub gearbox: f32,
}
```
- [ ] Implement damage accumulation
- [ ] Affect car performance based on damage
- [ ] Visual damage indicators
- [ ] Terminal damage (retirement)

**5. Testing** (4 hours)
- [ ] Test collision detection accuracy
- [ ] Verify collision response
- [ ] Test off-track behavior
- [ ] Validate damage accumulation
- [ ] Performance testing

#### Deliverables
- ✅ Track collision system
- ✅ Wall/barrier collision
- ✅ Surface physics
- ✅ Damage system
- ✅ Comprehensive tests

#### Success Criteria
- [ ] Cars stay on track (unless crashed)
- [ ] Collisions feel realistic
- [ ] Grass/gravel slow cars appropriately
- [ ] Damage affects performance
- [ ] No physics glitches

---

### Stage 3.4: Input Handling

**Duration:** 3 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 3.2

#### Objectives
- Implement keyboard input
- Add gamepad support
- Create input mapping system
- Add control assists (if in original)
- Support input recording/playback

#### Tasks

**1. Input System** (6 hours)
```rust
// src/platform/input.rs
pub struct InputManager {
    keyboard_state: KeyboardState,
    gamepad_state: Option<GamepadState>,
    mappings: InputMappings,
}

pub struct Inputs {
    pub throttle: f32,     // 0.0 - 1.0
    pub brake: f32,        // 0.0 - 1.0
    pub steering: f32,     // -1.0 to 1.0
    pub gear_up: bool,
    pub gear_down: bool,
}

impl InputManager {
    pub fn poll(&mut self) -> Inputs;
}
```
- [ ] Implement keyboard input
- [ ] Add analog input support (gamepad)
- [ ] Create input mapping
- [ ] Add configurable controls
- [ ] Implement input smoothing

**2. Gamepad Support** (4 hours)
- [ ] Detect connected gamepads
- [ ] Map gamepad axes to controls
- [ ] Add button mapping
- [ ] Implement dead zones
- [ ] Test with Xbox/PS controllers

**3. Driving Assists** (4 hours)
- [ ] Auto-braking (if in original)
- [ ] Traction control
- [ ] ABS (if in original)
- [ ] Steering assist
- [ ] Make assists configurable

**4. Input Recording** (3 hours)
```rust
pub struct InputRecorder {
    recording: Vec<(f32, Inputs)>,  // (timestamp, inputs)
}
```
- [ ] Record input sequences
- [ ] Playback recordings
- [ ] Save/load to file
- [ ] Use for testing and demos

**5. Testing** (3 hours)
- [ ] Test keyboard controls
- [ ] Test gamepad controls
- [ ] Verify input responsiveness
- [ ] Test edge cases (unplugged controller, etc.)

#### Deliverables
- ✅ Complete input system
- ✅ Keyboard support
- ✅ Gamepad support
- ✅ Driving assists
- ✅ Input recording

#### Success Criteria
- [ ] Controls are responsive
- [ ] Gamepad works smoothly
- [ ] Assists help novice players
- [ ] Input can be remapped
- [ ] No input lag

---

### Stage 3.5: Basic Playable Game

**Duration:** 4 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 3.3, Stage 3.4

#### Objectives
- Integrate all systems
- Create practice/time trial mode
- Add basic UI (lap times, position)
- Make the game playable
- Initial gameplay testing

#### Tasks

**1. Game Loop Integration** (6 hours)
```rust
// src/game/race.rs
pub struct RaceManager {
    track: Track,
    player_car: Car,
    physics: PhysicsEngine,
    renderer: Renderer,
}

impl RaceManager {
    pub fn update(&mut self, dt: f32) {
        // Update physics
        // Update AI (none yet)
        // Handle input
        // Update camera
    }

    pub fn render(&mut self) {
        // Render track
        // Render cars
        // Render UI
    }
}
```
- [ ] Integrate physics with rendering
- [ ] Implement fixed timestep game loop
- [ ] Add frame rate limiting
- [ ] Handle pause/resume
- [ ] Add state management

**2. Lap Timing** (4 hours)
```rust
pub struct LapTimer {
    current_lap: u32,
    sector_times: [Option<f32>; 3],
    lap_times: Vec<f32>,
    best_lap: Option<f32>,
}
```
- [ ] Detect lap completion
- [ ] Calculate sector times
- [ ] Track best lap
- [ ] Store lap history
- [ ] Implement sector timing

**3. HUD Implementation** (6 hours)
- [ ] Display current lap time
- [ ] Show best lap
- [ ] Display speed
- [ ] Show gear, RPM
- [ ] Add delta time (vs best lap)
- [ ] Display damage indicators

**4. Camera Following** (4 hours)
- [ ] Implement chase camera
- [ ] Add cockpit view (if sprites available)
- [ ] Add TV camera angles
- [ ] Smooth camera movement
- [ ] Add camera switching

**5. Practice Mode** (4 hours)
- [ ] Load track and car
- [ ] Start on grid
- [ ] Free practice (no AI)
- [ ] Reset to pits
- [ ] Exit to menu

#### Deliverables
- ✅ Playable practice mode
- ✅ Complete game loop
- ✅ Lap timing system
- ✅ Basic HUD
- ✅ Camera system

#### Success Criteria
- [ ] Can drive laps around track
- [ ] Lap times are recorded
- [ ] HUD shows relevant info
- [ ] Game runs at 60 FPS
- [ ] Controls feel good

---

### Phase 3 Milestone: Playable Demo

**Deliverables:**
- ✅ Physics engine working
- ✅ Car handles realistically
- ✅ Track collision working
- ✅ Input system functional
- ✅ Practice mode playable

**Success Criteria:**
- [ ] Can complete laps
- [ ] Physics feel authentic
- [ ] Performance is good
- [ ] Game is fun to play
- [ ] No major bugs

**Demo:**
```bash
# Play practice mode
cargo run --release -- \
  --mode practice \
  --track monaco \
  --car mclaren
```

---

## Phase 4: AI & Complete Race (Weeks 11-14)

**Goal:** Implement AI opponents and complete race functionality

---

### Stage 4.1: AI System Foundation

**Duration:** 4 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 3.5

#### Objectives
- Design AI architecture
- Implement path following
- Create AI driver framework
- Add basic steering/throttle AI
- Set up AI testing framework

#### Tasks

**1. AI Architecture** (4 hours)
```rust
// src/ai/mod.rs
pub struct AIDriver {
    car_handle: CarHandle,
    personality: DriverPersonality,
    racing_line: RacingLine,
    target_speed: f32,
    state: AIState,
}

pub enum AIState {
    Racing,
    Overtaking,
    Defending,
    Pitting,
}
```
- [ ] Design AI system structure
- [ ] Define AI states
- [ ] Create driver personality system
- [ ] Plan behavior tree or FSM
- [ ] Document AI design

**2. Path Following** (8 hours)
```rust
// src/ai/racing_line.rs
pub struct RacingLine {
    points: Vec<RacingLinePoint>,
    speeds: Vec<f32>,
}

impl RacingLine {
    pub fn get_target_point(&self, car_pos: Vec3, lookahead: f32) -> RacingLinePoint;
    pub fn get_target_speed(&self, car_pos: Vec3) -> f32;
}
```
- [ ] Load racing line from track data
- [ ] Implement path following algorithm (Pure Pursuit or similar)
- [ ] Calculate lookahead distance
- [ ] Determine target point
- [ ] Calculate steering angle
- [ ] Test path following accuracy

**3. Speed Control** (6 hours)
```rust
// src/ai/driver.rs
impl AIDriver {
    fn calculate_throttle_brake(&self, target_speed: f32, current_speed: f32) -> (f32, f32) {
        // PID controller or similar
    }
}
```
- [ ] Implement speed controller (PID)
- [ ] Calculate braking points
- [ ] Smooth throttle application
- [ ] Handle different conditions (wet, damage)
- [ ] Tune for realistic driving

**4. Driver Personalities** (4 hours)
```rust
pub struct DriverPersonality {
    aggression: f32,         // Overtaking behavior
    consistency: f32,        // Mistake frequency
    skill: f32,             // Overall speed
    wet_skill: f32,         // Wet weather performance
}
```
- [ ] Define personality parameters
- [ ] Create personalities for all drivers (match original)
- [ ] Apply to AI behavior
- [ ] Test personality differences

**5. AI Testing** (4 hours)
- [ ] Create AI test scenarios
- [ ] Visualize AI path and targets
- [ ] Add telemetry for AI
- [ ] Create debugging tools
- [ ] Measure AI lap times

#### Deliverables
- ✅ AI driver framework
- ✅ Path following system
- ✅ Speed control
- ✅ Driver personalities
- ✅ Testing tools

#### Success Criteria
- [ ] AI can follow racing line
- [ ] AI completes laps
- [ ] AI speed control is smooth
- [ ] Different personalities visible
- [ ] Lap times are reasonable

---

### Stage 4.2: AI Racing Line & Behavior

**Duration:** 6 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 4.1

#### Objectives
- Optimize racing line calculation
- Implement overtaking behavior
- Add defending position logic
- Handle multi-car interactions
- Match original AI behavior

#### Tasks

**1. Racing Line Optimization** (8 hours)
- [ ] Analyze original game racing lines
- [ ] Calculate optimal racing line
- [ ] Account for car setup
- [ ] Add qualifying vs race lines
- [ ] Store optimized lines per track

**2. Overtaking Logic** (10 hours)
```rust
impl AIDriver {
    fn should_attempt_overtake(&self, car_ahead: &CarState) -> bool;
    fn calculate_overtake_path(&self, car_ahead: &CarState) -> Path;
}
```
- [ ] Detect cars ahead
- [ ] Identify overtaking opportunities
- [ ] Calculate alternate paths (inside/outside)
- [ ] Execute overtaking maneuvers
- [ ] Return to racing line
- [ ] Handle failed overtakes
- [ ] Match original AI aggression

**3. Defending Position** (6 hours)
- [ ] Detect cars behind
- [ ] Move to inside line when appropriate
- [ ] Balance defense with lap time
- [ ] Avoid blocking penalties (if in original)
- [ ] Realistic defense behavior

**4. Multi-Car Awareness** (8 hours)
```rust
pub struct TrackState {
    cars: Vec<CarState>,
    gaps: HashMap<(usize, usize), f32>,
}

impl AIDriver {
    fn get_nearby_cars(&self, track_state: &TrackState) -> Vec<&CarState>;
    fn avoid_collision(&self, nearby: &[&CarState]) -> SteeringAdjustment;
}
```
- [ ] Track all car positions
- [ ] Calculate gaps between cars
- [ ] Implement collision avoidance
- [ ] Handle side-by-side racing
- [ ] Prevent AI car collisions

**5. Behavioral Tuning** (10 hours)
- [ ] Tune AI lap times to match original
- [ ] Adjust overtaking frequency
- [ ] Balance aggression levels
- [ ] Set mistake probability
- [ ] Match driver skill differences
- [ ] Validate against original replays

#### Deliverables
- ✅ Optimized racing lines
- ✅ Overtaking system
- ✅ Defensive driving
- ✅ Multi-car awareness
- ✅ Tuned AI behavior

#### Success Criteria
- [ ] AI lap times match original (±2%)
- [ ] Overtaking looks realistic
- [ ] Multi-car battles happen
- [ ] No AI crashes (unless realistic)
- [ ] Driver skill differences clear

---

### Stage 4.3: Race Session Management

**Duration:** 5 days
**Priority:** P0 (Critical)
**Dependencies:** Stage 4.2

#### Objectives
- Implement full race weekend structure
- Add practice/qualifying/race sessions
- Handle grid formation
- Implement race start sequence
- Add race rules and penalties

#### Tasks

**1. Session Manager** (6 hours)
```rust
// src/game/session.rs
pub enum SessionType {
    Practice,
    Qualifying,
    Race,
}

pub struct Session {
    session_type: SessionType,
    duration: f32,
    cars: Vec<Car>,
    results: SessionResults,
}

impl Session {
    pub fn new(session_type: SessionType, track: Track, cars: Vec<Car>) -> Self;
    pub fn update(&mut self, dt: f32);
    pub fn is_finished(&self) -> bool;
}
```
- [ ] Implement session structure
- [ ] Handle session timing
- [ ] Manage session transitions
- [ ] Store session results
- [ ] Create session UI

**2. Qualifying System** (6 hours)
- [ ] Implement qualifying rules (1991 style)
- [ ] Track best lap times
- [ ] Form starting grid
- [ ] Handle qualifying strategies
- [ ] Display qualifying results

**3. Race Start** (6 hours)
```rust
pub struct RaceStart {
    state: StartState,
    lights: Vec<bool>,
    jump_start_detection: HashMap<usize, bool>,
}

pub enum StartState {
    Formation,
    GridPositions,
    Lights,
    Racing,
}
```
- [ ] Formation lap (if in original)
- [ ] Grid formation
- [ ] Starting lights sequence
- [ ] Detect jump starts
- [ ] Handle start crashes
- [ ] Match original start behavior

**4. Race Rules** (6 hours)
- [ ] Implement flag system (yellow, black, etc.)
- [ ] Detect illegal overtakes
- [ ] Handle pit lane rules
- [ ] Implement penalties
- [ ] Track blue flags (lapping)
- [ ] Match 1991 F1 rules

**5. Race Results** (4 hours)
```rust
pub struct RaceResults {
    finishing_positions: Vec<(Driver, u32, f32)>,  // (driver, position, time)
    fastest_lap: Option<(Driver, f32)>,
    dnfs: Vec<(Driver, Reason)>,
}
```
- [ ] Track finishing order
- [ ] Calculate race time
- [ ] Identify fastest lap
- [ ] Handle DNFs
- [ ] Display results screen

#### Deliverables
- ✅ Session manager
- ✅ Qualifying system
- ✅ Race start sequence
- ✅ Race rules engine
- ✅ Results system

#### Success Criteria
- [ ] Full race weekend works
- [ ] Qualifying sets grid correctly
- [ ] Race start is authentic
- [ ] Rules are enforced
- [ ] Results are accurate

---

### Stage 4.4: Audio System

**Duration:** 4 days
**Priority:** P1 (High)
**Dependencies:** Stage 3.5

#### Objectives
- Implement audio engine
- Add engine sounds (synthesized)
- Add collision/effects sounds
- Implement 3D positional audio
- Match original audio feel

#### Tasks

**1. Audio Engine Setup** (4 hours)
```rust
// src/audio/mod.rs
use rodio::{OutputStream, Sink};

pub struct AudioEngine {
    _stream: OutputStream,
    sound_effects: HashMap<String, Sink>,
    engine_sounds: HashMap<usize, EngineSoundGenerator>,
}

impl AudioEngine {
    pub fn new() -> Result<Self>;
    pub fn play_sound(&mut self, sound: &str, volume: f32);
    pub fn update_engine_sound(&mut self, car_id: usize, rpm: f32);
}
```
- [ ] Initialize rodio audio system
- [ ] Create sound effect manager
- [ ] Implement volume control
- [ ] Add spatial audio support
- [ ] Handle audio device selection

**2. Engine Sound Synthesis** (8 hours)
```rust
// src/audio/engine_sound.rs
pub struct EngineSoundGenerator {
    sample_rate: u32,
    harmonics: Vec<(f32, f32)>,  // (frequency_ratio, amplitude)
}

impl EngineSoundGenerator {
    pub fn generate_sample(&mut self, rpm: f32) -> f32;
}
```
- [ ] Research engine sound synthesis
- [ ] Implement harmonic generation
- [ ] Map RPM to frequencies
- [ ] Add exhaust note characteristics
- [ ] Tune for realistic sound
- [ ] Support different engine types

**3. Sound Effects** (4 hours)
- [ ] Tire squeal sounds
- [ ] Collision/crash sounds
- [ ] Gearshift sounds
- [ ] Wind/ambient sounds
- [ ] UI sounds (menu clicks)
- [ ] Load or synthesize effects

**4. 3D Positional Audio** (4 hours)
```rust
impl AudioEngine {
    pub fn update_listener(&mut self, pos: Vec3, forward: Vec3);
    pub fn play_3d_sound(&mut self, sound: &str, pos: Vec3, volume: f32);
}
```
- [ ] Implement listener position
- [ ] Calculate sound attenuation by distance
- [ ] Add stereo panning
- [ ] Doppler effect (if feasible)
- [ ] Test with moving sound sources

**5. Audio Mixing** (4 hours)
- [ ] Mix engine sounds from all cars
- [ ] Prioritize nearby sounds
- [ ] Limit active sound sources
- [ ] Balance sound levels
- [ ] Add master volume control

#### Deliverables
- ✅ Audio engine
- ✅ Engine sound synthesis
- ✅ Sound effects
- ✅ 3D positional audio
- ✅ Audio mixing

#### Success Criteria
- [ ] Engine sounds are realistic
- [ ] 3D audio works correctly
- [ ] Sound effects enhance gameplay
- [ ] Audio performance is good
- [ ] No audio glitches

---

### Phase 4 Milestone: Complete Race

**Deliverables:**
- ✅ AI opponents working
- ✅ Full race sessions
- ✅ Race start sequence
- ✅ Audio system
- ✅ Complete race experience

**Success Criteria:**
- [ ] Can race against AI
- [ ] AI is competitive
- [ ] Full race weekend works
- [ ] Audio enhances immersion
- [ ] Game feels complete

**Demo:**
```bash
# Run full race
cargo run --release -- \
  --mode race \
  --track silverstone \
  --laps 10 \
  --difficulty medium
```

---

## Phase 5: Polish & Features (Weeks 15-16)

**Goal:** Add championship mode, car setup, polish UI, optimize performance

---

### Stage 5.1: Championship Mode

**Duration:** 4 days
**Priority:** P1 (High)
**Dependencies:** Stage 4.3

#### Objectives
- Implement championship progression
- Add points system
- Save/load championship state
- Create season calendar
- Implement driver standings

#### Tasks

**1. Championship Structure** (6 hours)
```rust
// src/game/championship.rs
pub struct Championship {
    season: u32,
    calendar: Vec<Race>,
    driver_standings: Vec<(Driver, u32)>,  // points
    constructor_standings: Vec<(Team, u32)>,
    current_round: usize,
}

impl Championship {
    pub fn new(season: u32) -> Self;
    pub fn next_race(&mut self) -> Option<&Race>;
    pub fn update_standings(&mut self, results: &RaceResults);
}
```
- [ ] Define championship structure
- [ ] Create 1991 calendar (16 races)
- [ ] Implement points system (10-6-4-3-2-1 for top 6)
- [ ] Track standings
- [ ] Handle season progression

**2. Save/Load System** (6 hours)
```rust
pub fn save_championship(championship: &Championship, path: &Path) -> Result<()>;
pub fn load_championship(path: &Path) -> Result<Championship>;
```
- [ ] Serialize championship state
- [ ] Save to file
- [ ] Load from file
- [ ] Handle save corruption
- [ ] Create save file UI

**3. Season Simulation** (4 hours)
- [ ] Simulate races player doesn't attend (if feature)
- [ ] Apply realistic results
- [ ] Handle AI championships
- [ ] Update standings

**4. Championship UI** (6 hours)
- [ ] Create standings screen
- [ ] Show calendar
- [ ] Display next race info
- [ ] Show season progress
- [ ] Add charts/graphs

#### Deliverables
- ✅ Championship mode
- ✅ Save/load system
- ✅ Season calendar
- ✅ Standings tracking
- ✅ Championship UI

#### Success Criteria
- [ ] Can play full season
- [ ] Standings update correctly
- [ ] Save/load works reliably
- [ ] UI is clear
- [ ] Feels authentic

---

### Stage 5.2: Car Setup System

**Duration:** 3 days
**Priority:** P1 (High)
**Dependencies:** Stage 4.4

#### Objectives
- Implement car setup screen
- Add setup options (wings, gears, etc.)
- Apply setups to car physics
- Save/load setups
- Match original setup system

#### Tasks

**1. Setup Data Structure** (4 hours)
```rust
// src/data/setup.rs
pub struct CarSetup {
    pub front_wing: u32,        // 1-20
    pub rear_wing: u32,         // 1-20
    pub gear_ratios: [u32; 6],  // Gear ratios
    pub brake_balance: u32,     // Front/rear balance
    pub tire_compound: TireCompound,
}
```
- [ ] Define setup structure
- [ ] Set parameter ranges (from original)
- [ ] Create default setups
- [ ] Add validation

**2. Setup Screen** (6 hours)
- [ ] Design setup UI
- [ ] Create sliders/controls
- [ ] Show car diagram
- [ ] Display effect of changes
- [ ] Allow saving presets
- [ ] Match original UI style

**3. Physics Integration** (4 hours)
```rust
impl CarSpec {
    pub fn apply_setup(&mut self, setup: &CarSetup) {
        self.aerodynamics.front_downforce = calculate_downforce(setup.front_wing);
        // etc.
    }
}
```
- [ ] Apply wing settings to aero model
- [ ] Apply gear ratios to drivetrain
- [ ] Apply brake balance
- [ ] Apply tire compound to grip
- [ ] Test setup effects

**4. Setup Presets** (3 hours)
- [ ] Create track-specific presets
- [ ] Add quick setup options (qualifying, race, wet)
- [ ] Save custom setups
- [ ] Load setups

#### Deliverables
- ✅ Car setup system
- ✅ Setup screen
- ✅ Physics integration
- ✅ Setup presets
- ✅ Save/load setups

#### Success Criteria
- [ ] Setup affects car performance
- [ ] UI is intuitive
- [ ] Can save custom setups
- [ ] Presets are useful
- [ ] Matches original functionality

---

### Stage 5.3: UI/Menus Polish

**Duration:** 4 days
**Priority:** P1 (High)
**Dependencies:** Stage 5.1, Stage 5.2

#### Objectives
- Create professional menu system
- Add all necessary screens
- Polish in-game UI
- Add visual feedback
- Match original aesthetics

#### Tasks

**1. Main Menu** (6 hours)
- [ ] Design main menu
- [ ] Add options: Championship, Race, Practice, Options
- [ ] Add background (track animation?)
- [ ] Add music/sound
- [ ] Smooth transitions

**2. Options Screen** (4 hours)
- [ ] Graphics settings (resolution, fullscreen)
- [ ] Audio settings (volume, device)
- [ ] Control settings (key mapping)
- [ ] Gameplay settings (assists, difficulty)
- [ ] Save preferences

**3. In-Game UI Polish** (6 hours)
- [ ] Improve HUD layout
- [ ] Add better fonts
- [ ] Add icons/graphics
- [ ] Improve timing displays
- [ ] Add mini-map (if not in original, optional)

**4. Race Results Screen** (4 hours)
- [ ] Display finishing positions
- [ ] Show lap times
- [ ] Highlight player
- [ ] Show championship impact
- [ ] Add replay option

**5. Visual Feedback** (4 hours)
- [ ] Add button hover effects
- [ ] Menu selection sounds
- [ ] Loading screens
- [ ] Transitions and animations
- [ ] Error messages

#### Deliverables
- ✅ Complete menu system
- ✅ Options screen
- ✅ Polished HUD
- ✅ Results screens
- ✅ Visual polish

#### Success Criteria
- [ ] Menus are intuitive
- [ ] UI looks professional
- [ ] All options work
- [ ] Visual feedback is clear
- [ ] Feels polished

---

### Stage 5.4: Performance Optimization

**Duration:** 4 days
**Priority:** P0 (Critical)
**Dependencies:** All previous stages

#### Objectives
- Profile performance
- Optimize rendering
- Optimize physics
- Reduce memory usage
- Target 60 FPS consistently

#### Tasks

**1. Profiling** (4 hours)
- [ ] Set up cargo-flamegraph
- [ ] Profile rendering pipeline
- [ ] Profile physics update
- [ ] Profile AI update
- [ ] Identify bottlenecks

**2. Rendering Optimization** (8 hours)
- [ ] Implement frustum culling
- [ ] Batch draw calls
- [ ] Optimize sprite rendering
- [ ] Reduce overdraw
- [ ] Use texture atlases
- [ ] Profile and verify improvements

**3. Physics Optimization** (6 hours)
- [ ] Optimize collision detection
- [ ] Reduce unnecessary calculations
- [ ] Use SIMD where possible (via glam)
- [ ] Cache computed values
- [ ] Profile improvements

**4. Memory Optimization** (4 hours)
- [ ] Reduce allocations in hot paths
- [ ] Use object pooling
- [ ] Optimize data structures
- [ ] Profile memory usage
- [ ] Fix memory leaks (if any)

**5. Multi-threading** (6 hours)
- [ ] Parallelize AI updates
- [ ] Parallelize physics (if feasible)
- [ ] Use rayon for parallel iteration
- [ ] Test on multi-core systems
- [ ] Ensure thread safety

#### Deliverables
- ✅ Performance profiling reports
- ✅ Rendering optimizations
- ✅ Physics optimizations
- ✅ Memory improvements
- ✅ Multi-threading where applicable

#### Success Criteria
- [ ] 60 FPS at 1080p consistently
- [ ] 30+ FPS at 4K
- [ ] Memory usage < 500MB
- [ ] No frame drops during races
- [ ] Fast loading times (< 5s)

---

### Stage 5.5: Testing & Bug Fixes

**Duration:** 3 days
**Priority:** P0 (Critical)
**Dependencies:** All previous stages

#### Objectives
- Comprehensive testing
- Fix all critical bugs
- Validate against original game
- Performance testing
- Prepare for release

#### Tasks

**1. Functional Testing** (6 hours)
- [ ] Test all game modes
- [ ] Test all tracks
- [ ] Test all cars
- [ ] Test edge cases
- [ ] Create bug list

**2. Physics Validation** (4 hours)
- [ ] Compare lap times to original
- [ ] Validate car handling
- [ ] Test collision detection
- [ ] Verify AI behavior
- [ ] Document differences

**3. Bug Fixes** (10 hours)
- [ ] Fix critical bugs
- [ ] Fix high-priority bugs
- [ ] Fix UI issues
- [ ] Fix performance issues
- [ ] Retest after fixes

**4. Cross-Platform Testing** (4 hours)
- [ ] Test on Windows 10
- [ ] Test on Windows 11
- [ ] Test on Linux (if supported)
- [ ] Test different hardware
- [ ] Document platform issues

**5. User Testing** (4 hours)
- [ ] Get feedback from testers
- [ ] Identify usability issues
- [ ] Gather performance data
- [ ] Prioritize improvements
- [ ] Make final adjustments

#### Deliverables
- ✅ Comprehensive test results
- ✅ Bug fix list
- ✅ Validation report
- ✅ Performance benchmarks
- ✅ Release candidate

#### Success Criteria
- [ ] No critical bugs
- [ ] Physics validated
- [ ] Performance targets met
- [ ] Positive user feedback
- [ ] Ready for release

---

### Phase 5 Milestone: Feature Complete

**Deliverables:**
- ✅ Championship mode
- ✅ Car setup system
- ✅ Polished UI
- ✅ Optimized performance
- ✅ Thoroughly tested

**Success Criteria:**
- [ ] All features implemented
- [ ] Game is polished
- [ ] Performance is excellent
- [ ] No critical bugs
- [ ] Ready for v1.0 release

**Release:**
- [ ] Tag v1.0.0
- [ ] Create release notes
- [ ] Build binaries for Windows
- [ ] Create installer (optional)
- [ ] Publish on GitHub

---

## Phase 6: Post-Release & Enhancements (Ongoing)

**Goal:** Cross-platform support, advanced features, community engagement

---

### Stage 6.1: Cross-Platform Support

**Duration:** 1-2 weeks
**Priority:** P2 (Medium)
**Dependencies:** Stage 5.5

#### Objectives
- Port to Linux
- Port to macOS
- Fix platform-specific issues
- Unified build system

#### Tasks
- [ ] Test and fix Linux builds
- [ ] Test and fix macOS builds
- [ ] Handle platform differences
- [ ] CI/CD for all platforms
- [ ] Create release packages

---

### Stage 6.2: Advanced Features

**Duration:** Ongoing
**Priority:** P3 (Low)
**Dependencies:** Stage 6.1

#### Potential Features
1. **Multiplayer**
   - LAN multiplayer
   - Online multiplayer (with server)
   - Hot-seat mode

2. **Graphics Upgrades**
   - Migrate to wgpu for modern 3D
   - 3D car models
   - Improved track rendering
   - Weather effects (rain, fog)
   - Dynamic time of day

3. **Gameplay Features**
   - More seasons (1992, 1993, etc.)
   - Career mode
   - Custom championships
   - Modding support

4. **VR Support**
   - VR headset support
   - Cockpit view
   - Motion controls

5. **Content Creation Tools**
   - Track editor
   - Car livery editor
   - Setup sharing
   - Replay system

---

## Risk Assessment & Mitigation

### Technical Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| **Physics don't match original** | High | High | Early validation, frequent testing, adjust parameters |
| **File formats incompletely documented** | Medium | Medium | Leverage community knowledge, incremental reverse engineering |
| **Performance issues** | Medium | High | Early profiling, optimization throughout, benchmarks |
| **Rendering complexity** | Low | Medium | Start with SDL2 (simpler), upgrade to wgpu later |
| **AI behavior difficult to replicate** | High | Medium | Study original carefully, iterative tuning, accept differences |
| **Cross-platform issues** | Medium | Low | Test early on Linux/Mac, use portable libraries |
| **Audio synthesis quality** | Medium | Low | Use original samples if available, iterate on synthesis |
| **Save file corruption** | Low | Medium | Thorough testing, checksums, backups |

### Project Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| **Scope creep** | High | Medium | Strict phase boundaries, prioritize features |
| **Time overrun** | Medium | Medium | Realistic estimates, track progress, adjust scope |
| **Loss of motivation** | Medium | High | Set achievable milestones, celebrate wins, community support |
| **Legal issues (copyright)** | Low | High | Clean-room implementation, don't distribute original assets |
| **Hardware compatibility** | Medium | Low | Test on various systems, fallback options |

### Mitigation Strategies

1. **Incremental Development**
   - Deliver working software at each milestone
   - Test frequently against original game
   - Adjust course based on findings

2. **Community Engagement**
   - Share progress publicly
   - Accept contributions
   - Leverage existing reverse engineering

3. **Documentation First**
   - Document findings before coding
   - Keep architecture docs current
   - Future maintainers can understand

4. **Quality Over Features**
   - Core gameplay must be solid
   - Advanced features can wait
   - Stability is paramount

5. **Performance Budget**
   - Profile early and often
   - Set performance targets
   - Don't sacrifice performance for features

---

## Quality Gates

### Code Quality Gates
- [ ] All code compiles without warnings
- [ ] Clippy passes (pedantic mode)
- [ ] rustfmt formatting applied
- [ ] No unsafe code without justification
- [ ] Public APIs have doc comments
- [ ] Complex algorithms explained

### Testing Quality Gates
- [ ] Unit tests for all modules
- [ ] Integration tests for systems
- [ ] Code coverage > 80%
- [ ] Physics validated against original
- [ ] Performance benchmarks pass
- [ ] Manual testing complete

### Documentation Quality Gates
- [ ] README is comprehensive
- [ ] Architecture documented
- [ ] File formats documented
- [ ] API docs generated
- [ ] User manual created
- [ ] Build instructions clear

### Performance Quality Gates
- [ ] 60 FPS at 1080p (minimum)
- [ ] 30 FPS at 4K (target)
- [ ] Load times < 5s
- [ ] Memory < 500MB
- [ ] No frame drops
- [ ] Smooth gameplay

### Release Quality Gates
- [ ] No critical bugs
- [ ] No high-priority bugs
- [ ] Physics validated
- [ ] All features complete
- [ ] Performance targets met
- [ ] Cross-platform tested
- [ ] User documentation complete
- [ ] Release notes prepared

---

## Resource Requirements

### Development Tools
- **Rust Toolchain:** Stable 1.75+
- **IDE:** VS Code with rust-analyzer, or CLion
- **Debugger:** lldb or gdb
- **Profiler:** cargo-flamegraph, perf
- **Hex Editor:** ImHex, 010 Editor, or HxD
- **Disassembler:** Ghidra or IDA Free
- **Graphics:** GIMP/Photoshop for assets
- **Version Control:** Git, GitHub

### Hardware Requirements
- **Development Machine:**
  - CPU: Modern quad-core (Intel i5/Ryzen 5 or better)
  - RAM: 16GB minimum
  - GPU: Decent GPU for testing (GTX 1060 or equivalent)
  - Storage: SSD recommended

- **Testing Machines:**
  - Low-end system (integrated graphics)
  - Mid-range system
  - High-end system
  - Multiple OS installs (Windows, Linux, macOS)

### Knowledge Requirements
- **Essential:**
  - Rust programming (intermediate)
  - Game loop architecture
  - Basic physics (kinematics, forces)
  - 2D rendering
  - Git/GitHub

- **Helpful:**
  - 3D graphics (for future)
  - Vehicle dynamics
  - AI/pathfinding
  - Audio synthesis
  - Reverse engineering
  - Assembly (for analysis)

### Time Allocation

| Phase | Duration | Effort (hrs) | Calendar Time |
|-------|----------|--------------|---------------|
| Phase 1: Foundation | 3 weeks | 90-120 | Weeks 1-3 |
| Phase 2: Graphics | 3 weeks | 90-120 | Weeks 4-6 |
| Phase 3: Physics/Gameplay | 4 weeks | 120-160 | Weeks 7-10 |
| Phase 4: AI & Race | 4 weeks | 120-160 | Weeks 11-14 |
| Phase 5: Polish | 2 weeks | 60-80 | Weeks 15-16 |
| Phase 6: Post-Release | Ongoing | Variable | Week 17+ |
| **Total Initial Release** | **16 weeks** | **480-640** | **4 months** |

**Assumptions:**
- 30-40 hours per week (full-time equivalent)
- Single developer
- Some parallel tasks where possible
- Contingency built into estimates

---

## Timeline & Milestones

### Gantt Chart Overview

```
Week 1-3: Phase 1 - Foundation
├── Stage 1.1: Project Setup (Days 1-2)
├── Stage 1.2: ISO Extraction (Days 3-5)
├── Stage 1.3: File Format Documentation (Days 6-10)
├── Stage 1.4: Data Structures (Days 11-13)
└── Stage 1.5: Track Loader (Days 14-17)
    └── MILESTONE 1: Data Extraction ✓

Week 4-6: Phase 2 - Graphics
├── Stage 2.1: Graphics Foundation (Days 18-20)
├── Stage 2.2: Track Renderer (Days 21-24)
├── Stage 2.3: Car Data Loader (Days 25-27)
└── Stage 2.4: Car Renderer (Days 28-30)
    └── MILESTONE 2: Visual Prototype ✓

Week 7-10: Phase 3 - Physics & Gameplay
├── Stage 3.1: Physics Engine Core (Days 31-35)
├── Stage 3.2: Car Physics (Days 36-42)
├── Stage 3.3: Track Collision (Days 43-46)
├── Stage 3.4: Input Handling (Days 47-49)
└── Stage 3.5: Basic Playable Game (Days 50-53)
    └── MILESTONE 3: Playable Demo ✓

Week 11-14: Phase 4 - AI & Complete Race
├── Stage 4.1: AI Foundation (Days 54-57)
├── Stage 4.2: AI Racing & Behavior (Days 58-63)
├── Stage 4.3: Race Session Management (Days 64-68)
└── Stage 4.4: Audio System (Days 69-72)
    └── MILESTONE 4: Complete Race ✓

Week 15-16: Phase 5 - Polish & Features
├── Stage 5.1: Championship Mode (Days 73-76)
├── Stage 5.2: Car Setup (Days 77-79)
├── Stage 5.3: UI/Menus Polish (Days 80-83)
├── Stage 5.4: Performance Optimization (Days 84-87)
└── Stage 5.5: Testing & Bug Fixes (Days 88-90)
    └── MILESTONE 5: Feature Complete ✓
    └── RELEASE: v1.0.0 🚀

Week 17+: Phase 6 - Post-Release
├── Stage 6.1: Cross-Platform (Ongoing)
└── Stage 6.2: Advanced Features (Ongoing)
    └── MILESTONE 6: Enhanced Version ✓
```

### Key Milestones

1. **Milestone 1: Data Extraction** (End of Week 3)
   - All original data accessible
   - Track loading working
   - ~10% complete

2. **Milestone 2: Visual Prototype** (End of Week 6)
   - Can see tracks and cars
   - Rendering system solid
   - ~25% complete

3. **Milestone 3: Playable Demo** (End of Week 10)
   - Can drive laps
   - Physics working
   - ~50% complete

4. **Milestone 4: Complete Race** (End of Week 14)
   - AI opponents
   - Full race
   - ~80% complete

5. **Milestone 5: Feature Complete** (End of Week 16)
   - Championship mode
   - Polished and optimized
   - 100% of planned features
   - **v1.0 Release**

6. **Milestone 6: Enhanced Version** (Ongoing)
   - Cross-platform
   - Advanced features
   - Community contributions

---

## Testing Strategy

### Unit Testing
**Scope:** Individual functions and modules

**Coverage Target:** > 80%

**Examples:**
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_track_loader() {
        let track = TrackLoader::new().load_from_file("test_track.f1ct").unwrap();
        assert_eq!(track.name, "Test Track");
        assert!(track.segments.len() > 0);
    }

    #[test]
    fn test_tire_force_calculation() {
        let tire = TireModel::default();
        let force = tire.calculate_force(0.1, 0.0, 5000.0, 0.0);
        assert!(force.x > 0.0);
    }
}
```

### Integration Testing
**Scope:** System interactions

**Examples:**
- Load track → render → verify output
- Physics update → collision detection → resolution
- AI decision → input generation → car control
- Session management → results → standings update

### Validation Testing
**Scope:** Compare to original game

**Method:**
1. Record original game data (lap times, behavior)
2. Run same scenarios in port
3. Compare results
4. Adjust parameters to match

**Validation Criteria:**
- Lap times within ±2%
- AI finishing order similar
- Car behavior feels same
- Visual appearance similar

### Performance Testing
**Tools:** criterion.rs, flamegraph

**Benchmarks:**
```rust
#[bench]
fn bench_physics_update(b: &mut Bencher) {
    let mut car = Car::default();
    let inputs = Inputs::default();

    b.iter(|| {
        car.update(0.016, &inputs);
    });
}
```

**Targets:**
- Physics update: < 1ms per car
- Rendering: < 16ms per frame (60 FPS)
- AI update: < 5ms for all cars
- Total frame time: < 16ms

### Manual Testing
**Test Plans:**
- Complete race on each track
- Test all game modes
- Test all UI screens
- Test edge cases (crashes, DNFs, etc.)
- Platform-specific testing

### Regression Testing
**Process:**
1. Automated test suite runs on every commit
2. Performance benchmarks tracked over time
3. Visual regression testing (screenshot comparison)
4. Save/load compatibility testing

---

## Appendices

### Appendix A: File Format Reference

#### Track File Format (.F1CT or similar)
```
Offset  | Size | Description
--------|------|------------------
0x0000  | 4    | Magic number / version
0x0004  | 32   | Track name (null-terminated string)
0x0024  | 4    | Track length (float, meters)
0x0028  | 4    | Number of segments
0x002C  | 4    | Segment data offset
0x0030  | 4    | Racing line offset
0x0034  | 4    | Scenery data offset
...

Segment Structure (repeating):
0x0000  | 12   | Position (3x float: x, y, z)
0x000C  | 4    | Width (float)
0x0010  | 4    | Banking (float, radians)
0x0014  | 1    | Surface type (enum)
...
```

*(To be filled in during Stage 1.3)*

### Appendix B: Rust Project Structure

```toml
# Cargo.toml (workspace root)
[workspace]
members = [
    "f1gp-port",
    "tools/extract_iso",
    "tools/track_viewer",
]

[workspace.package]
version = "0.1.0"
edition = "2021"
license = "GPL-3.0"

[workspace.dependencies]
# Shared dependencies
sdl2 = "0.37"
glam = "0.28"
serde = "1.0"
anyhow = "1.0"
```

### Appendix C: Performance Targets

| Metric | Target | Minimum |
|--------|--------|---------|
| Frame Rate (1080p) | 60 FPS | 60 FPS |
| Frame Rate (4K) | 60 FPS | 30 FPS |
| Frame Time | < 16ms | < 33ms |
| Load Time (track) | < 2s | < 5s |
| Load Time (game start) | < 3s | < 5s |
| Memory Usage | < 300MB | < 500MB |
| Physics Update | < 1ms/car | < 2ms/car |
| AI Update | < 5ms total | < 10ms total |

### Appendix D: Keyboard Controls (Default)

| Action | Key |
|--------|-----|
| Throttle | Up Arrow / W |
| Brake | Down Arrow / S |
| Steer Left | Left Arrow / A |
| Steer Right | Right Arrow / D |
| Gear Up | Z |
| Gear Down | X |
| Look Back | Backspace |
| Pause | ESC |
| Camera Change | C |

### Appendix E: Resources & References

**Community Resources:**
- F1GP-WC Forum: https://groups.google.com/g/f1gpwc
- F1GP Official Site: https://sites.google.com/view/f1gpwc
- F1GP Utils GitHub: https://github.com/sdidit/f1gp-utils

**Technical References:**
- Game Physics (Millington): Game physics algorithms
- Real-Time Rendering: Graphics techniques
- AI for Games: AI algorithms and techniques
- Vehicle Dynamics (Milliken): Car physics theory

**Rust Resources:**
- The Rust Programming Language (book)
- Rust Game Development: https://arewegameyet.rs/
- SDL2 Rust bindings: https://github.com/Rust-SDL2/rust-sdl2

**Tools:**
- Ghidra: https://ghidra-sre.org/
- ImHex: https://github.com/WerWolv/ImHex
- DOSBox Debugger: https://www.dosbox.com/wiki/Debugger

### Appendix F: Glossary

- **DOF:** Degrees of Freedom (6 for car: x, y, z, roll, pitch, yaw)
- **RK4:** Runge-Kutta 4th order (numerical integration method)
- **SIMD:** Single Instruction Multiple Data (parallel processing)
- **SDL2:** Simple DirectMedia Layer 2 (cross-platform library)
- **wgpu:** WebGPU implementation in Rust
- **Pacejka:** Magic Formula tire model (commonly used in racing sims)
- **Semi-implicit Euler:** Symplectic integration method (stable for physics)
- **Frustum Culling:** Don't render objects outside camera view
- **LOD:** Level of Detail (reduce detail for distant objects)

---

## Document Change Log

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025.11.14 | Implementation Planning | Initial comprehensive multi-stage plan |

---

**END OF DOCUMENT**

This implementation plan provides a detailed, actionable roadmap for porting F1GP to modern systems using Rust. Each stage includes clear objectives, tasks, deliverables, and success criteria. The plan emphasizes incremental development, validation against the original game, and quality at every step.
