# High-Level Design: Ghidra + Binary Ninja Reverse Engineering Pipeline

**Document Type:** High-Level Design (HLD)
**Version:** 0.1
**Date:** 2025.11.19
**Project:** F1GP Disassembly & Native Port Initiative
**Status:** Draft

---

## Table of Contents
1. [Executive Summary](#executive-summary)
2. [Objectives & Success Criteria](#objectives--success-criteria)
3. [Scope, Assumptions, Constraints](#scope-assumptions-constraints)
4. [Solution Overview](#solution-overview)
5. [Architecture](#architecture)
6. [Detailed Design](#detailed-design)
7. [Environment & Tooling Requirements](#environment--tooling-requirements)
8. [Risk Assessment & Mitigations](#risk-assessment--mitigations)
9. [Milestones & Deliverables](#milestones--deliverables)
10. [Open Questions & Next Actions](#open-questions--next-actions)

---

## Executive Summary
We will establish a dual-tool reverse engineering pipeline that treats **Ghidra** as the authoritative source for understanding the original 16-bit MS-DOS binary (`GP.EXE`) and **Binary Ninja** as the vehicle for lifting vetted routines into modern, analyzable IL suitable for partial auto-translation into 64-bit-native scaffolding. The end result is a continuously updated knowledge base that connects real-mode segmentation semantics to reimplemented Rust/C++ modules in `f1gp-port`, while preserving enough provenance to validate behavior against the DOS release.

Key to success is the shared artifact format (symbol database + typed data schemas) and automation that keeps both tools in sync whenever the disassembly evolves. This design prioritizes:
- Rapid iteration on naming/types inside Ghidra.
- Deterministic exports that Binary Ninja can re-ingest without manual cleanup.
- Incremental lifting of subsystems (physics, AI, rendering) into HLIL/LLVM for comparative testing.
- Traceability from HLIL back to raw addresses for regression investigations.

## Objectives & Success Criteria
- **Centralize truth**: Ghidra project holds canonical segment maps, overlay layout, interrupt usage, I/O ranges.
- **Composable lifts**: Binary Ninja produces HLIL per subsystem, exported as C-like stubs the Rust port can reference.
- **Automated sync**: `scripts/re/refresh_artifacts.py` regenerates JSON/YAML every time Ghidra annotations change, and Binary Ninja headless analysis validates imports within CI.
- **Traceable tests**: Each lifted function has metadata linking to in-game telemetry scenarios for verification.
- **Developer onboarding**: Clear SOPs for tool setup, naming conventions, and review gates.

Success Metrics:
1. ≥90% of executable segments labeled with function or data names.
2. Binary Ninja HLIL generated for top 5 target subsystems (physics, AI, rendering, audio mixing, input) with <5% manual fix-ups each iteration.
3. Round-trip CI job (<15 min) proving artifact generation + HLIL export on both Linux and Windows build agents.
4. Documentation coverage: every exported symbol includes description + dependency notes.

## Scope, Assumptions, Constraints
**In Scope**
- DOS real-mode `GP.EXE` (321,878 bytes) and supporting overlay segments within ISO.
- Creation of tooling, schemas, and automation for Ghidra ↔ Binary Ninja interop.
- Integration hooks for injecting lifted logic into `f1gp-port` while original DOS binary remains reference.

**Out of Scope (for this HLD)**
- Full static recompilation of the entire binary.
- Non-x86 platform support (e.g., Amiga release assets).
- Emulator-based translation layers (DOSBox-X) beyond test harness integration.

**Assumptions**
- Developers have valid licenses for Binary Ninja Commercial + Headless.
- Ghidra 11.x is acceptable baseline; Java 17 runtime available.
- Source control remains Git; large binaries tracked via Git LFS where necessary.

**Constraints**
- Need to preserve legal boundary: only operate on user-supplied ISO; no redistribution of original assets.
- Toolchain must operate offline (no external network dependency) except optional symbol enrichment scripts.
- CI agents are x86_64 Linux; Windows runners optional but recommended.

## Solution Overview
| Component | Role | Notes |
|-----------|------|-------|
| `re/ghidra_project/` | Stores `.gpr` project, load scripts, processor specs | Versioned via Git LFS; includes custom analyzer modules.
| `re/artifacts/symbols.json` | Canonical record of functions, data, comments, interrupts | Exported from Ghidra scripts; includes provenance hash of `GP.EXE`.
| `re/artifacts/segments.yml` | Segment layout + overlay definitions | Consumed by Binary Ninja loader plugin.
| Binary Ninja Plugin (`tools/bnn/f1gp_loader.py`) | Applies segments, imports symbols/types, triggers HLIL pass | Headless capable for CI.
| `re/artifacts/hlil/<subsystem>.c` | Generated HLIL stubs grouped by subsystem | Used by Rust rewrite team for reference + automated diffs.
| `tests/replay/*` | Deterministic telemetry inputs for lifted functions | Cross-checked against Rust reimplementation.

This pipeline supports two primary workflows:
1. **Exploration**: Analysts iterate in Ghidra, run scripts to update artifacts, review diffs.
2. **Lifting & Validation**: Binary Ninja consumes latest artifacts, regenerates HLIL, runs comparison harnesses.

## Architecture
### Toolchain Layers
1. **Acquisition Layer**: `GP.EXE` stored in `f1gp-disasm/`. SHA256 tracked in repo metadata.
2. **Analysis Layer (Ghidra)**: Custom loader settings (x86:LE:16:Real Mode, 20-bit addressing) plus analyzers for relocation tables, string recovery, BIOS INT mapping.
3. **Translation Layer (Binary Ninja)**: Extended loader normalizes far pointers into flat linear addresses (segment << 4 + offset), enabling HLIL to treat data as near pointers.
4. **Artifact Layer**: JSON/YAML + HLIL C-like exports, versioned and diffable.
5. **Integration Layer**: Scripts copy curated HLIL into `f1gp-port/docs/` and feed metadata into Rust enums/struct definitions.

### Data Flow (Happy Path)
1. Analyst imports `GP.EXE` into Ghidra project using template.
2. Ghidra analyzer runs (symbol recovery, stack frame inference, string extraction, INT annotation).
3. Analyst tags functions with subsystem labels (e.g., `Physics::IntegrateLap`) and triggers `ExportSymbolsToJson.java` script.
4. JSON + YAML artifacts committed.
5. Binary Ninja CI job downloads artifacts, runs headless `bndisasm.py` to load binary + metadata, emits HLIL C for targeted symbol sets.
6. HLIL outputs compile-time-checked (clang-format) and stored under version control.
7. `f1gp-port` build/test harness consumes HLIL for parity tests and report generation.

### Repository Additions
```
re/
  ghidra/
    project_template/
    scripts/
  binary_ninja/
    plugins/
    workflows/
  artifacts/
    symbols.json
    segments.yml
    hlil/
      physics.c
      ai.c
      graphics.c
```
`wrk_docs/` (existing) receives status docs, including this HLD and future SOPs.

## Detailed Design
### 6.1 Ghidra Workflow Blueprint
- **Project Template**: Initialize from `re/ghidra/project_template/` to enforce directory naming, analysis options, and data type libraries.
- **Loader Settings**: MZ format, `x86:LE:16:Real Mode`; enable overlay manager with manual segment definitions pulled from ISO directory listing.
- **Analyzers to enable**:
  - PCode Emulation (for stack variable inference).
  - Constant Reference Analyzer (captures I/O ports 0x201, 0x388, etc.).
  - Function Start Search (pattern tuned for Borland inline prologues).
  - x86 Operand Propagator.
- **Custom Scripts** (Java/Python):
  1. `ExportSymbolsToJson.java` – dumps function metadata (name, address, segment, size, comments, subsystem tag, dependencies, INT usage) into `re/artifacts/symbols.json`.
  2. `ExportSegmentsToYaml.java` – enumerates segments, overlay banks, data blocks, REL relocation table; ensures Binary Ninja can reconstruct memory map.
  3. `TagInterruptUsage.py` – scans for `INT xx` instructions, attaches structured comments consumed by docs.
  4. `EmitTypeDecls.py` – writes C headers for shared structs (car setup, telemetry frames).
- **Annotation Guidelines**: Documented in `re/ghidra/CONTRIBUTING.md` covering naming conventions (e.g., `Physics_UpdateSuspension`, `BIOS_Int10_SetMode13h`), comment format, subsystem tags, and review steps (PR review requires before/after screenshots or script outputs).
- **Version Control Strategy**: `.gpr` stored via Git LFS; scripts + exported artifacts stored as text; include hash of input binary to detect divergence.

### 6.2 Binary Ninja Workflow Blueprint
- **Loader Plugin** (`f1gp_loader.py`): Parses `segments.yml`, maps each segment to BN sections, sets default base = 0x10000 to avoid collisions, auto-creates segment registers.
- **Import Script** (`import_symbols.py`): Reads `symbols.json`, creates BN symbols with tags, applies calling conventions, attaches metadata (subsystem, verified status).
- **Lift Profile Config**: Custom settings enabling `analysis.cache`, `mlil` SSA, HLIL struct decompilation, stack variable recovery heuristics tuned for 16-bit.
- **HLIL Export Tool** (`emit_hlil.py`): Takes target subsystem list, emits `hlil/<name>.c` with:
  - File header referencing original addresses + checksum.
  - Inline comments showing I/O operations + INT usage.
  - `#pragma` hints for manual porting (e.g., `#pragma f1gp_stack(near)`), purely informational.
- **Validation Harness**: `bn_verify.py` re-runs with `--strict` flag to ensure no missing symbols; integrated into CI.

### 6.3 Shared Artifact Schema
`symbols.json` example excerpt:
```json
{
  "binary_hash": "sha256:...",
  "generated_at": "2025-11-19T18:42:00Z",
  "functions": [
    {
      "name": "Physics_UpdateCarState",
      "segment": "0x2C",
      "offset": "0x1400",
      "linear": "0x2D400",
      "size_bytes": 342,
      "subsystem": "physics",
      "callers": ["Main_Loop"],
      "int_usage": ["0x1A"],
      "notes": "Reads joystick via BIOS, writes telemetry buffer"
    }
  ]
}
```
`segments.yml` captures ordering, overlay ID, load address, file offsets, and decoder hints (code vs data).

### 6.4 Automation & CI Integration
- **Script Entry Point**: `scripts/re/refresh_artifacts.py`
  1. Calls Ghidra headless `analyzeHeadless` with `ExportSymbolsToJson` and `ExportSegmentsToYaml` post-scripts.
  2. Validates JSON/YAML against schema (using `jsonschema`).
  3. Invokes Binary Ninja headless with `emit_hlil.py` for target subsystems.
  4. Runs formatting (clang-format) + `codespell` on HLIL exports.
  5. Generates summary markdown appended to `wrk_journals` for audit.
- **CI Jobs**:
  - `re-ghidra` (Linux): ensures scripts still run with OSS Ghidra (no GUI).
  - `re-binja` (Linux, proprietary license key stored in CI secrets): caches BN install; fails build if HLIL diff not committed.
  - `parity-tests` (Rust workspace): compiles harness invoking lifted HLIL via FFI stubs, comparing outputs to DOS telemetry captured via DOSBox.

### 6.5 Integration with `f1gp-port`
- Create `f1gp-port/docs/re/` to mirror HLIL outputs for quick lookup.
- Generate Rust `enum SubsystemFunctionId` from `symbols.json` using build script; ensures telemetry harness references canonical IDs.
- Provide `ffi/shims/` that include HLIL C as part of regression tests (compiled only for verification targets, not shipping builds).

### 6.6 Observability & Traceability
- Tag each exported function with `source_recording_id` referencing traces captured from DOSBox runs; stored under `f1gp-data/dos_traces/`.
- Logging spec: `scripts/re/refresh_artifacts.py` emits `artifacts/logs/<timestamp>.json` with step durations, tool versions, host info.
- Dashboard idea: simple `mkdocs` site auto-generates HTML pages summarizing coverage, symbol counts, outstanding TODOs.

## Environment & Tooling Requirements
| Tool | Version | Notes |
|------|---------|-------|
| Ghidra | 11.0 (or latest stable) | Requires OpenJDK 17, 8+ GB RAM recommended.
| Binary Ninja | 4.0+ (Commercial + Headless) | Need license server or floating license file for CI.
| Python | 3.12 | For scripts, leverage venv already created in `f1gp-disasm/` if desired.
| clang-format | 17+ | For HLIL C outputs.
| jsonschema | Python dep for artifact validation.
| DOSBox-X | 2025.02+ | For telemetry capture/regression.

Hardware: Developer workstation with ≥16 GB RAM, CI runners with at least 4 cores for headless analysis.

## Risk Assessment & Mitigations
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Binary Ninja loader drift vs Ghidra segments | Wrong HLIL, wasted effort | Medium | Schema versioning + unit tests using sample `segments.yml` snapshots. |
| Licensing issues for headless BN in CI | CI blocked | Medium | Store encrypted license in GitHub Actions secrets; add fallback manual approval job. |
| Real-mode overlay logic misunderstood | Incorrect port behavior | High | Document overlays in `segments.yml`; add analyzer script verifying overlay call pairs. |
| HLIL readability limited for heavily optimized loops | Slower reimplementation | Medium | Provide manual rewriting guidelines + annotate original assembly in Ghidra comments linked to HLIL.
| Toolchain churn (Ghidra/Binja updates) | Pipeline breakage | Medium | Pin tool versions; run compatibility job monthly before upgrades.

## Milestones & Deliverables
1. **M1 – Toolchain Bootstrap (Week 1)**
   - Check in Ghidra template, Binary Ninja loader skeleton, sample artifact outputs for `Main_Loop`.
2. **M2 – Symbol Coverage 50% (Week 3)**
   - Run annotation sprint; produce first comprehensive `symbols.json` + review doc.
3. **M3 – HLIL for Physics & Input (Week 5)**
   - Binary Ninja exports validated; parity harness starts comparing physics routines.
4. **M4 – Graphics & Audio Lifts (Week 7)**
   - HLIL for rendering + audio mixing; produce integration notes for `f1gp-port` render path.
5. **M5 – Automation in CI (Week 8)**
   - `refresh_artifacts` job green on Linux + Windows; artifacts auto-published as build artifacts.
6. **M6 – Handoff Package (Week 10)**
   - Documentation bundle (this HLD + SOPs + artifacts) delivered to gameplay team for native implementation.

## Open Questions & Next Actions
1. **Binary relocation coverage** – Do we need to analyze `F1GPNOCD.EXE` or just `GP.EXE`? Proposal: defer until `GP.EXE` coverage >80%.
2. **Automated diffing vs DOS traces** – Determine best format (binary vs JSON) for telemetry comparisons; candidate: Cap'n Proto schema for deterministic results.
3. **CI licensing** – Confirm legal path for storing Binary Ninja headless license in repo-specific secrets.
4. **Team onboarding** – Produce quickstart video or step-by-step doc (follow-up deliverable `SOP - Ghidra Workflow`).

**Next Actions**
- [ ] Create `re/` directory skeleton with placeholder README + CONTRIBUTING.
- [ ] Check in initial Ghidra project template and exporter scripts.
- [ ] Implement Binary Ninja loader stub, ensure it ingests `segments.yml` produced manually.
- [ ] Draft SOP(s) referenced above and schedule review.
