# High-Level Design: Ghidra Annotation & Coverage Campaign

**Document Type:** HLD  
**Version:** 1.0  
**Date:** 2025.11.20  
**Author:** Codex  
**Project:** F1GP Disassembly & Native Port Initiative  
**Status:** Draft

---

## 1. Executive Summary
With headless Ghidra operational, we will launch a structured annotation campaign that continuously enriches `GP.EXE` with subsystem labels, comments, and telemetry trace IDs. The goal is to move from the current "entry-only" baseline to ≥90 % function coverage, producing high-fidelity artifacts (symbols, segments, HLIL, coverage reports) that feed Binary Ninja lifting and the parity harness. This design specifies the tooling, workflow, data contracts, and governance required for analysts to collaborate efficiently while keeping automation deterministic.

## 2. Objectives & Success Criteria
- **Coverage Growth:** Increase named function coverage to ≥90 % and maintain daily snapshots in `re/artifacts/coverage_summary.md`.
- **Subsystem Traceability:** Every named function tagged with `@subsystem:<name>` (physics, input, graphics, audio, AI, platform) and optional `@trace:<run_id>` linking to telemetry metadata.
- **Automation-Ready:** `refresh_artifacts.py` becomes the single entry point to regenerate symbols/segments, telemetry indices, coverage summaries, and publish HLIL outputs.
- **Collaboration Cadence:** Analysts can work concurrently by cloning the Ghidra project, using branch-based contributions, and relying on deterministic headless exports for code review.
- **Parity Feedback Loop:** Updated symbols feed Binary Ninja HLIL exports and parity harness diffs, enabling rapid detection of regressions in the Rust port.

Success metrics:
1. Coverage summary shows weekly +10 % improvements until plateau.
2. At least two telemetry traces (`sample_boot`, `physics_lap`) referenced by `@trace:` tags.
3. HLIL exports present for physics/input subsystems, mirrored under `f1gp-port/docs/re/`.
4. CI (`re-ghidra`, `re-binja`, `re-parity`) runs clean on main.

## 3. Scope
- **In Scope:** Ghidra project configuration, naming conventions, annotation SOP, headless export scripts, telemetry trace linkage, coverage dashboards, Binary Ninja ingestion alignment.
- **Out of Scope:** Manual decompilation rewrite, Rust gameplay feature work, DOSBox-X feature enhancements (beyond telemetry captures), non-DOS versions of F1GP.

## 4. Architecture Overview
| Layer | Component | Description |
|-------|-----------|-------------|
| Acquisition | `GP.EXE` | Extracted MS-DOS binary stored in `f1gp-disasm/`. Hash tracked in `re/SOURCE_MANIFEST.md`. |
| Ghidra | Project `F1GP_Auto` | Real-mode x86 project with custom scripts (TagInterruptUsage, ExportSymbolsToJson, ExportSegmentsToYaml, EmitTypeDecls). |
| Telemetry | `capture_telemetry.py` + macros | DOSBox-X macro runner generating `f1gp-data/dos_traces/<run_id>/`. Index built via `link_traces.py`. |
| Reporting | `coverage_report.py` | Emits `coverage_summary.md` summarizing progress per subsystem + INT use. |
| Publishing | `publish_hlil.py` | Copies HLIL exports to `f1gp-port/docs/re/`. |
| CI | `re-ghidra`, `re-binja`, `re-parity` | Automate artifact regeneration, HLIL export, and parity sanity checks. |

## 5. Detailed Design
### 5.1 Ghidra Configuration
- **Project:** `re/ghidra/project_template/F1GP_Auto` (Git LFS). Analysts clone locally; instructions in `re/ghidra/CONTRIBUTING.md`.
- **Language:** `x86:LE:16:Real Mode / default`.
- **Analyzers enabled:** ASCII Strings, Apply Data Archives, Function Start Search, Stack, x86 Constant Reference, Segmented x86 Calling Conventions, etc. (see contributor guide).
- **Scripts:**
  - `TagInterruptUsage.py` – marks INT instructions with `@interrupt` tag.
  - `ExportSymbolsToJson.java` – exports metadata (subsystem, trace IDs, callers) while ignoring uninitialized memory blocks for SHA.
  - `ExportSegmentsToYaml.java` – dumps segment layout.
  - `EmitTypeDecls.py` – optional (auto-skips if APIs missing).

### 5.2 Annotation Workflow
1. Analyst opens project in GUI, loads `GP.EXE`.
2. For each function:
   - Rename using `Subsystem_Action` convention (`Physics_IntegrateLap`).
   - Add comment heading summarizing behavior + regs.
   - Include `@subsystem:<name>` line.
   - If telemetry trace exists, add `@trace:<run_id>`.
3. Save project; run headless `refresh_artifacts.py` to update artifacts.
4. Review `git status` for changes to `re/artifacts/` and coverage summary; create PR with before/after coverage diff.

### 5.3 Telemetry Linkage
- Capture scripts live under `re/scripts/telemetry_macros/`; macro naming convention `YYYYMMDD_<scenario>.txt`.
- `capture_telemetry.py` invoked via `refresh_artifacts.py --capture-run <id> --capture-macro <macro>` prior to exports.
- Telemetry metadata stored in `f1gp-data/dos_traces/<run_id>/metadata.json`; `link_traces.py` aggregates into `re/artifacts/telemetry/index.json`.
- `source_recording_id` field in `symbols.json` references `run_id`; parity harness uses same ID.

### 5.4 Automation Entrypoint
`python3 re/scripts/refresh_artifacts.py [options]`
- Steps (when no skip flags):
  1. Optional telemetry capture.
  2. Trace index rebuild.
  3. Ghidra analysis + symbol/segment export.
  4. Binary Ninja HLIL export (future stage).
  5. Artifact validation vs. schemas.
  6. Coverage summary generation.
  7. HLIL publish into `f1gp-port/docs/re/`.
  8. Log written to `re/artifacts/logs/`.

### 5.5 Binary Ninja Alignment
- Loader (`f1gp_loader.py`) maps segments from YAML; importer ingests symbols.
- HLIL exporter generates `re/artifacts/hlil/<subsystem>.c`; `publish_hlil.py` mirrors to gameplay docs for easy review.
- CI job `re-binja` will run once subsystem annotations exist.

### 5.6 Parity Harness Integration
- Sample metadata ensures CI stays green (until real traces captured).
- Once new telemetry captured, update `f1gp-port/tests/data/*` and parity harness to compare actual trace outputs.

## 6. Tooling & Environment
| Tool | Version | Notes |
|------|---------|-------|
| Ghidra | 11.4.2 | Installed at `/home/md/ghidra_11.4.2_PUBLIC`; headless path exported via `GHIDRA_HEADLESS`. |
| Java | 17/21 | 21 currently works; maintain compatibility notes in SOP. |
| Binary Ninja | 4.x | Pending license upload for headless CI. |
| DOSBox-X | 2025.02+ | Required for telemetry capture; install next. |
| Python | 3.12 | For automation scripts (coverage, telemetry). |

## 7. Risks & Mitigations
| Risk | Mitigation |
|------|------------|
| Annotation drift between analysts | Enforce SOP + PR checklist; coverage summary highlights anomalies. |
| Ghidra API changes (as seen with 11.4) | Scripts now defensive (skip missing APIs, ignore uninitialized memory); document compatibility in SOP. |
| Telemetry legal constraints | Only commit sanitized traces; rely on metadata + hashes. |
| CI secrets for Binary Ninja | Store license + download URL in GitHub Actions secrets before enabling job. |

## 8. Milestones
1. **M1 (Week 0)** – Headless Ghidra run succeeds (DONE 2025-11-20).
2. **M2 (Week 1)** – Physics subsystem annotated (≥50 functions) + telemetry trace captured.
3. **M3 (Week 2)** – Binary Ninja HLIL exports for physics/input; docs published.
4. **M4 (Week 3)** – Coverage ≥70 %, parity harness uses real trace.
5. **M5 (Week 4+)** – Coverage ≥90 %, CI fully enabled.

## 9. Next Actions
1. Install DOSBox-X so telemetry capture step can produce real traces.
2. Kick off Physics sprint: annotate initialization + integration routines, capture `physics_boot` trace, rerun refresh pipeline.
3. Enable Binary Ninja (`--skip-binja` removal) once annotations exist to verify HLIL export path.
4. Update parity harness to consume actual telemetry once available.
