# High-Level Design: Real F1GP .TRK File Support

**Date:** 2025-11-16
**Author:** F1GP Port Team
**Status:** Design → Implementation
**Complexity:** High (Multi-week effort)

---

## Executive Summary

This HLD describes the design and implementation of full support for parsing and rendering authentic F1GP track files (.TRK/.DAT format) from the original 1991 game. Currently, the project uses procedurally generated tracks; this work will enable loading all 16 original circuits with accurate geometry, elevation, racing lines, and track objects.

**Key Goals:**
1. Extract original F1GP binary track files from ISO
2. Implement complete binary parser for .TRK/.DAT format
3. Convert binary data to our Track data structures
4. Generate accurate 3D track meshes with elevation and banking
5. Visualize racing lines and place track objects
6. Enable all 16 classic circuits in the 3D demo

---

## Background & Context

### Current State

**What Exists:**
- ✅ Complete Track data structures (Track, TrackSection, RacingLine, etc.)
- ✅ Binary parser framework (TrackParser with helpers)
- ✅ Graphical element parser (partial - polygons, bitmaps, lines)
- ✅ 3D track mesh generator (TrackMesh::from_track())
- ✅ 3D demo with 5 procedural tracks (Monaco, Spa, Monza, Silverstone, Test)
- ✅ ISO extraction tool (can extract files from original ISO)
- ⚠️ JSON track files (empty placeholders)
- ⚠️ Track format spec (20% complete)

**What's Missing:**
- ❌ Original binary .TRK files (F1CT01.DAT through F1CT16.DAT)
- ❌ Complete track section format documentation
- ❌ Track section binary parser implementation
- ❌ Racing line parser implementation
- ❌ Coordinate system understanding
- ❌ Elevation/banking data extraction
- ❌ Track object placement system

### Why This Matters

**Value Proposition:**
- **Authenticity:** Use original F1GP circuit layouts from 1991 season
- **Nostalgia:** Exact track geometry from the classic game
- **Completeness:** All 16 circuits (Phoenix, Monaco, Spa, Monza, Suzuka, etc.)
- **Accuracy:** Real elevation changes, banking, racing lines
- **Education:** Deep understanding of retro game file formats

**Technical Benefits:**
- Validates our data structures against real-world data
- Tests parser robustness with actual binary files
- Enables comprehensive testing across diverse track types
- Provides foundation for future enhancements (track editing, custom circuits)

---

## Design Overview

### System Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     F1GP ISO Image                           │
│  (Original game CD-ROM, ~28MB, 254 files)                   │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│              ISO Extraction Tool                             │
│  tools/extract_iso (cdfs crate, reads ISO 9660)             │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│         Binary Track Files (assets/original/)                │
│  F1CT01.DAT through F1CT16.DAT (13-20 KB each)              │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│           Track Parser (src/data/parser.rs)                  │
│  • Read binary structure                                     │
│  • Parse header and offsets                                  │
│  • Parse track sections (geometry, elevation, banking)       │
│  • Parse racing line points                                  │
│  • Parse object shapes and placements                        │
│  • Parse camera positions                                    │
│  • Verify checksum                                           │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│         Track Data Structure (src/data/track.rs)             │
│  Track { sections, racing_line, objects, cameras }          │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│        3D Track Mesh Generator (src/render3d/)               │
│  • Convert 2D track sections to 3D vertices                  │
│  • Apply elevation and banking                               │
│  • Generate normals and UVs                                  │
│  • Create mesh buffers                                       │
└───────────────────────┬─────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────┐
│              3D Demo (tools/3d_demo)                         │
│  • Render authentic F1GP circuits                            │
│  • Display racing line overlay                               │
│  • Place track objects                                       │
│  • All 16 classic circuits available                         │
└─────────────────────────────────────────────────────────────┘
```

---

## Binary Track File Format

### File Structure (Based on ArgDocs Research)

```
Offset      Size    Description
──────────────────────────────────────────────────────────────
0x0000      ???     Horizon Image (unknown format)
0x100E      2       Number of object shapes
0x1010      4*n     Object shape offsets (4 bytes each)
0x????      ???     Object shape data (variable length)
0x????      ???     Track data header (TBD)
0x????      ???     Track sections (TBD - CRITICAL)
0x????      ???     Racing line data (TBD - CRITICAL)
0x????      ???     AI behavior parameters
0x????      ???     Pit lane sections
0x????      ???     Camera definitions
0x????      ???     Additional data
filesize-4  4       Checksum (32-bit, algorithm TBD)
```

### Track Section Format (TO BE DISCOVERED)

**Goal:** Understand how F1GP encodes track geometry

**Hypotheses:**
- Segments stored as 2D coordinates (X, Y) with heading
- Elevation stored separately (Z coordinate or delta)
- Banking angle in degrees or radians
- Width in game units (to be calibrated to meters)
- Surface type flags (track, grass, gravel, kerb)
- Length of each segment

**Discovery Method:**
1. Hex dump analysis of multiple tracks
2. Pattern recognition (repeating structures)
3. Value range analysis (identify coordinates vs. flags)
4. Cross-reference with ArgDocs community knowledge
5. Trial and error with visualization

### Racing Line Format (TO BE DISCOVERED)

**Goal:** Extract AI racing line points

**Expected Structure:**
- Array of (X, Y, Z) points
- Speed/throttle values at each point
- Braking zone markers
- Gear recommendations

### Coordinate System (TO BE DETERMINED)

**Questions to Answer:**
1. What is the origin? (Center of track, start line, etc.)
2. What are the units? (Meters, game units, need conversion?)
3. Which axis is forward? (X, Y, or heading-based?)
4. How is elevation encoded? (Absolute or relative?)
5. Right-handed or left-handed coordinate system?

---

## Implementation Phases

### Phase 1: Acquisition & Setup (Est: 2-3 hours)

**Goal:** Obtain original F1GP binary track files

**Tasks:**

1. **Locate F1GP ISO** (30 min)
   - Search for original F1GP ISO image
   - Verify it's the correct version (1991 or 1992 edition)
   - Check file integrity (size should be ~28MB)
   - Options:
     - User's archive
     - Internet Archive (abandonware)
     - Original CD if available

2. **Extract ISO** (30 min)
   ```bash
   cd tools/extract_iso
   cargo run -- --input ~/f1gp.iso --output ../../assets/original/
   ```
   - Run extraction tool
   - Verify all 16 F1CT*.DAT files extracted
   - Check file sizes (13-20 KB range)
   - Verify checksums if available

3. **Create Binary Analysis Tools** (1 hour)
   - Hex dump viewer for .DAT files
   - Byte frequency analyzer
   - Pattern finder (repeating sequences)
   - File comparison tool (diff multiple tracks)
   - Create tools/analyze_track/ directory

4. **Setup Test Infrastructure** (30 min)
   - Copy F1CT01.DAT to test fixtures
   - Create parser unit tests skeleton
   - Setup test track validation
   - Document expected outputs

**Deliverables:**
- ✅ assets/original/F1CT01.DAT through F1CT16.DAT
- ✅ tools/analyze_track/ with analysis utilities
- ✅ Initial test fixtures
- ✅ Journal entry documenting findings

---

### Phase 2: Format Research (Est: 6-8 hours)

**Goal:** Fully document the track section and racing line formats

**Tasks:**

1. **Object Shape Analysis** (1 hour)
   - Validate existing object parser against real data
   - Parse object shapes from F1CT01.DAT
   - Document any deviations from ArgDocs spec
   - Test polygon/bitmap/line parsing

2. **Find Track Section Data** (2 hours)
   - Locate track sections in binary file
   - Identify section boundaries
   - Determine section structure size
   - Count sections per track
   - Hypothesis: Sections are after object shapes
   - Method: Look for repeating patterns of similar size

3. **Decode Track Geometry** (3 hours)
   - Identify X, Y coordinate bytes
   - Determine coordinate encoding (16-bit? 32-bit? Fixed point?)
   - Find width/banking/elevation bytes
   - Discover length encoding
   - Identify surface type flags
   - Validate by visualizing track outline

4. **Find Racing Line** (1 hour)
   - Locate racing line point array
   - Determine point structure
   - Extract speed/braking data
   - Count points per track

5. **Camera Data** (30 min)
   - Find camera definitions
   - Parse positions and targets
   - Determine FOV encoding

6. **Document Coordinate System** (30 min)
   - Determine origin point
   - Identify axis directions
   - Calculate unit conversion to meters
   - Document right/left handedness

**Deliverables:**
- ✅ Updated docs/track_format_spec.md with complete format
- ✅ Coordinate system documentation
- ✅ Test data with known values
- ✅ Visualization of track outlines (prove correctness)
- ✅ Journal with research findings

**Research Tools:**
- Hex editor (hexdump, xxd, ghex)
- Binary diff tool (vbindiff, dhex)
- Python analysis scripts
- Pattern recognition tools
- Visualization scripts (matplotlib)

---

### Phase 3: Parser Implementation (Est: 8-12 hours)

**Goal:** Implement complete binary parser for all track data

**Sub-Phase 3.1: Track Section Parser** (4 hours)

```rust
// src/data/parser.rs

/// Parse track sections from binary data
pub fn parse_track_sections(
    parser: &mut TrackParser,
    section_count: usize,
    section_offset: u64,
) -> Result<Vec<TrackSection>> {
    parser.seek(section_offset);

    let mut sections = Vec::with_capacity(section_count);
    let mut current_pos = Vec3::ZERO;

    for _ in 0..section_count {
        // Read section data based on discovered format
        let x = parser.read_i16()? as f32;
        let y = parser.read_i16()? as f32;
        let elevation = parser.read_i16()? as f32;
        let width = parser.read_u8()? as f32;
        let banking = parser.read_i8()? as f32;
        let surface_type_byte = parser.read_u8()?;
        let length = parser.read_u16()? as f32;

        // Convert game units to meters
        let position = convert_coordinates(x, y, elevation);
        let width_meters = width * UNIT_TO_METERS;
        let banking_radians = banking * BANKING_SCALE;
        let length_meters = length * UNIT_TO_METERS;

        sections.push(TrackSection {
            position,
            width: width_meters,
            banking: banking_radians,
            elevation: position.z,
            surface: decode_surface_type(surface_type_byte),
            length: length_meters,
        });

        current_pos = position;
    }

    Ok(sections)
}

/// Convert F1GP coordinates to 3D world space
fn convert_coordinates(x: f32, y: f32, z: f32) -> Vec3 {
    // Apply coordinate system transformation
    Vec3::new(
        x * UNIT_TO_METERS,
        z * UNIT_TO_METERS,  // Elevation
        y * UNIT_TO_METERS,  // Forward direction
    )
}

/// Decode surface type from byte flag
fn decode_surface_type(byte: u8) -> SurfaceType {
    match byte {
        0x00 => SurfaceType::Track,
        0x01 => SurfaceType::Grass,
        0x02 => SurfaceType::Gravel,
        0x03 => SurfaceType::Kerb,
        0x04 => SurfaceType::PitLane,
        0x05 => SurfaceType::Wall,
        _ => SurfaceType::Track,  // Default
    }
}
```

**Sub-Phase 3.2: Racing Line Parser** (2 hours)

```rust
/// Parse racing line points
pub fn parse_racing_line(
    parser: &mut TrackParser,
    point_count: usize,
    line_offset: u64,
) -> Result<RacingLine> {
    parser.seek(line_offset);

    let mut points = Vec::with_capacity(point_count);

    for _ in 0..point_count {
        let x = parser.read_i16()? as f32;
        let y = parser.read_i16()? as f32;
        let z = parser.read_i16()? as f32;
        let speed = parser.read_u8()? as f32;
        let flags = parser.read_u8()?;

        let position = convert_coordinates(x, y, z);
        let speed_ms = speed * SPEED_SCALE;
        let is_braking = (flags & 0x01) != 0;

        points.push(RacingLinePoint {
            position,
            speed: speed_ms,
            is_braking_zone: is_braking,
        });
    }

    Ok(RacingLine { points })
}
```

**Sub-Phase 3.3: Complete Track Parser** (3 hours)

```rust
/// Parse complete track file
pub fn parse_track(data: Vec<u8>, name: String) -> Result<Track> {
    let mut parser = TrackParser::new(data);

    // Read checksum
    parser.seek((parser.file_size - 4) as u64);
    let checksum = parser.read_u32()?;

    // Parse object shapes (offset 0x100E)
    parser.seek(0x100E);
    let object_count = parser.read_u16()? as usize;
    let object_shapes = parse_object_shapes_full(&mut parser, object_count)?;

    // Find track sections (heuristic or fixed offset)
    let section_offset = find_track_section_offset(&parser)?;
    let section_count = estimate_section_count(&parser, section_offset)?;
    let sections = parse_track_sections(&mut parser, section_count, section_offset)?;

    // Calculate track length
    let length = sections.iter().map(|s| s.length).sum();

    // Find and parse racing line
    let line_offset = find_racing_line_offset(&parser)?;
    let point_count = estimate_racing_line_points(&parser, line_offset)?;
    let racing_line = parse_racing_line(&mut parser, point_count, line_offset)?;

    // Parse cameras (if we find them)
    let cameras = parse_cameras(&mut parser).unwrap_or_default();

    // AI behavior (use defaults for now, can enhance later)
    let ai_behavior = AIBehavior::default();

    // Pit lane (parse if format discovered)
    let pit_lane = Vec::new();

    Ok(Track {
        name,
        length,
        object_shapes,
        sections,
        racing_line,
        ai_behavior,
        pit_lane,
        cameras,
        checksum,
    })
}
```

**Sub-Phase 3.4: Testing & Validation** (3 hours)

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn test_parse_monaco_track() {
        let data = std::fs::read("assets/original/F1CT04.DAT").unwrap();
        let track = parse_track(data, "Monaco".to_string()).unwrap();

        assert_eq!(track.name, "Monaco");
        assert!(track.sections.len() > 0);
        assert!(track.length > 1000.0);  // At least 1km
        assert!(track.length < 10000.0);  // Less than 10km
        assert!(track.racing_line.points.len() > 0);
    }

    #[test]
    fn test_all_16_tracks() {
        for i in 1..=16 {
            let path = format!("assets/original/F1CT{:02}.DAT", i);
            let data = std::fs::read(&path).unwrap();
            let track = parse_track(data, format!("Track {}", i)).unwrap();

            track.validate().unwrap();
            assert!(track.sections.len() > 10);
            assert!(track.length > 500.0);
        }
    }
}
```

**Deliverables:**
- ✅ Complete track section parser
- ✅ Racing line parser
- ✅ Camera parser
- ✅ Full integration in parse_track()
- ✅ Comprehensive unit tests
- ✅ All 16 tracks loading successfully
- ✅ Validation passing for all tracks

---

### Phase 4: 3D Integration (Est: 6-8 hours)

**Goal:** Render authentic F1GP tracks in 3D with elevation and banking

**Sub-Phase 4.1: Enhanced Mesh Generation** (3 hours)

```rust
// src/render3d/track_mesh.rs

impl TrackMesh {
    /// Generate 3D mesh from parsed track data
    pub fn from_track(track: &Track) -> Result<Self> {
        let mut vertices = Vec::new();
        let mut indices = Vec::new();

        // Generate track surface with elevation and banking
        for (i, section) in track.sections.iter().enumerate() {
            let next_section = track.sections.get(i + 1)
                .unwrap_or(&track.sections[0]);

            // Calculate direction vector
            let direction = (next_section.position - section.position).normalize();
            let right = Vec3::new(-direction.z, 0.0, direction.x);

            // Apply banking rotation
            let bank_quat = Quat::from_axis_angle(direction, section.banking);
            let banked_right = bank_quat * right;

            // Generate left and right edges with elevation
            let half_width = section.width / 2.0;
            let left_pos = section.position + banked_right * half_width;
            let right_pos = section.position - banked_right * half_width;

            // Add vertices with proper normals
            let normal = Vec3::Y;  // Will be recalculated
            let color = get_surface_color(&section.surface);

            vertices.push(TrackVertex {
                position: left_pos,
                normal,
                color,
                uv: [0.0, i as f32 / track.sections.len() as f32],
            });

            vertices.push(TrackVertex {
                position: right_pos,
                normal,
                color,
                uv: [1.0, i as f32 / track.sections.len() as f32],
            });

            // Create quad indices
            if i > 0 {
                let base = (i * 2) as u32;
                indices.extend_from_slice(&[
                    base - 2, base - 1, base,
                    base - 1, base + 1, base,
                ]);
            }
        }

        // Close the loop
        close_track_loop(&mut indices);

        // Recalculate normals for smooth lighting
        calculate_smooth_normals(&mut vertices, &indices);

        Ok(Self { vertices, indices })
    }
}

fn get_surface_color(surface: &SurfaceType) -> [f32; 3] {
    match surface {
        SurfaceType::Track => [0.3, 0.3, 0.35],     // Dark gray asphalt
        SurfaceType::Grass => [0.2, 0.6, 0.2],      // Green
        SurfaceType::Gravel => [0.8, 0.7, 0.5],     // Tan
        SurfaceType::Kerb => [1.0, 0.0, 0.0],       // Red
        SurfaceType::PitLane => [0.4, 0.4, 0.4],    // Light gray
        SurfaceType::Wall => [0.5, 0.5, 0.5],       // Gray
    }
}
```

**Sub-Phase 4.2: Racing Line Visualization** (2 hours)

```rust
// src/render3d/racing_line_renderer.rs

pub struct RacingLineRenderer {
    vertices: Vec<LineVertex>,
    pipeline: wgpu::RenderPipeline,
    vertex_buffer: wgpu::Buffer,
}

impl RacingLineRenderer {
    pub fn from_racing_line(
        device: &wgpu::Device,
        racing_line: &RacingLine,
    ) -> Self {
        let mut vertices = Vec::new();

        for (i, point) in racing_line.points.iter().enumerate() {
            let color = if point.is_braking_zone {
                [1.0, 0.0, 0.0, 0.8]  // Red for braking
            } else {
                [0.0, 1.0, 0.0, 0.8]  // Green for racing line
            };

            // Offset line above track to avoid z-fighting
            let position = point.position + Vec3::Y * 0.1;

            vertices.push(LineVertex { position, color });
        }

        // Create line strip buffer
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Racing Line Vertex Buffer"),
            contents: bytemuck::cast_slice(&vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });

        Self {
            vertices,
            pipeline: create_line_pipeline(device),
            vertex_buffer,
        }
    }

    pub fn render<'a>(&'a self, render_pass: &mut wgpu::RenderPass<'a>) {
        render_pass.set_pipeline(&self.pipeline);
        render_pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
        render_pass.draw(0..self.vertices.len() as u32, 0..1);
    }
}
```

**Sub-Phase 4.3: Track Selection System** (2 hours)

```rust
// tools/3d_demo/src/main.rs

const REAL_TRACKS: &[(&str, &str)] = &[
    ("F1CT01.DAT", "Phoenix"),
    ("F1CT02.DAT", "Interlagos"),
    ("F1CT03.DAT", "Imola"),
    ("F1CT04.DAT", "Monaco"),
    ("F1CT05.DAT", "Montreal"),
    ("F1CT06.DAT", "Mexico"),
    ("F1CT07.DAT", "Magny-Cours"),
    ("F1CT08.DAT", "Silverstone"),
    ("F1CT09.DAT", "Hockenheim"),
    ("F1CT10.DAT", "Hungaroring"),
    ("F1CT11.DAT", "Spa-Francorchamps"),
    ("F1CT12.DAT", "Monza"),
    ("F1CT13.DAT", "Estoril"),
    ("F1CT14.DAT", "Barcelona"),
    ("F1CT15.DAT", "Suzuka"),
    ("F1CT16.DAT", "Adelaide"),
];

impl App {
    fn load_real_track(&mut self, track_index: usize) -> Result<()> {
        let (filename, name) = REAL_TRACKS[track_index];
        let path = format!("assets/original/{}", filename);

        let track = load_track(&path, Some(name.to_string()))?;

        // Generate 3D mesh
        let track_mesh = TrackMesh::from_track(&track)?;

        // Generate racing line mesh
        let racing_line_mesh = RacingLineRenderer::from_racing_line(
            &self.device,
            &track.racing_line,
        );

        // Update renderer
        self.renderer.load_track(&self.device, &track_mesh)?;
        self.racing_line = Some(racing_line_mesh);

        // Reset game state
        self.game.reset_for_track(&track);

        println!("Loaded: {} ({:.0}m, {} sections)",
            track.name, track.length, track.sections.len());

        Ok(())
    }

    fn handle_track_selection(&mut self, key_code: KeyCode) {
        match key_code {
            KeyCode::F1 => self.load_real_track(0).ok(),   // Phoenix
            KeyCode::F2 => self.load_real_track(3).ok(),   // Monaco
            KeyCode::F3 => self.load_real_track(10).ok(),  // Spa
            KeyCode::F4 => self.load_real_track(11).ok(),  // Monza
            KeyCode::F5 => self.load_real_track(7).ok(),   // Silverstone
            KeyCode::F6 => self.load_real_track(14).ok(),  // Suzuka
            // ... etc for all 16 tracks
            _ => None,
        };
    }
}
```

**Sub-Phase 4.4: Testing & Polish** (1 hour)

- Test all 16 tracks load and render
- Verify elevation changes visible (especially Spa)
- Verify banking on fast corners
- Check racing line accuracy
- Validate track lengths against known values
- Performance testing (all tracks should maintain 60 FPS)

**Deliverables:**
- ✅ Enhanced TrackMesh with elevation and banking
- ✅ Racing line renderer
- ✅ Track selection UI in demo
- ✅ All 16 tracks rendering correctly
- ✅ Visual validation screenshots
- ✅ Performance benchmarks

---

### Phase 5: Validation & Polish (Est: 4-6 hours)

**Goal:** Ensure quality and correctness of all track data

**Tasks:**

1. **Visual Validation** (2 hours)
   - Compare rendered tracks to original F1GP screenshots
   - Verify recognizable track features:
     - Monaco: Tunnel, swimming pool, Rascasse
     - Spa: Eau Rouge elevation, La Source hairpin
     - Monza: Long straights, chicanes
     - Suzuka: Figure-8 layout, crossover bridge
   - Screenshot gallery for documentation

2. **Data Validation** (1 hour)
   - Check track lengths against real-world values
   - Verify section counts seem reasonable
   - Validate racing line stays on track
   - Check no degenerate geometry (zero-width, etc.)
   - Automated validation tests

3. **Performance Optimization** (1 hour)
   - Profile mesh generation
   - Optimize vertex count if needed
   - Check GPU memory usage
   - Ensure 60 FPS on all tracks

4. **Documentation** (2 hours)
   - Complete track format specification
   - Document coordinate system
   - Update README with real track support
   - Create developer guide for track parsing
   - Add screenshots to docs
   - Write comprehensive journal entry

**Deliverables:**
- ✅ Complete docs/track_format_spec.md
- ✅ Visual validation screenshots
- ✅ Performance benchmarks
- ✅ Updated README
- ✅ Developer guide
- ✅ Final journal entry

---

## Technical Challenges & Solutions

### Challenge 1: Unknown Binary Format

**Problem:** Track section format not fully documented

**Solutions:**
1. **Hex Analysis:** Pattern recognition in binary data
2. **Community Research:** ArgDocs, F1GP forums, GitHub projects
3. **Trial & Error:** Test hypotheses by visualizing results
4. **Incremental:** Start with simple tracks, add complexity
5. **Validation:** Cross-check with known values (track length, turn count)

**Mitigation:**
- Budget extra time for research (Phase 2)
- Create good analysis tools early
- Document findings incrementally
- Don't hesitate to ask community for help

### Challenge 2: Coordinate System Confusion

**Problem:** Unknown axis orientation and units

**Solution:**
1. Parse simple test track (circular?)
2. Visualize in 2D first (top-down view)
3. Compare to known track layout
4. Adjust coordinate transformation until it matches
5. Validate with multiple tracks

**Mitigation:**
- Start with 2D visualization (simpler)
- Use well-known track (Monaco) as reference
- Test coordinate systems systematically
- Document assumptions clearly

### Challenge 3: Elevation and Banking Accuracy

**Problem:** Subtle elevation/banking might be hard to detect visually

**Solution:**
1. Use Spa (largest elevation changes) as test case
2. Exaggerate elevation for initial testing
3. Compare to known altitude data (Eau Rouge: ~40m climb)
4. Calibrate scale factor to match
5. Visual confirmation with side-view camera

**Mitigation:**
- Implement camera controls for inspection
- Use wireframe mode to see geometry
- Add debug visualization (normals, banking angle)
- Reference real-world track profiles

### Challenge 4: Performance with Complex Tracks

**Problem:** Detailed tracks might have many vertices

**Solution:**
1. Profile early and often
2. Use level-of-detail (LOD) if needed
3. Cull invisible sections
4. Optimize vertex format (minimize padding)
5. Batch rendering calls

**Mitigation:**
- Target is only 60 FPS (not thousands)
- Tracks are static (precompute everything)
- Modern GPUs can handle this easily
- Optimize only if profiling shows issues

---

## Success Criteria

### Phase 1 Success
- ✅ All 16 F1CT*.DAT files extracted
- ✅ Analysis tools created
- ✅ Test fixtures prepared
- ✅ Can read files in Rust

### Phase 2 Success
- ✅ Track section format documented
- ✅ Racing line format documented
- ✅ Coordinate system understood
- ✅ Test track visualized correctly (2D)

### Phase 3 Success
- ✅ Parser compiles without errors
- ✅ All 16 tracks load without panics
- ✅ Track validation passes
- ✅ Racing line points extracted
- ✅ Unit tests pass (>80% coverage)

### Phase 4 Success
- ✅ All 16 tracks render in 3D
- ✅ Elevation visible (Spa test)
- ✅ Banking visible (Monza Parabolica)
- ✅ Racing line overlay works
- ✅ Track selection UI functional
- ✅ 60 FPS maintained

### Phase 5 Success
- ✅ Tracks match original layouts (visual check)
- ✅ Track lengths ±10% of real values
- ✅ Documentation complete
- ✅ All tests passing
- ✅ Code committed and pushed

---

## Timeline Estimates

| Phase | Tasks | Best Case | Likely | Worst Case |
|-------|-------|-----------|--------|------------|
| 1. Acquisition | Extract files, setup | 2h | 3h | 4h |
| 2. Research | Format analysis | 6h | 8h | 12h |
| 3. Parser | Implementation | 8h | 12h | 16h |
| 4. 3D Integration | Rendering | 6h | 8h | 12h |
| 5. Validation | Testing, docs | 4h | 6h | 8h |
| **TOTAL** | | **26h** | **37h** | **52h** |

**Expected Duration:** 4-6 working days (with breaks and research time)

**Critical Path:**
1. Phase 2 (Research) - blocks everything else
2. Phase 3 (Parser) - must be correct for rendering
3. Phase 4 (Integration) - visual validation needed

---

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Format not fully documented | High | High | Community research, trial & error, budget extra time |
| Coordinate system confusing | Medium | Medium | Start with 2D, test systematically |
| ISO not available | Low | High | User must provide, consider alternatives |
| Performance issues | Low | Medium | Profile early, optimize if needed |
| Elevation data missing | Medium | Medium | Tracks will be flat, still usable |
| Checksum validation fails | Low | Low | Skip validation, log warning |
| Banking not visible | Low | Low | Visual feature only, not critical |

**Overall Risk:** MEDIUM - Format research is the biggest unknown

---

## Future Enhancements

**After Phase 5 (Future Work):**

1. **Track Editor** (Est: 20+ hours)
   - Edit track sections graphically
   - Modify racing line
   - Place objects
   - Export to .TRK format

2. **Track Objects** (Est: 6 hours)
   - Parse object placement data
   - Render grandstands, barriers, trees
   - Billboards with textures
   - Pit buildings

3. **Advanced Features**
   - Pit lane support
   - Track limits detection
   - Marshal posts / flags
   - Starting grid positions
   - Sector timing splits

4. **Community Tracks**
   - Import community-created tracks
   - Share custom circuits
   - Track workshop/browser

---

## References & Resources

**Community Documentation:**
- ArgDocs: https://www.argtools.com/argdocs/file-formats/track/
- F1GP World Championship: https://sites.google.com/view/f1gpwc
- F1GP Utils (GitHub): Various community tools

**Technical Resources:**
- Binary file analysis tools: xxd, hexdump, ghex, 010 Editor
- Visualization: matplotlib, pygame, SDL2
- Debugging: Rust debugger, print debugging, unit tests

**Reference Implementations:**
- ArgEditor (C++): Track editor for F1GP
- F1GP-Utils (Python): Various parsing tools
- Community forums: Helpful F1GP enthusiasts

**Track Data:**
- 1991 F1 season circuits
- Real-world track maps for validation
- F1GP screenshots for visual comparison

---

## Conclusion

This HLD provides a comprehensive roadmap for implementing full support for authentic F1GP track files. The multi-phase approach allows for incremental progress, with each phase delivering value and reducing risk for subsequent phases.

**Key Success Factors:**
1. **Thorough research** in Phase 2 (don't rush)
2. **Good tooling** for binary analysis
3. **Incremental validation** (test often)
4. **Community engagement** (don't work in isolation)
5. **Documentation** (capture learnings)

**Expected Outcome:**
A robust, tested track parsing system that brings all 16 classic F1GP circuits to life in modern 3D graphics, preserving the authentic layouts and feel of the 1991 classic while leveraging contemporary rendering technology.

This work will complete a major milestone for the F1GP Modern Port project, transitioning from procedural tracks to authentic historical circuits.

---

**Status:** READY FOR IMPLEMENTATION
**Next Step:** Begin Phase 1 - Acquisition & Setup
**Estimated Start:** 2025-11-16
**Estimated Completion:** 2025-11-22 (1 week)

---
