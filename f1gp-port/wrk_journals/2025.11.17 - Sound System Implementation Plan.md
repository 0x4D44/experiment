# Sound System Implementation Plan

**Date:** 2025-11-17
**Goal:** Implement audio system to reach v1.0 (85% → 95%+)
**Approach:** Use SDL2 audio (already available, no new dependencies)

---

## Sound Requirements

### Critical Sounds (v1.0)
1. **Engine Sound** - RPM-based pitch modulation
2. **Gear Shift** - Mechanical shift sound
3. **Menu Navigation** - Beep/click sounds
4. **Race Countdown** - 5-4-3-2-1 beeps

### Nice-to-Have (post v1.0)
- Tire squeal (when sliding)
- Collision sounds
- Crowd ambience
- Wind/aero sounds

---

## Technical Approach

### Option 1: SDL2 Audio (✅ CHOSEN)
**Pros:**
- Already integrated (no new deps)
- Low-level control
- Cross-platform
- Lightweight

**Cons:**
- Need to synthesize sounds
- More manual work

### Option 2: Rodio
**Pros:**
- Easy to use
- Can play audio files

**Cons:**
- Additional dependency
- Need audio files
- Less integrated

---

## Implementation Plan

### Phase 1: Basic Audio Engine

**File:** `src/audio/engine.rs` (create new)

```rust
use sdl2::audio::{AudioCallback, AudioSpecDesired};
use std::sync::{Arc, Mutex};

pub struct AudioEngine {
    device: sdl2::audio::AudioDevice<EngineCallback>,
    state: Arc<Mutex<AudioState>>,
}

struct AudioState {
    rpm: f32,
    volume: f32,
    gear_shift_trigger: bool,
}

struct EngineCallback {
    state: Arc<Mutex<AudioState>>,
    phase: f32,
}

impl AudioCallback for EngineCallback {
    type Channel = f32;

    fn callback(&mut self, out: &mut [f32]) {
        // Generate engine sound based on RPM
        let state = self.state.lock().unwrap();
        let frequency = rpm_to_frequency(state.rpm);

        for x in out.iter_mut() {
            *x = generate_engine_wave(self.phase, frequency) * state.volume;
            self.phase = (self.phase + 1.0) % 48000.0;
        }
    }
}
```

### Phase 2: Sound Synthesis

**Engine Sound Formula:**
- Base frequency from RPM: `freq = 20 + (rpm / 8000) * 300`
- Sawtooth wave for aggressive tone
- Multiple harmonics for richness
- Low-pass filter for realism

**Gear Shift:**
- Short burst (~0.1s)
- White noise + click
- Envelope: quick attack, medium decay

**Menu Beeps:**
- Simple sine wave
- 440 Hz (A note)
- 50ms duration

### Phase 3: Game Integration

**Modify:** `src/game/state.rs`

```rust
pub struct GameState {
    // ... existing fields ...
    audio_engine: Option<AudioEngine>,
}

impl GameState {
    pub fn update(&mut self, dt: f32) {
        // Update physics...

        // Update audio
        if let Some(audio) = &mut self.audio_engine {
            audio.set_rpm(self.player_car.engine_rpm);

            // Trigger gear shift sound
            if self.player_car.just_shifted {
                audio.play_gear_shift();
            }
        }
    }
}
```

### Phase 4: Volume Control

Add audio settings:
- Master volume (0.0-1.0)
- Engine volume
- Effects volume
- Mute toggle (M key)

---

## Sound Design

### Engine Sound
```
Idle (1000 RPM):  Low rumble, ~50 Hz
Mid (6000 RPM):   Higher pitch, ~180 Hz
Redline (13000):  High scream, ~300 Hz
```

Using sawtooth wave with harmonics:
- Fundamental frequency
- 2nd harmonic at 50% amplitude
- 3rd harmonic at 25% amplitude

### Gear Shift
```
Duration: 100ms
Waveform: Noise burst + transient
Envelope: Attack(10ms) -> Decay(90ms)
```

---

## Testing Plan

1. **Idle Test**: Start game, hear engine idle
2. **Rev Test**: Throttle up, pitch increases smoothly
3. **Gear Test**: Shift gears, hear mechanical sound
4. **Menu Test**: Navigate menus, hear beeps
5. **Race Test**: Full race with all sounds

---

## Performance Considerations

- Audio runs in separate thread (SDL2 handles this)
- Lock state only briefly
- Pre-calculate wave tables where possible
- Target: < 5% CPU for audio

---

## Fallback Strategy

If audio fails to initialize:
- Log warning
- Continue without sound
- Game remains playable

---

## Success Criteria

✅ Engine sound changes with RPM
✅ Gear shifts produce sound
✅ Menu navigation has audio feedback
✅ No audio lag or stuttering
✅ < 5% CPU overhead
✅ Works on Linux/macOS/Windows

---

**Estimated Effort:** 3-4 hours
**Impact:** Critical for v1.0 (85% → 95%+)

---

**Next Steps:** Implement basic AudioEngine with RPM-based synthesis
