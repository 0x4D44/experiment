# 2025-11-19 – High-Level Design: F1GP Parity & Fidelity Plan

## 1. Vision & Scope
Deliver a Rust-based reimplementation that mirrors Geoff Crammond’s 1991 F1GP in gameplay, presentation, and compatibility with original assets (tracks, cars, audio). To avoid scope drift, we adopt the following success criteria and guardrails:

- **Parity mode:** When supplied with the original asset set, the port matches lap times within ±2% on reference tracks, renders the same camera angles/hud layout within one tile, and replays the full 26-car grid with identical driver order and pit strategies.
- **Modern mode:** Optional enhancements (3D, widescreen, stereo) never break parity mode and can be toggled at runtime.
- **Deterministic tooling:** Every asset and gameplay transformation is reproducible from version-controlled scripts so contributors can regenerate artifacts.

The effort spans:
- Deterministic ingestion of original data files (tracks, cars, audio, UI tables).
- Rendering that reproduces the DOS isometric look (2.5D sprites, horizon, objects).
- Physics and AI behavior tuned to original parameters (car setups, grip curves, racing lines).
- Authentic audio, controls, user interface, and session flow.
- Tooling/tests to ensure regression-free compatibility without shipping proprietary data.

## 2. Requirements Breakdown
| Area | Requirements |
|------|--------------|
| Track/Data Layer | Parse DAT offsets deterministically; decode sections, racing lines, kerb/pit commands, object shapes, horizon, cameras. Support both original floppy/CD assets. Provide validation and conversion utilities plus a schema that captures every parsed field. |
| Rendering | Support isometric projection, original palette, sprite batching (cars, objects, HUD), horizon layers, depth sorting. Provide toggle between faithful repro and optional modern 3D mode. |
| Physics | Wheel-speed feedback, tire/kerb interaction, damage, surface grip tables, wet/dry states, car setup parameters per track. |
| AI | Use parsed racing-line segments and section commands; full 26-car grid with per-driver stats; overtaking/blue-flag logic; pit strategies. |
| Audio | Load original sample banks (AdLib/SB). Provide mixing to modern APIs, replicating mixing rates/pitches. Support menu music and SFX. |
| Controls & UX | Keyboard, joystick, gamepad mappings; UI screens mirroring original layout; HUD indicators (gear, speed, lap delta). |
| Tooling & QA | Asset extractor scripts, legal guidance, test fixtures, golden-reference tests for parser/render/physics; documentation aligned with actual status; telemetry harness for parity validation. |
| Packaging & Deployment | Reproducible builds for Windows/Linux/macOS, installer generation, asset path detection, configuration migration. |

## 3. Architectural Overview
```
         +---------------------------+
         |  Asset Manager            |
         |  (original DAT/WAD files) |
         +------------+--------------+
                      |
         +------------v--------------+
         |  Data Services Layer      |
         |  - TrackParser (Offsets)  |
         |  - RacingLine Decoder     |
         |  - Object/Audio Extractor |
         |  - Car/Driver Database    |
         +------------+--------------+
                      |
   +------------------+--------------------+
   | Core Simulation                       |
   | - Physics Engine (cars, surfaces)     |
   | - AI Controller & Racing Logic        |
   | - Session Manager (flags, pits)       |
   +------------------+--------------------+
                      |
         +------------+--------------+
         | Presentation Layer        |
         | - Renderer (Isometric)    |
         | - HUD/UI Menus            |
         | - Audio Mixer             |
         +------------+--------------+
                      |
         +------------v--------------+
         | Input & Platform Adapter  |
         | - Keyboard/Joystick       |
         | - Windowing (SDL/WGPU)    |
         | - Config/Profile System   |
         +---------------------------+
```

## 4. Subsystem Designs

### 4.1 Data & Asset Pipeline
1. **Track Parser & Validator**
   - Implement offset table adjustment (`+0x1010`) and validate both checksum and file length against known-good hashes.
   - Decode sections, command blocks, kerb/pit flags, racing-line segments, cameras, horizon bitmaps, and object shapes.
   - Provide `TrackAsset` and `TrackMeta` structs mirroring DOS structures (each field annotated with offset/size) plus a binary blob for re-export.
   - Introduce a `track_validate` CLI that compares parsed output against golden JSON fixtures (sanitized) and reports divergences.
   - Add CLI tools (`track_dump`, `asset_pack`) with sanitized fixtures for CI.
2. **Car & Driver Data**
   - Import driver stats from original `CARS.DAT`/`DRIVER.DAT` analogs.
   - Provide YAML/JSON overlays to legalize distribution (e.g., `sample_roster`) while enabling personal extraction.
3. **Audio & UI Assets**
   - Add converter extracting PCM sample banks for engines, collisions, menus; store hashed references to avoid shipping proprietary data.
   - Capture bitmap fonts/UI sprites and convert to texture atlases; generate an open-source fallback skin for CI/generic builds.
4. **Legal/Tooling**
   - Ship scripts (e.g., `tools/extract_assets.py`) with clear user instructions and checksum verification to ensure users provide authentic data.
   - Introduce data schema tests verifying parsed outputs against known hashes and provide a manifest describing exactly which proprietary files are required.

### 4.2 Rendering & UI
1. **Isometric Renderer**
   - Use sprite atlas representing cars, kerbs, track edges; adopt original palette, dithering, and shading tables.
   - Implement tile-based horizon and background parallax with a camera controller that can swap between TV angles (as in DOS) and free-cam.
   - Depth sort track objects and cars by isometric Y; ensure deterministic ordering to match replays.
   - Provide optional WGPU 3D path for modern mode but keep parity mode default; the two rendering paths share a `RenderState` to avoid divergent HUD logic.
2. **HUD/FUI**
   - Reproduce original layout (gear indicator, rev bar, lap time/delta, positions, flag indicators).
   - Use bitmap font extracted from assets.
3. **Menus & Overlays**
   - Mirror main menu, options, setup (car tuning), race results screens.
   - Support VGA/EGA-style transitions to maintain look/feel.

### 4.3 Physics & Vehicle Systems
1. **Vehicle Model**
   - Calculate wheel speeds from body velocities; integrate per-wheel forces.
   - Implement tire temp/grip curves, kerb impact, suspension, damage states.
   - Car setup parameters from track data (wings, gear ratios) influencing simulation.
2. **Track Interaction**
   - Use parsed widths, banking, kerb types for collision envelope.
   - Elevation/horizon alignment ensures crests/dips match.
3. **Weather/Surface**
   - Introduce wet/dry logic, rain transitions, and rain-specific grip table from original.
   - Provide telemetry capture comparing lap delta vs. DOS reference to iteratively tune grip curves.

### 4.4 AI & Race Management
1. **Racing Line Integration**
   - Convert parsed segments (normal/wide radius) into spline path with speed profiles and attach metadata (e.g., braking markers) derived from curvature/commands.
   - Use commands (0x80–0xAC) to trigger AI state changes (pits, camera cues, hazards); document unsupported command IDs and fallback behavior.
2. **Driver Personalities**
   - Load aggression/skill/wet skill from data; apply to error modeling.
3. **Grid & Sessions**
   - Expand to 26 AI slots; implement qualifying/practice sessions, flag system, safety car logic if present.
   - Session Manager emits deterministic events (start lights timing, yellow flag sectors) to allow parity playback/comparison.
4. **Pit & Strategy**
   - Track-specific pit entrance/exit detection, fueling, tire wear, box handling.

### 4.5 Audio System
1. **Sample Playback**
   - Build mixer that plays extracted PCM at appropriate rates (11/22 kHz) with interpolation; support channel routing to mimic Sound Blaster vs. AdLib output.
   - Support multiple concurrent channels (engines, ambient, effects) with priority rules mirroring the DOS driver.
2. **Music & Menu SFX**
   - Convert AdLib/OPL sequences or supply re-sampled tracks.
3. **Config**
   - Provide toggles for original mix vs. modern enhancements (stereo, reverb).

### 4.6 Input & Platform
1. **Device Abstraction**
   - Map keyboard, joystick, and modern gamepads via SDL2’s controller API.
   - Calibration UI for analog axes; support multiple control schemes including split-keyboard for hotseat multiplayer.
2. **Config Persistence**
   - Save input, graphics, and audio settings in a user profile file.

### 4.7 Tooling, QA, and Documentation
1. **CI Fixtures**
   - Include sanitized or procedurally generated test assets to exercise parsers/renderers.
2. **Regression Tests**
   - Parser: compare against stored JSON snapshots.
   - Renderer: golden image tests for HUD and track scenes (with public-domain track data) plus palette/dithering verification.
   - Physics/AI: scenario tests (gear shift times, lap-time sanity, AI racing line adherence) using recorded telemetry.
3. **Documentation & Telemetry**
   - Update README with honest progress, instructions for asset extraction, and roadmaps.
   - Add design docs per subsystem under `docs/` with change-history tables.
   - Provide a telemetry capture tool that logs car state for both DOS and Rust versions to aid tuning; store anonymized reference runs for regression checks.

### 4.8 Parity Validation Harness
1. **DOS Capture Pipeline**
   - Automate recording of original gameplay via DOSBox or PCem with synchronized seed (track, weather, driver lineup). Export frame hashes, car states, and audio RMS data.
   - Store recordings as encrypted artifacts requiring user-provided assets, but allow CI to run against sanitized stub data.
2. **Comparison Toolkit**
   - Build a `parity_check` tool that replays identical scenarios in the Rust port and outputs delta metrics (lap time, position order, frame differencing, audio spectrum).
   - Define acceptable thresholds per metric; failing thresholds block releases.
3. **Telemetry Schema**
   - Standardize a binary/JSON schema for captured telemetry (timestamp, car id, position, input, RPM, gear, grip, camera id) so both DOS capture and Rust sim emit comparable data.

### 4.9 Packaging & Deployment
1. **Build Targets**
   - Support Windows (MSVC), Linux (glibc + Wayland/X11), and macOS (universal binaries). Provide reproducible builds via CI pipelines with artifact signing.
2. **Installer/Bundle**
   - Ship a launcher that verifies asset presence, offers extraction helpers, and lets users pick parity vs. modern mode before boot.
3. **Configuration Management**
   - Store user profiles under OS-specific config dirs, with schema migrations and backup/restore commands.
4. **Distribution Constraints**
   - Document licensing requirements prominently; include EULA acknowledgement in the launcher since original data is user-supplied.

## 5. Phased Roadmap & Acceptance Criteria
1. **Phase 1 – Data Foundation** (Parser rewrite, asset extraction tooling, driver DB).
   - Deliverables: validated `TrackAsset`/`DriverDB`, CLI tools, CI fixtures; parity check that parsed section counts and offsets match DOS reference for at least 5 tracks.
   - Dependencies: none; blocking for all other phases.
2. **Phase 2 – Rendering & UI** (Isometric renderer, HUD, menus).
   - Deliverables: parity visuals in practice mode; screenshot diff tool shows <1 px delta vs. DOS capture on Monaco.
   - Dependencies: Phase 1 data schemas.
3. **Phase 3 – Physics & AI** (Vehicle model, racing line integration, full grid).
   - Deliverables: single race replicating DOS lap times within ±2% and AI finishing order ±2 positions.
   - Dependencies: Phase 1 & 2 assets and camera data.
4. **Phase 4 – Audio & Controls** (Sample playback, joystick support, menu music).
   - Deliverables: audio spectrograms within ±3 dB of DOS capture; joystick calibration stored in profile.
   - Dependencies: Phase 1 asset extraction; Phase 2 UI for options screen.
5. **Phase 5 – Sessions & Polish** (Practice/qualy, pit stops, documentation, packaging).
   - Deliverables: End-to-end Grand Prix weekend replicating DOS rules; updated README, installer, telemetry harness; parity-check suite green across baseline tracks.

Each phase ends with updated docs, test coverage, telemetry comparison runs, and a tagged milestone. CI executes parser/renderer/physics/audio/input suites per push.

## 6. Risks & Mitigations
- **Legal constraints** – Mitigate by shipping only tools and documentation for asset extraction; avoid bundling copyrighted data.
- **Performance** – Isometric sprite batching must stay within 60 FPS; use texture atlases and GPU instancing. Include perf budgets per subsystem and instrument frame-time telemetry in dev builds.
- **Accuracy** – Without source code, tuning physics/AI requires empirical validation; plan for telemetry capture comparing DOS version vs. Rust port, and budget time for iterative tuning sprints each phase.
- **Platform divergence** – SDL/WGPU behavior differs per OS; maintain nightly smoke tests on all targets and document platform-specific workarounds early.

## 7. Next Steps
1. Create detailed implementation tickets for Phase 1 tasks (checksum, offset adjustments, racing-line parsing, asset extractor).
2. Set up CI pipeline with sanitized fixtures and golden tests.
3. Align README with planned roadmap and document asset extraction instructions.
