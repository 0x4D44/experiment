# Comprehensive Code Review – 2025-11-18

## Summary
- The codebase establishes a broad module skeleton (data parsing, physics, AI, rendering, UI, tools), but several subsystems remain placeholders or internally inconsistent. Critical gameplay data (track offsets, objects, racing line) is neither parsed nor fed into simulation, so downstream consumers operate on mostly defaulted structures.
- Core physics/game loops rely on derived state that never updates (e.g., wheel speeds), so advertised systems such as RPM-based power delivery, surface grip, and blue-flag logic cannot behave as described without significant fixes.
- Rendering stacks mix world axes (treating Y as horizontal instead of Z), causing HUD/track visuals and collision math to disagree about where the car is. The new 3D pipeline doubles vertical offsets and runs at a fixed 16 ms timestep regardless of the actual frame rate.
- Workspace tooling and documentation are out of sync with the library API and the repository reality. Several helper crates reference fields that no longer exist and therefore do not compile; the published README claims the game is playable while `src/main.rs` still prints a placeholder banner. Integration tests require proprietary assets that are not supplied, so CI coverage is effectively zero.

## Detailed Findings

### 1. Data ingestion & assets
1. **Checksum/validation placeholders** – `calculate_checksum` and `verify_checksum` merely echo the last four bytes and check for non-zero, so corrupted track files will be accepted silently (`src/data/loader.rs:16-40`). The loader even logs "{} bytes" using `track.checksum`, so the diagnostic output is wrong (`src/data/loader.rs:56-84`). Implement the actual checksum and keep logging the real byte length.
2. **Offset table never adjusted** – The parser comments that the last three offsets require `+0x1010`, yet it returns the raw i16 values without the correction (`src/data/parser.rs:400-423`). As a result, the `checksum_position`/`object_data` members cannot be used to locate their sections later.
3. **Track sections lose width/banking/surface data** – When a section is parsed the struct is filled via `..Default::default()` (`src/data/parser.rs:214-269`), so `width`, `banking`, `surface`, etc. retain the default values from `TrackSection::default` (always 10 m wide, zero banking, asphalt; `src/data/track.rs:309-334`). Downstream consumers (collision detection, rendering) therefore work with fabricated dimensions instead of the file data.
4. **Racing line and object shapes left empty** – `parse_object_shapes` still returns an empty `Vec` and `parse_track` explicitly skips racing-line parsing, constructing `Track` instances whose `object_shapes`, `racing_line.segments`, `pit_lane`, and `cameras` are always empty (`src/data/parser.rs:386-394` and `src/data/parser.rs:568-612`). Any tooling or AI features that rely on this data has nothing to consume.
5. **Heuristic track-data discovery can silently fail** – `parse_track` iterates a list of skip distances and picks the "shortest valid" candidate in the 2.5–8 km range. If none match, `sections` stays empty and the function still returns a `Track` after logging a warning (`src/data/parser.rs:568-595`). Callers never see an error, yet later systems assume `sections` is populated.

### 2. Physics, AI, and race management
1. **Wheel speeds never update** – `CarPhysics` exposes `wheel_speeds` and bases RPM on the average rear wheel value (`src/physics/car.rs:74-164`), but those fields are written only during struct initialization. Without publishing real wheel speeds, the engine stays clamped at idle and the torque calculation (power × 1000 ÷ RPM) effectively divides by the idle RPM for the lifetime of the car.
2. **Surface grip accumulates instead of sampling** – `apply_surface_grip` multiplies the existing tire grip by the current surface multiplier each frame and clamps the result (`src/physics/car.rs:346-359`). Leaving grass momentarily will permanently reduce grip because the baseline is never restored when the car returns to asphalt. Consider storing "base" grip per tire and applying multipliers against that baseline per frame.
3. **Rigid-body orientation update is incorrect** – The integrator adds quaternions (`body.orientation + angular_quat * body.orientation`) instead of multiplying by the delta rotation (`src/physics/engine.rs:318-323`). Adding quaternions produces drift and non-normalized orientations under rotation; use the standard `body.orientation = (angular_quat * body.orientation).normalize()` or integrate via `Quat::from_axis_angle`.
4. **Collision classification ignores track heading** – `TrackCollision::check_collision` marks a car "off track" simply because its Euclidean distance from the nearest section center exceeds `width / 2` (`src/physics/collision.rs:52-99`). That penalizes cars that are ahead/behind the section rather than to the side because longitudinal deltas increase the distance just as much as lateral deltas. Project the car position onto the section tangent before comparing lateral offsets.
5. **Blue flag threshold too lax** – Drivers are only flagged blue when the leader is three laps ahead (`src/game/session.rs:226-236`), even though real rules trigger a blue flag once a car is about to be lapped. This prevents legitimate blue flags when the leader is one lap ahead.
6. **Lap/session data never incorporates actual track data** – Because `TrackSection` width, surface, and racing-line information stay at defaults (see Section 1), lap counting and AI logic operate on approximate circles, not the course described in the file.

### 3. Rendering (2D & 3D)
1. **Axis mix-ups** – Multiple render paths treat the world Y axis as horizontal: the 2D track renderer builds `Vec2::new(section.position.x, section.position.y)` (`src/render/track_renderer.rs:37-43`), the camera converts using `(world_pos.x, world_pos.y)` (`src/render/camera.rs:80-88`), and car velocity HUD data uses `Vec3::truncate()` which discards Z instead of Y (`src/game/state.rs:598-614`). However, the simulation stores forward motion in X/Z and height in Y, so the drawn track and the collision math disagree on where cars are.
2. **3D mesh doubles elevation** – `TrackMesh::from_track` maintains a `current_height` accumulator and also adds each section’s `elevation` again when computing positions (`src/render3d/track_mesh.rs:58-105`). Because `TrackSection.elevation` was already set to the cumulative elevation in `calculate_section_positions`, the mesh applies the height change twice and produces extreme slopes.
3. **3D renderer ignores actual frame time** – `Renderer3D::update` always calls `camera.update_from_car(..., 0.016)` regardless of the elapsed time passed to the app (`src/render3d/renderer.rs:643-650`). Any hitch or variable frame rate will desynchronize the 3D view from the physics state.
4. **Collision width defaults propagate visually** – Due to the data issue above, the camera fitting, track renderer, and collision system all believe sections are 10 m wide (default), so even if parsing is fixed later the rendering code will need to consume the actual header widths.

### 4. Tooling, tests, and documentation
1. **Workspace tools do not compile** – Example: `tools/playable_demo` constructs `TrackSection` literals without filling mandatory fields and references `RacingLine { points: ... }`, which no longer exists, so the crate fails to build (`tools/playable_demo/src/main.rs:140-160`). `track_inspector` likewise prints `track.racing_line.points.len()` (`tools/track_inspector/src/main.rs:51`), which prevents `cargo build -p track_inspector` from succeeding. These crates need to be updated to the current `Track` API.
2. **Tests depend on missing proprietary assets** – `tests/track_loading.rs` tries to load `assets/original/HARDDISK/F1CT*.DAT` and silently returns if the files are absent (`tests/track_loading.rs:7-42`). Because the repo does not ship those ROMs, every test becomes a no-op, so CI cannot detect regressions.
3. **README vs. reality mismatch** – The README advertises a fully playable, 95% complete game with 87 passing tests (`README.md:1-58`), yet the binary entry point only initializes logging and prints “This is a work in progress” (`src/main.rs:5-16`). Overstating project status while the executable is a stub misleads contributors and users.

## Recommendations & Next Steps
1. **Stabilize the data layer first** – Implement proper offset adjustments, checksum verification, and track-header parsing (width, banking, surfaces). Fail fast when no valid section set is found. Once the parser reliably populates `Track`, refactor renderers and collision detection to consume the real data instead of defaults.
2. **Restore physics feedback loops** – Populate `wheel_speeds` from chassis motion each frame (or derive RPM directly from linear velocity), fix quaternion integration, and rework `apply_surface_grip` to sample surfaces without permanently degrading baseline grip. Only after those corrections will the advertised physics features behave predictably.
3. **Align coordinate systems** – Decide whether world Y or Z represents "up" for 2D projections, then update the camera, renderers, and HUD to use the same axes as physics/collision. Fix the 3D mesh height accumulation and drive the 3D camera with actual `delta_time` from the main loop.
4. **Reconcile documentation and tooling** – Update the README to reflect the current state (or finish the missing functionality), and fix the workspace tools/tests so that `cargo test`/`cargo build --workspace` succeeds without proprietary assets. Consider providing mock data for CI to validate the parser.
5. **Track action items** – Use the findings above as a checklist in issue tracking (e.g., “Implement checksum,” “Populate racing line,” “Fix tool API drift”) so future contributors can pick up well-scoped tasks.
