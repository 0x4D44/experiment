<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game of Life - Test Suite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        .controls {
            text-align: center;
            margin-bottom: 30px;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .summary {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .summary-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border-radius: 12px;
            text-align: center;
            min-width: 150px;
        }

        .summary-label {
            font-size: 14px;
            opacity: 0.9;
        }

        .summary-value {
            font-size: 32px;
            font-weight: bold;
            margin-top: 5px;
        }

        .test-section {
            margin-bottom: 30px;
        }

        .test-section h2 {
            color: #667eea;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .test-case {
            background: #f5f7fa;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #ccc;
            transition: all 0.3s ease;
        }

        .test-case.pass {
            border-left-color: #38ef7d;
            background: #f0fff4;
        }

        .test-case.fail {
            border-left-color: #ff6a00;
            background: #fff5f5;
        }

        .test-case.running {
            border-left-color: #4facfe;
            background: #f0f9ff;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .test-name {
            font-weight: 600;
            color: #333;
        }

        .test-status {
            font-weight: bold;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 14px;
        }

        .test-status.pass {
            background: #38ef7d;
            color: white;
        }

        .test-status.fail {
            background: #ff6a00;
            color: white;
        }

        .test-status.running {
            background: #4facfe;
            color: white;
        }

        .test-description {
            color: #666;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .test-details {
            background: white;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
        }

        .test-details.error {
            color: #c53030;
        }

        .test-grid {
            background: #1a1a2e;
            padding: 10px;
            border-radius: 4px;
            display: inline-block;
            margin-top: 10px;
        }

        .test-grid-row {
            display: flex;
            gap: 2px;
        }

        .test-grid-cell {
            width: 15px;
            height: 15px;
            background: #2a2a3e;
        }

        .test-grid-cell.alive {
            background: #00ff88;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e2e8f0;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #38ef7d 0%, #11998e 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§ª Game of Life Test Suite</h1>
        <p class="subtitle">Comprehensive validation of Conway's rules and functionality</p>

        <div class="controls">
            <button id="runTestsBtn">Run All Tests</button>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
        </div>

        <div class="summary">
            <div class="summary-box">
                <div class="summary-label">Total Tests</div>
                <div class="summary-value" id="totalTests">0</div>
            </div>
            <div class="summary-box">
                <div class="summary-label">Passed</div>
                <div class="summary-value" id="passedTests">0</div>
            </div>
            <div class="summary-box">
                <div class="summary-label">Failed</div>
                <div class="summary-value" id="failedTests">0</div>
            </div>
            <div class="summary-box">
                <div class="summary-label">Duration</div>
                <div class="summary-value" id="duration">0ms</div>
            </div>
        </div>

        <div id="testResults"></div>
    </div>

    <script>
        // Minimal Game of Life implementation for testing
        class GameOfLife {
            constructor(rows, cols) {
                this.rows = rows;
                this.cols = cols;
                this.grid = this.createGrid();
            }

            createGrid() {
                return Array(this.rows).fill(null).map(() => Array(this.cols).fill(0));
            }

            setGrid(grid) {
                this.grid = grid.map(row => [...row]);
            }

            getGrid() {
                return this.grid.map(row => [...row]);
            }

            countNeighbors(row, col) {
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        const newRow = (row + i + this.rows) % this.rows;
                        const newCol = (col + j + this.cols) % this.cols;
                        count += this.grid[newRow][newCol];
                    }
                }
                return count;
            }

            step() {
                const nextGrid = this.createGrid();

                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const neighbors = this.countNeighbors(row, col);
                        const cell = this.grid[row][col];

                        if (cell === 1) {
                            // Living cell
                            if (neighbors < 2 || neighbors > 3) {
                                nextGrid[row][col] = 0; // Dies
                            } else {
                                nextGrid[row][col] = 1; // Survives
                            }
                        } else {
                            // Dead cell
                            if (neighbors === 3) {
                                nextGrid[row][col] = 1; // Born
                            } else {
                                nextGrid[row][col] = 0;
                            }
                        }
                    }
                }

                this.grid = nextGrid;
            }

            countLivingCells() {
                let count = 0;
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        count += this.grid[row][col];
                    }
                }
                return count;
            }
        }

        // Test framework
        class TestRunner {
            constructor() {
                this.tests = [];
                this.results = [];
            }

            test(name, description, fn) {
                this.tests.push({ name, description, fn });
            }

            async runAll() {
                this.results = [];
                const startTime = performance.now();

                for (let i = 0; i < this.tests.length; i++) {
                    const test = this.tests[i];
                    this.updateProgress(i, this.tests.length);
                    this.markTestRunning(i);

                    try {
                        await test.fn();
                        this.results.push({ ...test, status: 'pass' });
                        this.markTestPass(i);
                    } catch (error) {
                        this.results.push({ ...test, status: 'fail', error: error.message, stack: error.stack });
                        this.markTestFail(i, error);
                    }

                    await this.sleep(50); // Small delay for visual effect
                }

                const endTime = performance.now();
                const duration = Math.round(endTime - startTime);

                this.updateProgress(this.tests.length, this.tests.length);
                this.updateSummary(duration);
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            updateProgress(current, total) {
                const percent = Math.round((current / total) * 100);
                const progressBar = document.getElementById('progressBar');
                progressBar.style.width = `${percent}%`;
                progressBar.textContent = `${percent}%`;
            }

            markTestRunning(index) {
                const testCase = document.querySelectorAll('.test-case')[index];
                testCase.className = 'test-case running';
                const status = testCase.querySelector('.test-status');
                status.className = 'test-status running';
                status.textContent = 'RUNNING';
            }

            markTestPass(index) {
                const testCase = document.querySelectorAll('.test-case')[index];
                testCase.className = 'test-case pass';
                const status = testCase.querySelector('.test-status');
                status.className = 'test-status pass';
                status.textContent = 'PASS âœ“';
            }

            markTestFail(index, error) {
                const testCase = document.querySelectorAll('.test-case')[index];
                testCase.className = 'test-case fail';
                const status = testCase.querySelector('.test-status');
                status.className = 'test-status fail';
                status.textContent = 'FAIL âœ—';

                const details = testCase.querySelector('.test-details');
                if (details) {
                    details.className = 'test-details error';
                    details.textContent = `Error: ${error.message}\n\n${error.stack}`;
                    details.style.display = 'block';
                }
            }

            updateSummary(duration) {
                const passed = this.results.filter(r => r.status === 'pass').length;
                const failed = this.results.filter(r => r.status === 'fail').length;

                document.getElementById('totalTests').textContent = this.tests.length;
                document.getElementById('passedTests').textContent = passed;
                document.getElementById('failedTests').textContent = failed;
                document.getElementById('duration').textContent = `${duration}ms`;
            }

            renderTests() {
                const container = document.getElementById('testResults');
                container.innerHTML = '';

                const sections = {
                    'Conway\'s Rules': [],
                    'Pattern Evolution': [],
                    'Boundary Behavior': [],
                    'Preset Patterns': []
                };

                this.tests.forEach(test => {
                    const sectionName = test.name.split(':')[0];
                    if (sections[sectionName]) {
                        sections[sectionName].push(test);
                    }
                });

                Object.entries(sections).forEach(([sectionName, tests]) => {
                    if (tests.length === 0) return;

                    const section = document.createElement('div');
                    section.className = 'test-section';

                    const heading = document.createElement('h2');
                    heading.textContent = sectionName;
                    section.appendChild(heading);

                    tests.forEach(test => {
                        const testCase = document.createElement('div');
                        testCase.className = 'test-case';

                        const header = document.createElement('div');
                        header.className = 'test-header';

                        const name = document.createElement('div');
                        name.className = 'test-name';
                        name.textContent = test.name.split(': ')[1] || test.name;

                        const status = document.createElement('div');
                        status.className = 'test-status';
                        status.textContent = 'PENDING';

                        header.appendChild(name);
                        header.appendChild(status);

                        const description = document.createElement('div');
                        description.className = 'test-description';
                        description.textContent = test.description;

                        const details = document.createElement('div');
                        details.className = 'test-details';
                        details.style.display = 'none';

                        testCase.appendChild(header);
                        testCase.appendChild(description);
                        testCase.appendChild(details);

                        section.appendChild(testCase);
                    });

                    container.appendChild(section);
                });
            }
        }

        // Helper functions
        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEquals(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(message || `Expected ${expected}, but got ${actual}`);
            }
        }

        function assertGridEquals(actual, expected, message) {
            if (actual.length !== expected.length) {
                throw new Error(message || `Grid height mismatch: expected ${expected.length}, got ${actual.length}`);
            }

            for (let i = 0; i < actual.length; i++) {
                if (actual[i].length !== expected[i].length) {
                    throw new Error(message || `Grid width mismatch at row ${i}: expected ${expected[i].length}, got ${actual[i].length}`);
                }

                for (let j = 0; j < actual[i].length; j++) {
                    if (actual[i][j] !== expected[i][j]) {
                        throw new Error(message || `Cell mismatch at [${i}][${j}]: expected ${expected[i][j]}, got ${actual[i][j]}`);
                    }
                }
            }
        }

        // Create test suite
        const runner = new TestRunner();

        // Conway's Rules Tests
        runner.test(
            "Conway's Rules: Underpopulation",
            "A live cell with fewer than 2 neighbors dies",
            () => {
                const game = new GameOfLife(5, 5);
                game.setGrid([
                    [0, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0],
                    [0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ]);
                game.step();
                assertEquals(game.countLivingCells(), 0, "Both cells should die from underpopulation");
            }
        );

        runner.test(
            "Conway's Rules: Survival with 2 neighbors",
            "A live cell with 2 neighbors survives",
            () => {
                const game = new GameOfLife(5, 5);
                game.setGrid([
                    [0, 0, 0, 0, 0],
                    [0, 1, 1, 0, 0],
                    [0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ]);
                game.step();
                const grid = game.getGrid();
                assertEquals(grid[1][1], 1, "Cell with 2 neighbors should survive");
            }
        );

        runner.test(
            "Conway's Rules: Survival with 3 neighbors",
            "A live cell with 3 neighbors survives",
            () => {
                const game = new GameOfLife(5, 5);
                game.setGrid([
                    [0, 0, 0, 0, 0],
                    [0, 1, 1, 0, 0],
                    [0, 1, 1, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ]);
                game.step();
                const grid = game.getGrid();
                // All 4 corner cells have 3 neighbors each
                assertEquals(grid[1][1], 1, "Cell with 3 neighbors should survive");
                assertEquals(grid[1][2], 1, "Cell with 3 neighbors should survive");
                assertEquals(grid[2][1], 1, "Cell with 3 neighbors should survive");
                assertEquals(grid[2][2], 1, "Cell with 3 neighbors should survive");
            }
        );

        runner.test(
            "Conway's Rules: Overpopulation",
            "A live cell with more than 3 neighbors dies",
            () => {
                const game = new GameOfLife(5, 5);
                game.setGrid([
                    [0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0],
                    [0, 1, 1, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ]);
                game.step();
                const grid = game.getGrid();
                assertEquals(grid[1][1], 0, "Cell with 4 neighbors should die from overpopulation");
            }
        );

        runner.test(
            "Conway's Rules: Reproduction",
            "A dead cell with exactly 3 neighbors becomes alive",
            () => {
                const game = new GameOfLife(5, 5);
                game.setGrid([
                    [0, 0, 0, 0, 0],
                    [0, 1, 1, 0, 0],
                    [0, 1, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ]);
                game.step();
                const grid = game.getGrid();
                assertEquals(grid[1][1], 1, "Dead cell with 3 neighbors should become alive");
            }
        );

        // Pattern Evolution Tests
        runner.test(
            "Pattern Evolution: Still Life (Block)",
            "A 2x2 block should remain stable",
            () => {
                const game = new GameOfLife(6, 6);
                const block = [
                    [0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0],
                    [0, 0, 1, 1, 0, 0],
                    [0, 0, 1, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0]
                ];
                game.setGrid(block);
                game.step();
                assertGridEquals(game.getGrid(), block, "Block should remain unchanged");
            }
        );

        runner.test(
            "Pattern Evolution: Oscillator (Blinker) period 2",
            "A blinker should oscillate between horizontal and vertical",
            () => {
                const game = new GameOfLife(5, 5);
                const horizontal = [
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ];
                const vertical = [
                    [0, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0],
                    [0, 0, 1, 0, 0],
                    [0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0]
                ];

                game.setGrid(horizontal);
                game.step();
                assertGridEquals(game.getGrid(), vertical, "Blinker should flip to vertical");
                game.step();
                assertGridEquals(game.getGrid(), horizontal, "Blinker should flip back to horizontal");
            }
        );

        runner.test(
            "Pattern Evolution: Glider movement",
            "A glider should move diagonally",
            () => {
                const game = new GameOfLife(10, 10);
                game.setGrid([
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                ]);

                const initialCount = game.countLivingCells();

                // Run 4 generations (one cycle)
                for (let i = 0; i < 4; i++) {
                    game.step();
                }

                const finalCount = game.countLivingCells();
                assertEquals(finalCount, initialCount, "Glider should maintain its shape (5 cells)");

                // Check that it moved (at least one cell should be in a different position)
                const grid = game.getGrid();
                const hasMovedDown = grid[4][2] === 1 || grid[4][3] === 1 || grid[5][2] === 1;
                assert(hasMovedDown, "Glider should have moved down");
            }
        );

        runner.test(
            "Pattern Evolution: Toad oscillator period 2",
            "A toad should oscillate with period 2",
            () => {
                const game = new GameOfLife(6, 6);
                const toad1 = [
                    [0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0],
                    [0, 0, 1, 1, 1, 0],
                    [0, 1, 1, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0]
                ];

                game.setGrid(toad1);
                const initial = game.getGrid();
                game.step();
                const afterOne = game.getGrid();
                game.step();
                const afterTwo = game.getGrid();

                assertGridEquals(afterTwo, initial, "Toad should return to initial state after 2 generations");
            }
        );

        // Boundary Behavior Tests
        runner.test(
            "Boundary Behavior: Toroidal wrapping horizontal",
            "Cells should wrap around horizontally",
            () => {
                const game = new GameOfLife(5, 5);
                game.setGrid([
                    [0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 0],
                    [1, 0, 0, 0, 1],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ]);

                // The cells at [0][4], [2][0], and [2][4] form a glider-like pattern that wraps
                const neighbors = game.countNeighbors(1, 0);
                assertEquals(neighbors, 3, "Cell should count wrapped neighbors");
            }
        );

        runner.test(
            "Boundary Behavior: Toroidal wrapping vertical",
            "Cells should wrap around vertically",
            () => {
                const game = new GameOfLife(5, 5);
                game.setGrid([
                    [0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0]
                ]);

                const neighbors = game.countNeighbors(0, 2);
                assert(neighbors >= 2, "Cell at top should count wrapped bottom neighbor");
            }
        );

        runner.test(
            "Boundary Behavior: Corner wrapping",
            "Cells in corners should wrap correctly",
            () => {
                const game = new GameOfLife(5, 5);
                game.setGrid([
                    [1, 0, 0, 0, 1],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [1, 0, 0, 0, 1]
                ]);

                const neighbors = game.countNeighbors(0, 0);
                assertEquals(neighbors, 3, "Top-left corner should count all corner neighbors");
            }
        );

        // Preset Patterns Tests
        runner.test(
            "Preset Patterns: Blinker correctness",
            "Blinker pattern should be correctly defined",
            () => {
                const game = new GameOfLife(5, 5);
                const blinker = [
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0]
                ];
                game.setGrid(blinker);
                assertEquals(game.countLivingCells(), 3, "Blinker should have 3 cells");

                game.step();
                assertEquals(game.countLivingCells(), 3, "Blinker should maintain 3 cells");
            }
        );

        runner.test(
            "Preset Patterns: Glider correctness",
            "Glider pattern should maintain 5 cells and move",
            () => {
                const game = new GameOfLife(20, 20);
                const glider = [
                    [0, 1, 0],
                    [0, 0, 1],
                    [1, 1, 1]
                ];

                // Place glider in center
                for (let i = 0; i < glider.length; i++) {
                    for (let j = 0; j < glider[i].length; j++) {
                        game.grid[5 + i][5 + j] = glider[i][j];
                    }
                }

                assertEquals(game.countLivingCells(), 5, "Glider should have 5 cells");

                // Evolve and check it maintains 5 cells
                for (let i = 0; i < 10; i++) {
                    game.step();
                    assertEquals(game.countLivingCells(), 5, `Glider should maintain 5 cells at generation ${i + 1}`);
                }
            }
        );

        runner.test(
            "Preset Patterns: Block stability",
            "2x2 block should remain stable forever",
            () => {
                const game = new GameOfLife(10, 10);
                game.setGrid([
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                ]);

                const initial = game.getGrid();

                for (let i = 0; i < 100; i++) {
                    game.step();
                }

                assertGridEquals(game.getGrid(), initial, "Block should remain stable for 100 generations");
            }
        );

        runner.test(
            "Preset Patterns: Beacon oscillator",
            "Beacon should oscillate with period 2",
            () => {
                const game = new GameOfLife(8, 8);
                game.setGrid([
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 1, 1, 0, 0, 0, 0],
                    [0, 0, 1, 1, 0, 0, 0, 0],
                    [0, 0, 0, 0, 1, 1, 0, 0],
                    [0, 0, 0, 0, 1, 1, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0]
                ]);

                const initial = game.getGrid();
                game.step();
                const afterOne = game.getGrid();
                game.step();
                assertGridEquals(game.getGrid(), initial, "Beacon should return to initial state");
            }
        );

        runner.test(
            "Preset Patterns: Empty grid stays empty",
            "An empty grid should remain empty",
            () => {
                const game = new GameOfLife(10, 10);
                game.step();
                assertEquals(game.countLivingCells(), 0, "Empty grid should stay empty");
            }
        );

        runner.test(
            "Preset Patterns: Full extinction scenario",
            "Isolated cells should all die",
            () => {
                const game = new GameOfLife(10, 10);
                game.setGrid([
                    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                ]);

                game.step();
                assertEquals(game.countLivingCells(), 0, "All isolated cells should die");
            }
        );

        // Initialize and render tests
        runner.renderTests();

        // Run tests button
        document.getElementById('runTestsBtn').addEventListener('click', async () => {
            document.getElementById('runTestsBtn').disabled = true;
            await runner.runAll();
            document.getElementById('runTestsBtn').disabled = false;
        });

        // Auto-run tests on load
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('runTestsBtn').click();
            }, 500);
        });
    </script>
</body>
</html>
