# High-Level Design: Interactive UI Enhancements for benchctl

**Date:** 14 Nov 2025
**Author:** Design Review
**Status:** Draft
**Related:** 2025.11.13 - HLD - rust benchmarking app.md

## 1. Executive Summary

This document describes a comprehensive redesign of the benchctl TUI to provide an interactive, data-rich user experience. The enhanced UI will support module selection, expandable test details, real-time charts for cache hierarchy analysis and per-core performance visualization, and user-controlled application lifecycle.

### Key Enhancements
1. **Interactive Module Selection**: Arrow key navigation with expandable/collapsible detail views
2. **Detailed Test Results**: Display individual sub-test metrics for each module
3. **Cache Hierarchy Visualization**: Memory bandwidth charts across buffer sizes showing L1/L2/L3 cache effects
4. **Per-Core Performance Analysis**: CPU performance visualization by core ID to identify E-core vs P-core differences
5. **User-Controlled Exit**: Application remains open after test completion until user presses 'q' or Ctrl+C

## 2. Current State Analysis

### 2.1 Existing UI Architecture
The current implementation (`benchctl/src/ui.rs`) provides:
- **Simple Status Table**: Shows module name, status badge, and summary detail
- **Auto-Exit Behavior**: Application closes automatically when all tests complete
- **Non-Interactive**: No keyboard input handling beyond shutdown
- **Limited Detail**: Only shows aggregated summary (e.g., "36.52 GB/s copy")

### 2.2 Current Data Model
Each module produces rich metrics that aren't fully exposed in the UI:

**CPU Module** (`modules/cpu.rs`):
```json
{
  "threads": 24,
  "operations": [
    {"name": "int", "approx_gops": 1.68, "iterations_total": 50488680000},
    {"name": "float", "approx_gops": 1.68, "iterations_total": 50488680000},
    {"name": "hash", "approx_gops": 0.95, "iterations_total": 28500000000}
  ]
}
```

**Memory Module** (`modules/memory.rs`):
```json
{
  "buffer_mb": 512,
  "kernels": [
    {"name": "copy", "mean_gbps": 36.52, "p95_gbps": 38.34, "p99_gbps": 38.91, "samples": 1093},
    {"name": "scale", "mean_gbps": 18.71, "p95_gbps": 19.42, "p99_gbps": 19.63, "samples": 561},
    {"name": "triad", "mean_gbps": 8.15, "p95_gbps": 8.37, "p99_gbps": 8.49, "samples": 163}
  ]
}
```

**Disk Module** (`modules/disk.rs`):
```json
{
  "patterns": [
    {"pattern": "seq_write", "mb_per_sec": 2433.31},
    {"pattern": "seq_read", "mb_per_sec": 9513.74}
  ]
}
```

## 3. Goals & Requirements

### 3.1 Functional Requirements
1. **FR-1**: Support Up/Down arrow keys to select module in the list
2. **FR-2**: Support '+' or Enter key to expand selected module to show individual test results
3. **FR-3**: Support '-' or Enter key to collapse expanded module
4. **FR-4**: Display individual test results for each module when expanded
5. **FR-5**: Display memory bandwidth chart showing performance across multiple buffer sizes (4KB to 512MB) to visualize cache hierarchy
6. **FR-6**: Display per-core CPU performance chart to identify E-core vs P-core performance differences
7. **FR-7**: Application must remain open after test completion
8. **FR-8**: Support 'q' key to quit application
9. **FR-9**: Support Ctrl+C to quit application
10. **FR-10**: Display helpful status message indicating how to quit when tests complete

### 3.2 Non-Functional Requirements
1. **NFR-1**: UI must remain responsive during test execution (< 100ms input latency)
2. **NFR-2**: Charts should update in real-time as test data becomes available
3. **NFR-3**: UI layout should gracefully handle terminal resize events
4. **NFR-4**: Minimum terminal size: 120 columns × 40 rows for optimal experience
5. **NFR-5**: Color scheme should maintain accessibility and readability
6. **NFR-6**: Memory usage should not significantly increase (< 50MB additional overhead)

### 3.3 Out of Scope
- Mouse input support
- Configuration of chart parameters via UI
- Export of chart data to image files
- Historical comparison of benchmark runs in UI
- Network test latency histograms (future enhancement)

## 4. Architecture & Design

### 4.1 UI State Machine

```
┌─────────────┐
│   Running   │ ──────────────┐
│   Tests     │               │
└─────────────┘               │
       │                      │
       │ All tests complete   │
       ▼                      │
┌─────────────┐               │
│  Complete   │               │
│ (awaiting   │               │
│   user)     │               │
└─────────────┘               │
       │                      │
       │ 'q' or Ctrl+C        │
       ▼                      │
┌─────────────┐               │
│   Exiting   │ ◄─────────────┘
└─────────────┘          Ctrl+C during tests
```

### 4.2 Enhanced UI Data Model

```rust
struct UiApp {
    rows: Vec<ModuleRow>,
    selected_index: Option<usize>,
    expanded_modules: HashSet<String>,
    exit_requested: bool,
    tests_complete: bool,
    banner: String,
    theme: Theme,
    chart_data: ChartData,
}

struct ModuleRow {
    name: String,
    status: UiStatus,
    detail: Option<String>,
    sub_tests: Vec<SubTestResult>,
}

struct SubTestResult {
    name: String,
    value: String,
    unit: String,
}

struct ChartData {
    memory_by_buffer_size: Vec<MemoryBandwidthPoint>,
    cpu_by_core: Vec<CpuPerformancePoint>,
}

struct MemoryBandwidthPoint {
    buffer_size_kb: u64,
    copy_gbps: f64,
    scale_gbps: f64,
    triad_gbps: f64,
}

struct CpuPerformancePoint {
    core_id: usize,
    core_type: CoreType, // E-core, P-core, or Unknown
    gops: f64,
    operation: String,
}

enum CoreType {
    Performance,  // P-core (high frequency)
    Efficient,    // E-core (lower frequency)
    Unknown,
}
```

### 4.3 UI Layout Structure

```
┌────────────────────────────────────────────────────────────────────────────────┐
│ benchctl  │  Mode: Sequential, Runtime: TokioMultiThread       [RUNNING/DONE]  │
├────────────────────────────────────────────────────────────────────────────────┤
│ Modules                                                             ↑          │
│ ┌────────────────────────────────────────────────────────────────┐ │          │
│ │ > CPU                     [SUCCESS]   1.68 GOPS across 24 thr.. │ │ MODULE  │
│ │   ├─ int                              1.68 GOPS                 │ │  LIST   │
│ │   ├─ float                            1.68 GOPS                 │ │ (scroll)│
│ │   └─ hash                             0.95 GOPS                 │ │          │
│ │   Memory                  [RUNNING]   measuring scale kernel    │ │          │
│ │   Disk                    [PENDING]   waiting...                │ │          │
│ │   Network                 [PENDING]   waiting...                │ ↓          │
│ └────────────────────────────────────────────────────────────────┘            │
├────────────────────────────────────────────────────────────────────────────────┤
│ Performance Charts                                                             │
│ ┌──────────────────────────────────────────────────────────────────────────┐   │
│ │ Memory Bandwidth by Buffer Size (Cache Hierarchy)                        │   │
│ │  40 GB/s ┤           ████ copy                                           │   │
│ │  35 GB/s ┤       ████    ████                                            │   │
│ │  30 GB/s ┤   ████            ████                                        │   │
│ │  25 GB/s ┤                       ████                                    │   │
│ │  20 GB/s ┤████                       ████ scale                          │   │
│ │  15 GB/s ┤                               ████████                        │   │
│ │  10 GB/s ┤                                       ████ triad              │   │
│ │   5 GB/s ┤                                           ████████████        │   │
│ │          └─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────         │   │
│ │               4K   32K  256K   1M   8M   64M  512M                       │   │
│ │                         L1    L2    L3    RAM                            │   │
│ └──────────────────────────────────────────────────────────────────────────┘   │
│ ┌──────────────────────────────────────────────────────────────────────────┐   │
│ │ CPU Performance by Core (E-core vs P-core)                               │   │
│ │  2.0 GOPS ┤                                                              │   │
│ │  1.8 GOPS ┤ ███ ███ ███ ███ ███ ███ ███ ███                             │   │
│ │  1.6 GOPS ┤ ███ ███ ███ ███ ███ ███ ███ ███                             │   │
│ │  1.4 GOPS ┤ ███ ███ ███ ███ ███ ███ ███ ███                             │   │
│ │  1.2 GOPS ┤ ███ ███ ███ ███ ███ ███ ███ ███                             │   │
│ │  1.0 GOPS ┤ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███    │   │
│ │  0.8 GOPS ┤ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███ ███    │   │
│ │           └──┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬──   │   │
│ │              0   1   2   3   4   5   6   7   8   9  10  11  12  13      │   │
│ │             [────── P-cores ──────] [──────── E-cores ────────]          │   │
│ └──────────────────────────────────────────────────────────────────────────┘   │
├────────────────────────────────────────────────────────────────────────────────┤
│ Status: Tests complete • Press 'q' to quit • ↑↓ select • +/- expand/collapse  │
└────────────────────────────────────────────────────────────────────────────────┘
```

### 4.4 Layout Constraints

The screen will be divided using ratatui's `Layout` with the following constraints:

```rust
let chunks = Layout::default()
    .direction(Direction::Vertical)
    .constraints([
        Constraint::Length(3),      // Header (3 lines)
        Constraint::Percentage(40), // Module list (40% of remaining)
        Constraint::Percentage(60), // Charts (60% of remaining)
        Constraint::Length(1),      // Status footer (1 line)
    ])
    .split(f.size());
```

For the charts section, further split:
```rust
let chart_chunks = Layout::default()
    .direction(Direction::Vertical)
    .constraints([
        Constraint::Percentage(50), // Memory bandwidth chart
        Constraint::Percentage(50), // CPU per-core chart
    ])
    .split(chunks[2]);
```

## 5. Component Details

### 5.1 Input Handling

**New Event Loop** (`ui.rs:run_terminal_ui`):
```rust
fn run_terminal_ui(rx: Receiver<UiMessage>) -> Result<()> {
    terminal::enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(stdout, EnterAlternateScreen, cursor::Hide)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;
    let mut app = UiApp::default();

    loop {
        // Process incoming messages from test orchestrator
        while let Ok(msg) = rx.try_recv() {
            app.handle_message(msg);
        }

        // Handle keyboard input
        if event::poll(Duration::from_millis(100))? {
            if let Event::Key(key) = event::read()? {
                app.handle_key_event(key);
            }
        }

        // Render UI
        terminal.draw(|f| app.draw(f))?;

        // Check exit condition
        if app.should_exit() {
            break;
        }
    }

    terminal::disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen, cursor::Show)?;
    Ok(())
}
```

**Key Event Handler**:
```rust
impl UiApp {
    fn handle_key_event(&mut self, key: KeyEvent) {
        match key.code {
            KeyCode::Char('q') | KeyCode::Char('Q') => {
                self.exit_requested = true;
            }
            KeyCode::Char('c') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                self.exit_requested = true;
            }
            KeyCode::Down => {
                self.select_next();
            }
            KeyCode::Up => {
                self.select_previous();
            }
            KeyCode::Char('+') | KeyCode::Enter => {
                self.toggle_expand();
            }
            KeyCode::Char('-') => {
                self.collapse_selected();
            }
            _ => {}
        }
    }

    fn select_next(&mut self) {
        if self.rows.is_empty() {
            return;
        }
        let next = self.selected_index
            .map(|i| (i + 1) % self.rows.len())
            .unwrap_or(0);
        self.selected_index = Some(next);
    }

    fn select_previous(&mut self) {
        if self.rows.is_empty() {
            return;
        }
        let prev = self.selected_index
            .map(|i| if i == 0 { self.rows.len() - 1 } else { i - 1 })
            .unwrap_or(0);
        self.selected_index = Some(prev);
    }

    fn toggle_expand(&mut self) {
        if let Some(idx) = self.selected_index {
            if let Some(row) = self.rows.get(idx) {
                let name = row.name.clone();
                if self.expanded_modules.contains(&name) {
                    self.expanded_modules.remove(&name);
                } else {
                    self.expanded_modules.insert(name);
                }
            }
        }
    }
}
```

### 5.2 Sub-Test Data Extraction

**Message Enhancement**:
```rust
pub enum UiMessage {
    Register { name: String },
    SetBanner { text: String },
    Update {
        name: String,
        status: UiStatus,
        detail: Option<String>,
        sub_tests: Vec<SubTestResult>,  // NEW
    },
    UpdateChart {
        chart_type: ChartType,
        data: ChartDataPoint,  // NEW
    },
    Shutdown,
}

pub enum ChartType {
    MemoryBandwidth,
    CpuPerCore,
}

pub enum ChartDataPoint {
    Memory(MemoryBandwidthPoint),
    Cpu(CpuPerformancePoint),
}
```

**Module Reporting Updates** (each module):
```rust
// In CPU module (modules/cpu.rs)
fn build_sub_tests(metrics: &CpuMetrics) -> Vec<SubTestResult> {
    metrics.operations.iter().map(|op| SubTestResult {
        name: op.name.to_string(),
        value: format!("{:.2}", op.approx_gops),
        unit: "GOPS".to_string(),
    }).collect()
}

// In Memory module (modules/memory.rs)
fn build_sub_tests(metrics: &MemoryMetrics) -> Vec<SubTestResult> {
    metrics.kernels.iter().map(|k| SubTestResult {
        name: k.name.to_string(),
        value: format!("{:.2}", k.mean_gbps),
        unit: "GB/s".to_string(),
    }).collect()
}
```

### 5.3 Expandable Module Rendering

```rust
fn render_module_row(
    &self,
    row: &ModuleRow,
    idx: usize,
    is_selected: bool,
    is_expanded: bool,
) -> Vec<Row<'static>> {
    let mut rows = Vec::new();

    // Main module row
    let palette = palette_for_module(&row.name);
    let (badge_text, badge_style) = status_badge(row.status, &self.theme);
    let prefix = if is_selected { "> " } else { "  " };

    let main_row = Row::new(vec![
        Cell::from(format!("{}{}", prefix, row.name))
            .style(Style::default()
                .fg(palette.accent)
                .add_modifier(Modifier::BOLD)),
        Cell::from(badge_text).style(badge_style),
        Cell::from(row.detail.as_deref().unwrap_or("waiting..."))
            .style(Style::default().fg(palette.detail)),
    ])
    .style(Style::default().bg(
        if is_selected {
            self.theme.selected_bg
        } else {
            row_background(idx, row.status, &self.theme, &palette)
        }
    ));

    rows.push(main_row);

    // Sub-test rows (if expanded)
    if is_expanded {
        for sub_test in &row.sub_tests {
            let sub_row = Row::new(vec![
                Cell::from(format!("  ├─ {}", sub_test.name))
                    .style(Style::default().fg(palette.detail)),
                Cell::from(""),
                Cell::from(format!("{} {}", sub_test.value, sub_test.unit))
                    .style(Style::default().fg(palette.detail)),
            ])
            .style(Style::default().bg(
                if is_selected {
                    self.theme.selected_bg_dim
                } else {
                    row_background(idx, row.status, &self.theme, &palette)
                }
            ));
            rows.push(sub_row);
        }
    }

    rows
}
```

### 5.4 Chart Rendering - Memory Bandwidth by Buffer Size

**Data Collection Strategy**:
The memory module will be enhanced to run tests across multiple buffer sizes in a single execution:

```rust
// In modules/memory.rs
const CACHE_TEST_BUFFER_SIZES_KB: &[u64] = &[
    4,      // L1 cache
    32,     // L1/L2 boundary
    256,    // L2 cache
    2048,   // L2/L3 boundary (2MB)
    8192,   // L3 cache (8MB)
    65536,  // Beyond L3 (64MB)
    524288, // Main memory (512MB)
];

fn run_cache_hierarchy_test(
    ctx: &ModuleContext,
    ui_tx: Option<UiSender>,
) -> Vec<MemoryBandwidthPoint> {
    let mut results = Vec::new();

    for &buffer_kb in CACHE_TEST_BUFFER_SIZES_KB {
        let buffer_mb = buffer_kb / 1024;
        let len = ((buffer_kb * 1024) as usize) / std::mem::size_of::<f64>();
        let mut a = vec![1.0f64; len];
        let mut b = vec![2.0f64; len];
        let mut c = vec![0.0f64; len];

        // Quick test (2 seconds per buffer size)
        let duration = Duration::from_secs(2);
        let kernel_metrics = run_kernels(&mut a, &mut b, &mut c, duration, false, None)?;

        let point = MemoryBandwidthPoint {
            buffer_size_kb: buffer_kb,
            copy_gbps: kernel_metrics.iter()
                .find(|k| k.name == "copy")
                .map(|k| k.mean_gbps)
                .unwrap_or(0.0),
            scale_gbps: kernel_metrics.iter()
                .find(|k| k.name == "scale")
                .map(|k| k.mean_gbps)
                .unwrap_or(0.0),
            triad_gbps: kernel_metrics.iter()
                .find(|k| k.name == "triad")
                .map(|k| k.mean_gbps)
                .unwrap_or(0.0),
        };

        results.push(point.clone());

        // Send chart update
        if let Some(tx) = &ui_tx {
            let _ = tx.send(UiMessage::UpdateChart {
                chart_type: ChartType::MemoryBandwidth,
                data: ChartDataPoint::Memory(point),
            });
        }
    }

    results
}
```

**Chart Widget**:
```rust
use ratatui::widgets::{Axis, Chart, Dataset, GraphType};

fn render_memory_bandwidth_chart(&self, area: Rect, f: &mut Frame) {
    if self.chart_data.memory_by_buffer_size.is_empty() {
        let placeholder = Paragraph::new("Memory cache hierarchy test not yet run")
            .style(Style::default().fg(self.theme.placeholder_fg))
            .block(Block::default()
                .title("Memory Bandwidth by Buffer Size")
                .borders(Borders::ALL));
        f.render_widget(placeholder, area);
        return;
    }

    // Prepare datasets
    let copy_data: Vec<(f64, f64)> = self.chart_data.memory_by_buffer_size
        .iter()
        .map(|p| (p.buffer_size_kb as f64, p.copy_gbps))
        .collect();

    let scale_data: Vec<(f64, f64)> = self.chart_data.memory_by_buffer_size
        .iter()
        .map(|p| (p.buffer_size_kb as f64, p.scale_gbps))
        .collect();

    let triad_data: Vec<(f64, f64)> = self.chart_data.memory_by_buffer_size
        .iter()
        .map(|p| (p.buffer_size_kb as f64, p.triad_gbps))
        .collect();

    // Create datasets
    let datasets = vec![
        Dataset::default()
            .name("copy")
            .marker(symbols::Marker::Braille)
            .graph_type(GraphType::Line)
            .style(Style::default().fg(Color::Cyan))
            .data(&copy_data),
        Dataset::default()
            .name("scale")
            .marker(symbols::Marker::Braille)
            .graph_type(GraphType::Line)
            .style(Style::default().fg(Color::Green))
            .data(&scale_data),
        Dataset::default()
            .name("triad")
            .marker(symbols::Marker::Braille)
            .graph_type(GraphType::Line)
            .style(Style::default().fg(Color::Magenta))
            .data(&triad_data),
    ];

    // Determine axis bounds
    let max_gbps = copy_data.iter()
        .map(|(_, gbps)| gbps)
        .fold(0.0f64, |a, &b| a.max(b))
        * 1.1; // 10% padding

    // X-axis labels with cache level annotations
    let x_labels = vec![
        Span::raw("4K"),
        Span::raw("32K"),
        Span::raw("256K"),
        Span::styled("L1", Style::default().fg(Color::Yellow)),
        Span::raw("1M"),
        Span::raw("8M"),
        Span::styled("L2", Style::default().fg(Color::Yellow)),
        Span::raw("64M"),
        Span::raw("512M"),
        Span::styled("L3/RAM", Style::default().fg(Color::Yellow)),
    ];

    let chart = Chart::new(datasets)
        .block(Block::default()
            .title("Memory Bandwidth by Buffer Size (Cache Hierarchy)")
            .borders(Borders::ALL)
            .border_style(Style::default().fg(self.theme.chart_border)))
        .x_axis(Axis::default()
            .title("Buffer Size")
            .style(Style::default().fg(Color::Gray))
            .bounds([0.0, 524288.0])  // 4KB to 512MB (log scale ideal, but linear for simplicity)
            .labels(x_labels))
        .y_axis(Axis::default()
            .title("Bandwidth (GB/s)")
            .style(Style::default().fg(Color::Gray))
            .bounds([0.0, max_gbps])
            .labels(vec![
                Span::raw("0"),
                Span::raw(format!("{:.0}", max_gbps / 2.0)),
                Span::raw(format!("{:.0}", max_gbps)),
            ]));

    f.render_widget(chart, area);
}
```

### 5.5 Chart Rendering - CPU Performance by Core

**Data Collection Strategy**:
The CPU module will be enhanced to run single-core tests with core affinity:

```rust
// In modules/cpu.rs
use core_affinity;

fn run_per_core_test(
    ctx: &ModuleContext,
    ui_tx: Option<UiSender>,
) -> Vec<CpuPerformancePoint> {
    let core_ids = core_affinity::get_core_ids()
        .unwrap_or_else(|| vec![]);
    let mut results = Vec::new();

    // Detect core types (heuristic: use CPU frequency if available)
    let core_types = detect_core_types(&core_ids);

    for (idx, core_id) in core_ids.iter().enumerate() {
        // Pin to specific core
        core_affinity::set_for_current(*core_id);

        // Run short test (1 second per core)
        let duration = Duration::from_secs(1);
        let operations = vec![CpuOperation::Int];
        let counters = run_workers(&operations, 1, duration, None);

        let gops = counters[0] as f64 / duration.as_secs_f64() / 1_000_000_000.0;

        let point = CpuPerformancePoint {
            core_id: idx,
            core_type: core_types.get(idx).copied().unwrap_or(CoreType::Unknown),
            gops,
            operation: "int".to_string(),
        };

        results.push(point.clone());

        // Send chart update
        if let Some(tx) = &ui_tx {
            let _ = tx.send(UiMessage::UpdateChart {
                chart_type: ChartType::CpuPerCore,
                data: ChartDataPoint::Cpu(point),
            });
        }
    }

    results
}

fn detect_core_types(core_ids: &[CoreId]) -> Vec<CoreType> {
    // Heuristic: On hybrid architectures (12th+ gen Intel, Apple Silicon),
    // P-cores typically have higher max frequency
    // This is a simplified detection; production would use CPUID or platform APIs

    #[cfg(target_os = "linux")]
    {
        use std::fs;
        let mut freqs: Vec<(usize, u64)> = core_ids.iter().enumerate()
            .filter_map(|(idx, _)| {
                let path = format!("/sys/devices/system/cpu/cpu{}/cpufreq/cpuinfo_max_freq", idx);
                fs::read_to_string(&path)
                    .ok()
                    .and_then(|s| s.trim().parse::<u64>().ok())
                    .map(|freq| (idx, freq))
            })
            .collect();

        if freqs.is_empty() {
            return vec![CoreType::Unknown; core_ids.len()];
        }

        // If there's a significant frequency gap (> 20%), classify as hybrid
        freqs.sort_by_key(|(_, freq)| std::cmp::Reverse(*freq));
        let max_freq = freqs[0].1;
        let min_freq = freqs.last().unwrap().1;

        if max_freq > min_freq * 12 / 10 {  // 20% difference
            let threshold = (max_freq + min_freq) / 2;
            return (0..core_ids.len()).map(|idx| {
                let freq = freqs.iter()
                    .find(|(i, _)| *i == idx)
                    .map(|(_, f)| *f)
                    .unwrap_or(min_freq);
                if freq >= threshold {
                    CoreType::Performance
                } else {
                    CoreType::Efficient
                }
            }).collect();
        }
    }

    vec![CoreType::Unknown; core_ids.len()]
}
```

**Chart Widget**:
```rust
use ratatui::widgets::BarChart;

fn render_cpu_per_core_chart(&self, area: Rect, f: &mut Frame) {
    if self.chart_data.cpu_by_core.is_empty() {
        let placeholder = Paragraph::new("CPU per-core test not yet run")
            .style(Style::default().fg(self.theme.placeholder_fg))
            .block(Block::default()
                .title("CPU Performance by Core")
                .borders(Borders::ALL));
        f.render_widget(placeholder, area);
        return;
    }

    // Prepare bar chart data
    let bars: Vec<(&str, u64)> = self.chart_data.cpu_by_core
        .iter()
        .map(|p| {
            let label = Box::leak(format!("{}", p.core_id).into_boxed_str()) as &str;
            let value = (p.gops * 100.0) as u64; // Scale for display
            (label, value)
        })
        .collect();

    // Determine colors based on core type
    let bar_style = |point: &CpuPerformancePoint| {
        match point.core_type {
            CoreType::Performance => Style::default().fg(Color::Cyan),
            CoreType::Efficient => Style::default().fg(Color::Green),
            CoreType::Unknown => Style::default().fg(Color::Gray),
        }
    };

    // Create legend showing core type ranges
    let legend = if self.chart_data.cpu_by_core.iter()
        .any(|p| p.core_type != CoreType::Unknown) {
        let p_cores: Vec<_> = self.chart_data.cpu_by_core.iter()
            .enumerate()
            .filter(|(_, p)| p.core_type == CoreType::Performance)
            .map(|(i, _)| i)
            .collect();
        let e_cores: Vec<_> = self.chart_data.cpu_by_core.iter()
            .enumerate()
            .filter(|(_, p)| p.core_type == CoreType::Efficient)
            .map(|(i, _)| i)
            .collect();

        format!(
            "P-cores: {:?}, E-cores: {:?}",
            p_cores,
            e_cores
        )
    } else {
        "Core types not detected".to_string()
    };

    let chart = BarChart::default()
        .block(Block::default()
            .title(format!("CPU Performance by Core ({})", legend))
            .borders(Borders::ALL)
            .border_style(Style::default().fg(self.theme.chart_border)))
        .bar_width(3)
        .bar_gap(1)
        .bar_style(Style::default().fg(Color::Cyan))
        .value_style(Style::default().fg(Color::White).add_modifier(Modifier::BOLD))
        .label_style(Style::default().fg(Color::Gray))
        .data(&bars)
        .max(self.chart_data.cpu_by_core.iter()
            .map(|p| (p.gops * 100.0) as u64)
            .max()
            .unwrap_or(100) * 11 / 10); // 10% padding

    f.render_widget(chart, area);
}
```

### 5.6 Exit Behavior Modification

**Current Implementation** (`ui.rs:226`):
```rust
fn should_exit(&self) -> bool {
    self.exit_requested && self.rows.iter().all(|row| row.status.is_terminal())
}
```

**New Implementation**:
```rust
fn should_exit(&self) -> bool {
    self.exit_requested  // Exit only when user explicitly requests
}

fn are_tests_complete(&self) -> bool {
    !self.rows.is_empty() && self.rows.iter().all(|row| row.status.is_terminal())
}

// In message handler
fn handle_message(&mut self, msg: UiMessage) {
    match msg {
        UiMessage::Update { name, status, detail, sub_tests } => {
            // ... existing update logic ...

            // Check if all tests just completed
            if self.are_tests_complete() && !self.tests_complete {
                self.tests_complete = true;
                self.banner = "Tests complete • Press 'q' to quit • ↑↓ select • +/- expand".to_string();
            }
        }
        // ... other cases ...
    }
}
```

**Status Footer**:
```rust
fn render_footer(&self, area: Rect, f: &mut Frame) {
    let status_text = if self.tests_complete {
        "Tests complete • Press 'q' to quit • ↑↓ select module • +/- expand/collapse"
    } else {
        "Running tests... • Ctrl+C to abort • ↑↓ select module • +/- expand/collapse"
    };

    let footer = Paragraph::new(status_text)
        .style(Style::default()
            .fg(if self.tests_complete {
                Color::Green
            } else {
                Color::Yellow
            })
            .add_modifier(Modifier::BOLD))
        .block(Block::default()
            .borders(Borders::TOP)
            .border_style(Style::default().fg(self.theme.footer_border)));

    f.render_widget(footer, area);
}
```

## 6. Configuration Enhancements

### 6.1 New Configuration Options

Add to `config.toml`:
```toml
[ui]
# Enable/disable interactive features
interactive = true

# Enable/disable chart generation
charts_enabled = true

# Specific chart controls
enable_cache_hierarchy_chart = true
enable_per_core_chart = true

# Auto-exit behavior (legacy compatibility)
auto_exit = false

[memory]
# Existing options...
buffer_mb = 512

# NEW: Enable cache hierarchy test (runs multiple buffer sizes)
test_cache_hierarchy = true

# NEW: Buffer sizes for cache test (KB)
cache_test_sizes = [4, 32, 256, 2048, 8192, 65536, 524288]

[cpu]
# Existing options...
threads = "auto"
operations = ["int", "float", "hash"]

# NEW: Enable per-core performance test
test_per_core = true

# NEW: Duration for per-core test (seconds per core)
per_core_duration_secs = 1
```

### 6.2 CLI Arguments

Add to `cli.rs`:
```rust
#[derive(Parser)]
pub struct Cli {
    // ... existing args ...

    /// Disable interactive UI features (charts, keyboard input)
    #[arg(long)]
    pub no_interactive: bool,

    /// Auto-exit after tests complete (legacy mode)
    #[arg(long)]
    pub auto_exit: bool,

    /// Disable chart generation
    #[arg(long)]
    pub no_charts: bool,
}
```

## 7. Testing Strategy

### 7.1 Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_selection_navigation() {
        let mut app = UiApp::default();
        app.rows = vec![
            ModuleRow::new("cpu"),
            ModuleRow::new("memory"),
            ModuleRow::new("disk"),
        ];

        app.select_next();
        assert_eq!(app.selected_index, Some(0));

        app.select_next();
        assert_eq!(app.selected_index, Some(1));

        app.select_previous();
        assert_eq!(app.selected_index, Some(0));
    }

    #[test]
    fn test_expand_collapse() {
        let mut app = UiApp::default();
        app.rows = vec![ModuleRow::new("cpu")];
        app.selected_index = Some(0);

        app.toggle_expand();
        assert!(app.expanded_modules.contains("cpu"));

        app.toggle_expand();
        assert!(!app.expanded_modules.contains("cpu"));
    }

    #[test]
    fn test_exit_behavior() {
        let mut app = UiApp::default();

        // Should not exit without explicit request
        assert!(!app.should_exit());

        // Should exit when requested
        app.exit_requested = true;
        assert!(app.should_exit());
    }

    #[test]
    fn test_core_type_detection() {
        // Mock test for core type detection
        let core_ids = vec![/* mock core IDs */];
        let types = detect_core_types(&core_ids);
        assert_eq!(types.len(), core_ids.len());
    }
}
```

### 7.2 Integration Tests

```rust
#[test]
fn test_memory_cache_hierarchy() {
    let mut config = BenchConfig::default();
    config.memory.test_cache_hierarchy = true;
    config.memory.cache_test_sizes = vec![4, 256, 8192, 524288];

    let ctx = ModuleContext::new(/* ... */);
    let mut module = MemoryModule::new();

    let report = module.execute(&ctx).unwrap();

    // Verify chart data was collected
    assert!(report.metrics.get("cache_hierarchy").is_some());
    let hierarchy = report.metrics["cache_hierarchy"].as_array().unwrap();
    assert_eq!(hierarchy.len(), 4);
}

#[test]
fn test_cpu_per_core() {
    let mut config = BenchConfig::default();
    config.cpu.test_per_core = true;

    let ctx = ModuleContext::new(/* ... */);
    let mut module = CpuModule::new();

    let report = module.execute(&ctx).unwrap();

    // Verify per-core data was collected
    assert!(report.metrics.get("per_core").is_some());
}
```

### 7.3 Manual Testing Scenarios

1. **Terminal Size Handling**:
   - Test with minimum size (120×40)
   - Test with very large terminal (4K display)
   - Test dynamic resizing during execution

2. **Keyboard Input**:
   - Navigation with arrow keys
   - Expand/collapse with +/-
   - Exit with 'q' and Ctrl+C
   - Rapid key presses (stress test)

3. **Chart Rendering**:
   - Verify cache hierarchy shows expected L1/L2/L3 transitions
   - Verify per-core chart identifies E/P cores correctly on hybrid CPUs
   - Test with systems that don't have hybrid architecture

4. **Data Integrity**:
   - Verify expanded sub-tests match JSON output
   - Verify chart data matches raw metrics
   - Verify all tests complete successfully

## 8. Performance Considerations

### 8.1 UI Rendering Performance

- **Target**: Maintain < 100ms input latency
- **Strategy**:
  - Limit chart data points (max 100 points per dataset)
  - Use efficient data structures (Vec over HashMap for small collections)
  - Minimize allocations in hot rendering path
  - Cache computed layouts where possible

### 8.2 Test Execution Overhead

**Cache Hierarchy Test**:
- 7 buffer sizes × 2 seconds = ~14 seconds additional overhead
- Mitigation: Make this test optional (controlled by config)

**Per-Core Test**:
- 24 cores × 1 second = ~24 seconds additional overhead on a 24-core system
- Mitigation:
  - Reduce per-core duration to 0.5 seconds
  - Make this test optional
  - Skip on systems with > 32 cores

### 8.3 Memory Overhead

**Chart Data Storage**:
```
Memory chart: 7 points × 4 fields × 8 bytes = 224 bytes
CPU chart: 24 cores × 4 fields × 8 bytes = 768 bytes
Total: ~1 KB (negligible)
```

**Expanded Module State**:
```
HashSet<String>: ~24 bytes per module × 4 modules = 96 bytes
SubTestResult: ~64 bytes × 10 sub-tests × 4 modules = 2.5 KB
Total: ~3 KB (negligible)
```

## 9. Migration & Deployment

### 9.1 Backward Compatibility

- Legacy mode supported via `--auto-exit` flag
- Non-interactive mode via `--no-interactive` flag
- Chart generation can be disabled via `--no-charts`
- Existing JSON output format unchanged (charts data added as additional fields)

### 9.2 Deployment Plan

**Phase 1** (Week 1-2): Core Interactive Features
- Implement keyboard input handling
- Add module selection and expansion
- Modify exit behavior
- Update sub-test data extraction

**Phase 2** (Week 3-4): Chart Infrastructure
- Implement chart data collection
- Add chart rendering widgets
- Integrate chart updates during test execution

**Phase 3** (Week 5-6): Advanced Features & Polish
- Implement cache hierarchy test
- Implement per-core test
- Add core type detection
- Performance optimization

**Phase 4** (Week 7): Testing & Documentation
- Comprehensive testing on multiple platforms
- User documentation
- Example screenshots

### 9.3 Rollback Plan

If critical issues arise:
1. Revert to previous UI via feature flag: `--legacy-ui`
2. Disable chart generation: `charts_enabled = false` in config
3. Full rollback: git revert to previous stable tag

## 10. Future Enhancements

### 10.1 Additional Charts

1. **Network Latency Histogram**:
   - Show latency distribution (p50, p95, p99)
   - Identify packet loss patterns

2. **Disk IOPS by Queue Depth**:
   - Vary queue depth from 1 to 64
   - Show IOPS scaling characteristics

3. **CPU Thread Scaling**:
   - Run CPU test with 1, 2, 4, 8, ... threads
   - Show scaling efficiency

### 10.2 Export & Sharing

- Export chart data as CSV for external analysis
- Generate PNG/SVG images of charts (via external tool integration)
- HTML report generation with embedded charts

### 10.3 Comparative Analysis

- Load baseline metrics from previous runs
- Overlay baseline on charts for comparison
- Highlight regressions/improvements

### 10.4 Real-Time Filtering

- Filter modules by status (e.g., only show running tests)
- Search/filter sub-tests by name
- Customize chart display (select which datasets to show)

## 11. Open Questions & Decisions

### 11.1 Design Decisions

**Q1**: Should we use logarithmic scale for buffer size X-axis in memory chart?
- **Decision**: Use linear scale initially for simplicity. Log scale can be added as enhancement.
- **Rationale**: Linear scale is easier to understand for non-expert users.

**Q2**: Should per-core test run in parallel or sequentially?
- **Decision**: Sequential (one core at a time)
- **Rationale**: Avoids interference; provides clearer per-core measurements.

**Q3**: Should we auto-detect if system has hybrid architecture?
- **Decision**: Yes, use heuristic based on CPU frequency
- **Rationale**: Better user experience; fallback to "Unknown" if detection fails.

**Q4**: Should charts update in real-time during test execution?
- **Decision**: Yes, send `UiMessage::UpdateChart` as data becomes available
- **Rationale**: Provides better visual feedback; helps users understand test progress.

### 11.2 Open Questions

**Q1**: How should we handle very wide terminals (> 200 columns)?
- **Option A**: Use extra space for wider charts
- **Option B**: Add side panel with additional stats
- **Recommendation**: Option A for initial implementation

**Q2**: Should we support mouse input for module selection?
- **Recommendation**: Defer to future enhancement (not in scope for v1)

**Q3**: Should we provide a "quick mode" that skips chart tests?
- **Recommendation**: Yes, via `--no-charts` flag

## 12. Success Criteria

### 12.1 Functional Success Metrics

- ✅ User can navigate modules with arrow keys
- ✅ User can expand/collapse modules with +/- keys
- ✅ Application only exits when user presses 'q' or Ctrl+C
- ✅ Memory bandwidth chart shows clear cache transitions
- ✅ CPU per-core chart identifies E/P cores on hybrid systems
- ✅ All existing tests pass with new UI
- ✅ JSON output includes new chart data

### 12.2 Non-Functional Success Metrics

- ✅ Input latency < 100ms (measured via manual testing)
- ✅ UI renders correctly on terminals from 120×40 to 300×80
- ✅ Additional memory overhead < 50MB
- ✅ Chart tests complete within 2× original runtime
- ✅ No visual glitches during terminal resize

### 12.3 User Experience Metrics

- ✅ Users can understand cache hierarchy without external documentation
- ✅ Users can identify E-core vs P-core performance at a glance
- ✅ UI feels responsive and interactive
- ✅ Clear instructions displayed for keyboard shortcuts

## 13. Documentation Requirements

### 13.1 User Documentation

- Update README with screenshots of new UI
- Document keyboard shortcuts
- Explain chart interpretations (cache hierarchy, E/P cores)
- Provide examples of config options

### 13.2 Developer Documentation

- Architecture diagrams for UI data flow
- Module extension guide (how to add chart data)
- Chart widget customization guide
- Performance profiling guide

## 14. Appendix

### 14.1 Reference Screenshots

_(To be added during implementation)_

### 14.2 Dependencies

**New Crates**:
```toml
[dependencies]
# Existing dependencies...
ratatui = "0.26"
crossterm = "0.27"

# New dependencies for enhanced UI
core_affinity = "0.8"  # For per-core CPU pinning
```

### 14.3 Platform Compatibility

| Feature | Linux | macOS | Windows |
|---------|-------|-------|---------|
| Interactive UI | ✅ | ✅ | ✅ |
| Module Expansion | ✅ | ✅ | ✅ |
| Memory Chart | ✅ | ✅ | ✅ |
| CPU Chart | ✅ | ✅ | ⚠️ (limited) |
| Core Type Detection | ✅ | ✅ | ❌ |
| Core Affinity | ✅ | ✅ | ⚠️ (limited) |

Legend:
- ✅ Fully supported
- ⚠️ Partial support or platform limitations
- ❌ Not supported

### 14.4 Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Chart rendering performance issues | Medium | Medium | Limit data points, optimize rendering |
| Core detection fails on some CPUs | High | Low | Fallback to "Unknown" |
| Per-core test too slow on high-core count | Medium | Medium | Make test optional, reduce duration |
| Terminal compatibility issues | Low | High | Test on major terminals (iTerm, Terminal, Windows Terminal) |
| Chart data too large for JSON | Low | Low | Add size limits, sampling |

### 14.5 Glossary

- **E-core**: Efficiency core (lower frequency, lower power)
- **P-core**: Performance core (higher frequency, higher power)
- **Cache Hierarchy**: L1 → L2 → L3 → RAM memory levels
- **STREAM**: Sustainable Memory Bandwidth benchmark
- **TUI**: Terminal User Interface
- **HDR Histogram**: High Dynamic Range histogram for latency measurements

---

**Reviewers**: Please provide feedback on:
1. Chart design and data collection strategy
2. Performance overhead acceptability
3. Platform compatibility concerns
4. User experience considerations

**Approval**: _Pending review_
