# jrnrvw - Multistage Implementation Plan

**Version:** 1.0
**Date:** 2025.11.13
**Project:** jrnrvw (Journal Review Tool)
**Based on:** jrnrvw tool specification v1.0
**Total Duration:** 4-5 weeks

---

## Executive Summary

This document outlines a comprehensive multistage implementation plan for the jrnrvw (Journal Review) tool. The implementation is divided into 7 major stages, each with specific deliverables, acceptance criteria, and dependencies. The plan follows an iterative approach, delivering a minimal viable product early and progressively adding features.

**Key Milestones:**
- Stage 1-2: MVP (Weeks 1-2) - Basic functionality
- Stage 3-4: Feature Complete (Week 3) - All core features
- Stage 5-6: Production Ready (Week 4) - Polish and testing
- Stage 7: Release (Week 5) - Distribution and documentation

---

## Table of Contents

1. [Stage 0: Project Setup](#stage-0-project-setup)
2. [Stage 1: Core Data Models and Foundation](#stage-1-core-data-models-and-foundation)
3. [Stage 2: File Discovery and Basic Parsing](#stage-2-file-discovery-and-basic-parsing)
4. [Stage 3: Analysis, Filtering, and Grouping](#stage-3-analysis-filtering-and-grouping)
5. [Stage 4: Output Formatters and CLI](#stage-4-output-formatters-and-cli)
6. [Stage 5: Advanced Features and Configuration](#stage-5-advanced-features-and-configuration)
7. [Stage 6: Testing and Quality Assurance](#stage-6-testing-and-quality-assurance)
8. [Stage 7: Documentation and Release](#stage-7-documentation-and-release)
9. [Risk Management](#risk-management)
10. [Resource Requirements](#resource-requirements)

---

## Stage 0: Project Setup

**Duration:** 0.5 days
**Dependencies:** None
**Status:** Foundation

### Objectives
- Initialize Rust project structure
- Set up version control and development environment
- Configure dependencies
- Establish coding standards and tooling

### Tasks

#### 0.1 Initialize Rust Project
- [ ] Create new Rust project: `cargo new jrnrvw`
- [ ] Set up Git repository
- [ ] Create `.gitignore` for Rust projects
- [ ] Initialize directory structure according to spec

#### 0.2 Configure Cargo.toml
- [ ] Set project metadata (name, version, authors, edition)
- [ ] Add core dependencies:
  ```toml
  [dependencies]
  clap = { version = "4.4", features = ["derive", "cargo"] }
  walkdir = "2.4"
  regex = "1.10"
  chrono = { version = "0.4", features = ["serde"] }
  serde = { version = "1.0", features = ["derive"] }
  serde_json = "1.0"
  pulldown-cmark = "0.9"
  anyhow = "1.0"
  thiserror = "1.0"

  [dev-dependencies]
  tempfile = "3.8"
  assert_cmd = "2.0"
  predicates = "3.0"
  ```
- [ ] Add optional dependencies for output formatting:
  ```toml
  colored = "2.1"
  comfy-table = "7.1"
  tera = "1.19"
  csv = "1.3"
  toml = "0.8"
  ```

#### 0.3 Project Structure
Create directory structure:
```
jrnrvw/
├── .git/
├── .gitignore
├── Cargo.toml
├── Cargo.lock
├── README.md
├── LICENSE
├── src/
│   ├── main.rs
│   ├── lib.rs
│   ├── cli.rs
│   ├── error.rs
│   ├── models/
│   │   └── mod.rs
│   ├── discovery/
│   │   └── mod.rs
│   ├── parser/
│   │   └── mod.rs
│   ├── analyzer/
│   │   └── mod.rs
│   ├── output/
│   │   └── mod.rs
│   └── config/
│       └── mod.rs
├── tests/
│   ├── integration/
│   │   └── mod.rs
│   └── fixtures/
│       └── sample_journals/
└── examples/
    └── basic_usage.rs
```

#### 0.4 Development Tooling
- [ ] Set up `rustfmt.toml` for code formatting
- [ ] Configure `clippy.toml` for linting
- [ ] Set up pre-commit hooks (optional)
- [ ] Configure CI/CD skeleton (GitHub Actions)

#### 0.5 Initial Documentation
- [ ] Create basic README.md
- [ ] Add LICENSE file (MIT or Apache-2.0)
- [ ] Create CONTRIBUTING.md guidelines
- [ ] Initialize CHANGELOG.md

### Deliverables
- ✅ Functioning Rust project that compiles
- ✅ All dependencies configured
- ✅ Git repository initialized
- ✅ Project structure in place
- ✅ Development environment ready

### Acceptance Criteria
- `cargo build` succeeds without errors
- `cargo test` runs (even with no tests)
- Project follows Rust conventions
- All development tools configured

### Time Estimate: 4 hours

---

## Stage 1: Core Data Models and Foundation

**Duration:** 1.5 days
**Dependencies:** Stage 0
**Status:** Foundation

### Objectives
- Implement core data structures
- Create error handling framework
- Build foundational types and traits
- Set up module organization

### Tasks

#### 1.1 Error Handling Framework
File: `src/error.rs`

- [ ] Define custom error types using `thiserror`:
  ```rust
  #[derive(Debug, thiserror::Error)]
  pub enum JrnrvwError {
      #[error("IO error: {0}")]
      Io(#[from] std::io::Error),

      #[error("Invalid date format in filename: {0}")]
      InvalidDateFormat(String),

      #[error("Failed to parse journal file: {0}")]
      ParseError(String),

      #[error("Invalid regex pattern: {0}")]
      InvalidRegex(#[from] regex::Error),

      #[error("Configuration error: {0}")]
      ConfigError(String),
  }

  pub type Result<T> = std::result::Result<T, JrnrvwError>;
  ```

- [ ] Implement Display and Debug traits
- [ ] Add error context helpers
- [ ] Create error conversion implementations

#### 1.2 Journal Entry Model
File: `src/models/journal.rs`

- [ ] Implement `JournalEntry` struct:
  ```rust
  use chrono::NaiveDate;
  use serde::{Serialize, Deserialize};
  use std::path::PathBuf;

  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct JournalEntry {
      pub date: NaiveDate,
      pub filename: String,
      pub filepath: PathBuf,
      pub title: Option<String>,
      pub task: Option<String>,
      pub repository: Option<String>,
      pub activities: Vec<String>,
      pub notes: Option<String>,
      pub time_spent: Option<String>,
      pub raw_content: String,
  }

  impl JournalEntry {
      pub fn new(filepath: PathBuf, date: NaiveDate) -> Self { ... }
      pub fn with_content(self, content: String) -> Self { ... }
  }
  ```

- [ ] Add constructor methods
- [ ] Implement builder pattern for optional fields
- [ ] Add helper methods (e.g., `is_in_repo`, `matches_task`)
- [ ] Implement comparison traits (Ord, PartialOrd) for sorting

#### 1.3 Repository and Task Models
File: `src/models/repository.rs`

- [ ] Implement `Repository` struct:
  ```rust
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Repository {
      pub name: String,
      pub path: PathBuf,
      pub tasks: Vec<Task>,
  }

  impl Repository {
      pub fn new(name: String, path: PathBuf) -> Self { ... }
      pub fn add_task(&mut self, task: Task) { ... }
      pub fn find_task(&self, name: &str) -> Option<&Task> { ... }
      pub fn entry_count(&self) -> usize { ... }
  }
  ```

- [ ] Implement `Task` struct:
  ```rust
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct Task {
      pub name: String,
      pub entries: Vec<JournalEntry>,
  }

  impl Task {
      pub fn new(name: String) -> Self { ... }
      pub fn add_entry(&mut self, entry: JournalEntry) { ... }
      pub fn date_range(&self) -> Option<(NaiveDate, NaiveDate)> { ... }
  }
  ```

- [ ] Add helper methods for grouping and aggregation

#### 1.4 Report and Statistics Models
File: `src/models/report.rs`

- [ ] Implement `Report` struct:
  ```rust
  #[derive(Debug, Serialize, Deserialize)]
  pub struct Report {
      pub metadata: ReportMetadata,
      pub repositories: Vec<Repository>,
      pub statistics: Statistics,
  }
  ```

- [ ] Implement `ReportMetadata`:
  ```rust
  #[derive(Debug, Serialize, Deserialize)]
  pub struct ReportMetadata {
      pub generated_at: chrono::DateTime<chrono::Utc>,
      pub period: Option<DateRange>,
      pub total_entries: usize,
      pub repository_count: usize,
  }
  ```

- [ ] Implement `Statistics`:
  ```rust
  #[derive(Debug, Serialize, Deserialize)]
  pub struct Statistics {
      pub total_entries: usize,
      pub date_range_days: i64,
      pub active_days: usize,
      pub repositories: usize,
      pub unique_tasks: usize,
      pub total_time: Option<String>,
  }
  ```

- [ ] Implement `DateRange`:
  ```rust
  #[derive(Debug, Clone, Serialize, Deserialize)]
  pub struct DateRange {
      pub from: NaiveDate,
      pub to: NaiveDate,
  }
  ```

#### 1.5 Common Types and Traits
File: `src/models/common.rs`

- [ ] Define grouping enums:
  ```rust
  #[derive(Debug, Clone, Copy)]
  pub enum GroupBy {
      Repository,
      Task,
      Date,
      Week,
      Month,
  }

  #[derive(Debug, Clone, Copy)]
  pub enum SortBy {
      Date,
      Repository,
      Task,
  }

  #[derive(Debug, Clone, Copy)]
  pub enum OutputFormat {
      Text,
      Markdown,
      Json,
      Html,
      Csv,
  }
  ```

- [ ] Implement FromStr for CLI parsing
- [ ] Add validation methods

#### 1.6 Module Organization
File: `src/models/mod.rs`

- [ ] Set up module exports
- [ ] Re-export commonly used types
- [ ] Add module-level documentation

#### 1.7 Unit Tests for Models
Files: `src/models/*.rs` (inline tests)

- [ ] Test JournalEntry creation and methods
- [ ] Test Repository grouping logic
- [ ] Test Task aggregation
- [ ] Test date range calculations
- [ ] Test serialization/deserialization
- [ ] Test edge cases (empty data, invalid dates)

### Deliverables
- ✅ Complete data model implementation
- ✅ Error handling framework
- ✅ Comprehensive unit tests for models
- ✅ Full rustdoc documentation

### Acceptance Criteria
- All models compile without warnings
- Unit tests achieve >90% coverage for models
- Serialization to/from JSON works correctly
- Error types cover all failure modes
- Documentation is complete and clear

### Time Estimate: 12 hours

---

## Stage 2: File Discovery and Basic Parsing

**Duration:** 2 days
**Dependencies:** Stage 1
**Status:** Core Feature

### Objectives
- Implement file discovery system
- Build filename parser for date extraction
- Create basic markdown parser
- Extract metadata from journal files

### Tasks

#### 2.1 File Discovery - Scanner
File: `src/discovery/scanner.rs`

- [ ] Implement `JournalScanner` struct:
  ```rust
  use walkdir::WalkDir;
  use std::path::{Path, PathBuf};

  pub struct JournalScanner {
      root_path: PathBuf,
      exclude_dirs: Vec<String>,
      case_sensitive: bool,
  }

  impl JournalScanner {
      pub fn new(root_path: PathBuf) -> Self { ... }
      pub fn with_excludes(mut self, excludes: Vec<String>) -> Self { ... }
      pub fn scan(&self) -> Result<Vec<PathBuf>> { ... }
  }
  ```

- [ ] Implement recursive directory traversal using `walkdir`
- [ ] Add directory exclusion logic (skip .git, target, node_modules)
- [ ] Handle permission errors gracefully
- [ ] Implement early filtering based on file extension (.md)
- [ ] Add progress callback support (for future verbose mode)

#### 2.2 File Discovery - Filename Pattern Matching
File: `src/discovery/filters.rs`

- [ ] Implement `FilenameParser`:
  ```rust
  use regex::Regex;
  use chrono::NaiveDate;

  pub struct FilenameParser {
      pattern: Regex,
  }

  impl FilenameParser {
      pub fn new() -> Result<Self> { ... }
      pub fn matches(&self, filename: &str) -> bool { ... }
      pub fn parse_date(&self, filename: &str) -> Result<NaiveDate> { ... }
      pub fn parse_description(&self, filename: &str) -> Result<String> { ... }
  }
  ```

- [ ] Create regex pattern: `^(\d{4})\.(\d{2})\.(\d{2})\s*-\s*JRN\s*-\s*(.+)\.md$`
- [ ] Implement date extraction and validation
- [ ] Parse description from filename
- [ ] Handle variations in spacing and case
- [ ] Add comprehensive error messages

#### 2.3 Markdown Parser - Structure Extraction
File: `src/parser/journal.rs`

- [ ] Implement `JournalParser`:
  ```rust
  use pulldown_cmark::{Parser, Event, Tag};

  pub struct JournalParser {
      content: String,
  }

  impl JournalParser {
      pub fn new(content: String) -> Self { ... }
      pub fn parse(&self) -> Result<ParsedContent> { ... }
      fn extract_sections(&self) -> HashMap<String, String> { ... }
  }
  ```

- [ ] Use `pulldown-cmark` to parse markdown AST
- [ ] Identify header sections (## Task, ## Activities, etc.)
- [ ] Extract content under each header
- [ ] Handle nested lists (for activities)
- [ ] Support flexible section naming variations

#### 2.4 Metadata Extraction
File: `src/parser/metadata.rs`

- [ ] Implement `MetadataExtractor`:
  ```rust
  pub struct MetadataExtractor {
      sections: HashMap<String, String>,
  }

  impl MetadataExtractor {
      pub fn new(sections: HashMap<String, String>) -> Self { ... }
      pub fn extract_task(&self) -> Option<String> { ... }
      pub fn extract_repository(&self) -> Option<String> { ... }
      pub fn extract_activities(&self) -> Vec<String> { ... }
      pub fn extract_notes(&self) -> Option<String> { ... }
      pub fn extract_time_spent(&self) -> Option<String> { ... }
  }
  ```

- [ ] Extract task from "Task" or "Project" sections
- [ ] Extract repository from "Repo" or "Repository" sections
- [ ] Parse activity lists (bullet points)
- [ ] Extract notes section
- [ ] Parse time spent (support various formats: "2h", "2 hours", "120m")
- [ ] Handle missing or malformed sections gracefully

#### 2.5 Repository Detection
File: `src/discovery/repo_detector.rs`

- [ ] Implement `RepositoryDetector`:
  ```rust
  use std::path::{Path, PathBuf};

  pub struct RepositoryDetector;

  impl RepositoryDetector {
      pub fn detect(journal_path: &Path) -> String { ... }
      fn find_git_root(path: &Path) -> Option<PathBuf> { ... }
      fn extract_repo_name(path: &Path) -> String { ... }
  }
  ```

- [ ] Priority 1: Use explicit repository from metadata
- [ ] Priority 2: Walk up directory tree to find .git/
- [ ] Priority 3: Use parent directory name
- [ ] Priority 4: Return "Unknown"
- [ ] Extract repository name from git remote (optional enhancement)

#### 2.6 Integration - Discovery to Entry
File: `src/discovery/mod.rs`

- [ ] Implement orchestration function:
  ```rust
  pub fn discover_journals(
      root: &Path,
      excludes: Vec<String>
  ) -> Result<Vec<JournalEntry>> { ... }
  ```

- [ ] Combine scanner, parser, and metadata extraction
- [ ] Handle errors per-file (continue on failure)
- [ ] Collect parsing errors for verbose reporting
- [ ] Return fully populated JournalEntry vector

#### 2.7 Unit and Integration Tests
Files: `src/discovery/*.rs`, `tests/integration/discovery_tests.rs`

- [ ] Test filename pattern matching (valid/invalid formats)
- [ ] Test date parsing edge cases (leap years, invalid dates)
- [ ] Test directory scanning with exclusions
- [ ] Test markdown parsing with various structures
- [ ] Test metadata extraction with missing sections
- [ ] Test repository detection (with/without git)
- [ ] Create test fixtures (sample journal files)
- [ ] Test error handling and recovery

### Deliverables
- ✅ Complete file discovery system
- ✅ Filename and date parser
- ✅ Markdown parser with metadata extraction
- ✅ Repository detection
- ✅ Integration tests with fixtures
- ✅ >80% code coverage

### Acceptance Criteria
- Successfully finds all journal files in test fixtures
- Correctly parses dates from filenames
- Extracts all metadata fields from well-formed journals
- Handles malformed files gracefully
- Detects git repositories accurately
- All tests pass
- No panics or crashes on invalid input

### Time Estimate: 16 hours

---

## Stage 3: Analysis, Filtering, and Grouping

**Duration:** 2 days
**Dependencies:** Stage 2
**Status:** Core Feature

### Objectives
- Implement time range filtering
- Build grouping logic (by repo, task, date)
- Create statistics calculator
- Implement sorting capabilities

### Tasks

#### 3.1 Time Range Filtering - Date Range Parser
File: `src/analyzer/filter.rs`

- [ ] Implement `TimeRangeFilter`:
  ```rust
  use chrono::{NaiveDate, Duration, Datelike};

  pub enum TimeRange {
      LastWeek,
      LastMonth,
      ThisWeek,
      ThisMonth,
      ActivityDays(usize),
      Custom { from: NaiveDate, to: NaiveDate },
      Since(NaiveDate),
      Before(NaiveDate),
  }

  impl TimeRange {
      pub fn to_date_range(&self, today: NaiveDate) -> DateRange { ... }
      pub fn includes(&self, date: NaiveDate) -> bool { ... }
  }
  ```

- [ ] Implement `LastWeek` (7 days from today)
- [ ] Implement `LastMonth` (30 days from today)
- [ ] Implement `ThisWeek` (current Monday to Sunday)
- [ ] Implement `ThisMonth` (first to last day of current month)
- [ ] Implement custom date ranges

#### 3.2 Activity-Based Time Windows
File: `src/analyzer/activity_window.rs`

- [ ] Implement `ActivityWindowFilter`:
  ```rust
  pub struct ActivityWindowFilter {
      window_size: usize,
  }

  impl ActivityWindowFilter {
      pub fn new(window_size: usize) -> Self { ... }
      pub fn filter(&self, entries: &[JournalEntry]) -> Vec<NaiveDate> { ... }
  }
  ```

- [ ] Collect all unique dates from entries
- [ ] Sort dates in descending order
- [ ] Take N most recent dates
- [ ] Return set of dates to include
- [ ] Handle edge cases (fewer entries than window size)

#### 3.3 Entry Filtering
File: `src/analyzer/filter.rs`

- [ ] Implement `EntryFilter`:
  ```rust
  pub struct EntryFilter {
      time_range: Option<TimeRange>,
      repo_pattern: Option<Regex>,
      task_pattern: Option<Regex>,
  }

  impl EntryFilter {
      pub fn new() -> Self { ... }
      pub fn with_time_range(mut self, range: TimeRange) -> Self { ... }
      pub fn with_repo_pattern(mut self, pattern: &str) -> Result<Self> { ... }
      pub fn with_task_pattern(mut self, pattern: &str) -> Result<Self> { ... }
      pub fn apply(&self, entries: Vec<JournalEntry>) -> Vec<JournalEntry> { ... }
  }
  ```

- [ ] Filter by date range
- [ ] Filter by repository (regex match)
- [ ] Filter by task (regex match)
- [ ] Combine multiple filters (AND logic)
- [ ] Preserve original entries (non-destructive)

#### 3.4 Grouping Engine
File: `src/analyzer/grouper.rs`

- [ ] Implement `Grouper`:
  ```rust
  pub struct Grouper {
      group_by: GroupBy,
      sort_by: SortBy,
      reverse: bool,
  }

  impl Grouper {
      pub fn new(group_by: GroupBy, sort_by: SortBy) -> Self { ... }
      pub fn group_entries(&self, entries: Vec<JournalEntry>) -> Vec<Repository> { ... }
  }
  ```

- [ ] Group by repository:
  - Collect all entries per repository
  - Create Repository structs
  - Within each repo, group by task

- [ ] Group by task:
  - Create flat list of tasks
  - Attach entries to tasks
  - Optionally show repository per task

- [ ] Group by date:
  - Create date-based buckets
  - Group entries by exact date

- [ ] Group by week:
  - Calculate week number
  - Group entries by week

- [ ] Group by month:
  - Calculate month
  - Group entries by month

#### 3.5 Sorting Logic
File: `src/analyzer/sorter.rs`

- [ ] Implement sorting for repositories:
  ```rust
  pub fn sort_repositories(
      repos: &mut Vec<Repository>,
      sort_by: SortBy,
      reverse: bool
  ) { ... }
  ```

- [ ] Sort by date (most recent first/last)
- [ ] Sort by repository name (alphabetically)
- [ ] Sort by task name (alphabetically)
- [ ] Support reverse order
- [ ] Sort tasks within repositories
- [ ] Sort entries within tasks

#### 3.6 Statistics Calculator
File: `src/analyzer/stats.rs`

- [ ] Implement `StatisticsCalculator`:
  ```rust
  pub struct StatisticsCalculator<'a> {
      entries: &'a [JournalEntry],
      repositories: &'a [Repository],
  }

  impl<'a> StatisticsCalculator<'a> {
      pub fn new(entries: &'a [JournalEntry], repos: &'a [Repository]) -> Self { ... }
      pub fn calculate(&self) -> Statistics { ... }
  }
  ```

- [ ] Calculate total entries
- [ ] Calculate date range (earliest to latest)
- [ ] Calculate active days (unique dates with entries)
- [ ] Count unique repositories
- [ ] Count unique tasks
- [ ] Aggregate total time spent (parse and sum time values)
- [ ] Calculate entries per repository/task

#### 3.7 Report Builder
File: `src/analyzer/report_builder.rs`

- [ ] Implement `ReportBuilder`:
  ```rust
  pub struct ReportBuilder {
      entries: Vec<JournalEntry>,
      filter: EntryFilter,
      grouper: Grouper,
  }

  impl ReportBuilder {
      pub fn new(entries: Vec<JournalEntry>) -> Self { ... }
      pub fn with_filter(mut self, filter: EntryFilter) -> Self { ... }
      pub fn with_grouping(mut self, grouper: Grouper) -> Self { ... }
      pub fn build(self) -> Result<Report> { ... }
  }
  ```

- [ ] Apply filters to entries
- [ ] Group entries into repositories/tasks
- [ ] Calculate statistics
- [ ] Assemble Report struct
- [ ] Add metadata (generation time, etc.)

#### 3.8 Unit Tests
Files: Inline tests in `src/analyzer/*.rs`

- [ ] Test date range calculations
- [ ] Test activity window filtering
- [ ] Test entry filtering (time, repo, task)
- [ ] Test grouping by each type
- [ ] Test sorting in both directions
- [ ] Test statistics calculation accuracy
- [ ] Test edge cases (empty entries, single entry)
- [ ] Test report builder integration

### Deliverables
- ✅ Complete filtering system
- ✅ Flexible grouping engine
- ✅ Statistics calculator
- ✅ Report builder
- ✅ Comprehensive unit tests
- ✅ >85% code coverage

### Acceptance Criteria
- All time range options work correctly
- Activity window correctly skips gaps
- Grouping produces correct hierarchy
- Statistics are accurate
- Sorting works in all modes
- Edge cases handled gracefully
- All tests pass

### Time Estimate: 16 hours

---

## Stage 4: Output Formatters and CLI

**Duration:** 2.5 days
**Dependencies:** Stage 3
**Status:** Core Feature

### Objectives
- Implement all output formatters (text, markdown, JSON, HTML, CSV)
- Build complete CLI interface
- Integrate all components
- Create working MVP

### Tasks

#### 4.1 Output Trait Definition
File: `src/output/mod.rs`

- [ ] Define output trait:
  ```rust
  pub trait Formatter {
      fn format(&self, report: &Report, options: &OutputOptions) -> Result<String>;
  }

  pub struct OutputOptions {
      pub colored: bool,
      pub verbose: bool,
      pub include_activities: bool,
      pub include_notes: bool,
      pub include_stats: bool,
      pub summary_only: bool,
  }
  ```

- [ ] Implement common helper functions
- [ ] Set up module exports

#### 4.2 Text Formatter
File: `src/output/text.rs`

- [ ] Implement `TextFormatter`:
  ```rust
  pub struct TextFormatter {
      colored: bool,
  }

  impl Formatter for TextFormatter {
      fn format(&self, report: &Report, options: &OutputOptions) -> Result<String> { ... }
  }
  ```

- [ ] Format header with metadata
- [ ] Format repositories with indentation
- [ ] Format tasks under repositories
- [ ] Format entries under tasks
- [ ] Format activities and notes (if requested)
- [ ] Format statistics section
- [ ] Add color support using `colored` crate
- [ ] Handle summary-only mode
- [ ] Use `comfy-table` for tabular data in stats

#### 4.3 Markdown Formatter
File: `src/output/markdown.rs`

- [ ] Implement `MarkdownFormatter`:
  ```rust
  pub struct MarkdownFormatter;

  impl Formatter for MarkdownFormatter {
      fn format(&self, report: &Report, options: &OutputOptions) -> Result<String> { ... }
  }
  ```

- [ ] Generate markdown headers (# ## ###)
- [ ] Create bullet lists for activities
- [ ] Add code blocks for statistics
- [ ] Generate tables for summary data
- [ ] Add metadata frontmatter (optional)
- [ ] Ensure proper markdown formatting
- [ ] Support GitHub-flavored markdown

#### 4.4 JSON Formatter
File: `src/output/json.rs`

- [ ] Implement `JsonFormatter`:
  ```rust
  pub struct JsonFormatter {
      pretty: bool,
  }

  impl Formatter for JsonFormatter {
      fn format(&self, report: &Report, options: &OutputOptions) -> Result<String> { ... }
  }
  ```

- [ ] Use `serde_json` to serialize Report
- [ ] Support pretty-printing option
- [ ] Ensure all data is included
- [ ] Handle optional fields correctly
- [ ] Validate JSON output

#### 4.5 HTML Formatter
File: `src/output/html.rs`

- [ ] Implement `HtmlFormatter`:
  ```rust
  pub struct HtmlFormatter {
      template_engine: tera::Tera,
  }

  impl Formatter for HtmlFormatter {
      fn format(&self, report: &Report, options: &OutputOptions) -> Result<String> { ... }
  }
  ```

- [ ] Create HTML template using Tera
- [ ] Design responsive layout
- [ ] Add inline CSS for styling
- [ ] Create collapsible sections
- [ ] Add table of contents
- [ ] Support dark/light themes
- [ ] Ensure accessibility (semantic HTML)

Template structure:
```html
<!DOCTYPE html>
<html>
<head>
    <title>Journal Review Report</title>
    <style>/* Inline CSS */</style>
</head>
<body>
    <header><!-- Metadata --></header>
    <nav><!-- Table of contents --></nav>
    <main>
        <!-- Repositories -->
        <!-- Tasks -->
        <!-- Entries -->
    </main>
    <footer><!-- Statistics --></footer>
</body>
</html>
```

#### 4.6 CSV Formatter
File: `src/output/csv.rs`

- [ ] Implement `CsvFormatter`:
  ```rust
  pub struct CsvFormatter;

  impl Formatter for CsvFormatter {
      fn format(&self, report: &Report, options: &OutputOptions) -> Result<String> { ... }
  }
  ```

- [ ] Flatten hierarchical data into rows
- [ ] Create columns: Date, Repository, Task, Filename, Activities, Notes, Time
- [ ] Use `csv` crate for proper escaping
- [ ] Add header row
- [ ] Handle multi-line activities (join with semicolon or newline)
- [ ] Ensure Excel compatibility

CSV structure:
```
Date,Repository,Task,Filename,Activities,Notes,TimeSpent
2025-11-13,myapp,Authentication,"2025.11.13 - JRN - auth.md","Activity 1; Activity 2","Some notes",4h
```

#### 4.7 CLI Interface - Argument Parsing
File: `src/cli.rs`

- [ ] Implement CLI structure using `clap`:
  ```rust
  use clap::{Parser, ValueEnum};

  #[derive(Parser)]
  #[command(name = "jrnrvw")]
  #[command(about = "Journal Review Tool - Analyze task journal files")]
  #[command(version)]
  pub struct Cli {
      /// Root directory to search
      #[arg(value_name = "PATH")]
      pub path: Option<PathBuf>,

      // Time range options
      #[arg(long, conflicts_with_all = ["last_month", "this_week"])]
      pub last_week: bool,

      #[arg(long)]
      pub last_month: bool,

      #[arg(long)]
      pub this_week: bool,

      #[arg(long)]
      pub this_month: bool,

      #[arg(long, value_name = "N")]
      pub activity_days: Option<usize>,

      #[arg(long, value_name = "DATE")]
      pub from: Option<NaiveDate>,

      #[arg(long, value_name = "DATE")]
      pub to: Option<NaiveDate>,

      // Filtering
      #[arg(long, value_name = "PATTERN")]
      pub repo: Option<String>,

      #[arg(long, value_name = "PATTERN")]
      pub task: Option<String>,

      // Grouping and sorting
      #[arg(long, value_enum, default_value = "repo")]
      pub group_by: GroupByArg,

      #[arg(long, value_enum, default_value = "date")]
      pub sort_by: SortByArg,

      #[arg(long)]
      pub reverse: bool,

      // Output
      #[arg(short, long, value_name = "FILE")]
      pub output: Option<PathBuf>,

      #[arg(short = 'f', long, value_enum, default_value = "text")]
      pub format: FormatArg,

      #[arg(long)]
      pub no_color: bool,

      #[arg(short, long)]
      pub verbose: bool,

      #[arg(short, long)]
      pub quiet: bool,

      // Display options
      #[arg(long)]
      pub summary: bool,

      #[arg(long)]
      pub with_activities: bool,

      #[arg(long)]
      pub with_notes: bool,

      #[arg(long)]
      pub stats: bool,

      // Config
      #[arg(long, value_name = "FILE")]
      pub config: Option<PathBuf>,
  }
  ```

- [ ] Define value enums for group-by, sort-by, format
- [ ] Add argument validation
- [ ] Implement conflict resolution
- [ ] Add help text and examples
- [ ] Support short and long flags

#### 4.8 Main Application Logic
File: `src/main.rs`

- [ ] Implement main function:
  ```rust
  fn main() -> Result<()> {
      let cli = Cli::parse();

      // 1. Determine root path
      let root_path = cli.path.unwrap_or_else(|| env::current_dir().unwrap());

      // 2. Discover journal files
      let entries = discover_journals(&root_path, vec![])?;

      // 3. Build filter from CLI args
      let filter = build_filter(&cli)?;

      // 4. Build grouper from CLI args
      let grouper = build_grouper(&cli);

      // 5. Build report
      let report = ReportBuilder::new(entries)
          .with_filter(filter)
          .with_grouping(grouper)
          .build()?;

      // 6. Format output
      let output_options = build_output_options(&cli);
      let formatted = format_report(&report, &cli.format, &output_options)?;

      // 7. Write output
      write_output(&formatted, &cli.output)?;

      Ok(())
  }
  ```

- [ ] Implement helper functions (build_filter, build_grouper, etc.)
- [ ] Handle errors with user-friendly messages
- [ ] Add verbose logging
- [ ] Support quiet mode
- [ ] Add progress indicators (if verbose)

#### 4.9 Integration Tests
File: `tests/integration/end_to_end.rs`

- [ ] Test complete workflow: discovery → filtering → grouping → formatting
- [ ] Test each output format
- [ ] Test CLI argument parsing
- [ ] Test file output
- [ ] Test error scenarios
- [ ] Use `assert_cmd` for CLI testing
- [ ] Create comprehensive test fixtures

### Deliverables
- ✅ All 5 output formatters working
- ✅ Complete CLI interface
- ✅ Integrated application (MVP)
- ✅ End-to-end integration tests
- ✅ Command-line help documentation

### Acceptance Criteria
- CLI accepts all specified arguments
- All output formats generate correct output
- Application runs end-to-end without errors
- Help text is clear and comprehensive
- Integration tests cover main workflows
- MVP can be used for basic journal analysis

### Time Estimate: 20 hours

---

## Stage 5: Advanced Features and Configuration

**Duration:** 1.5 days
**Dependencies:** Stage 4
**Status:** Enhancement

### Objectives
- Implement configuration file support
- Add advanced filtering options
- Enhance error reporting
- Add output enhancements (colors, tables)
- Implement summary mode

### Tasks

#### 5.1 Configuration File Support
File: `src/config/settings.rs`

- [ ] Define configuration structure:
  ```rust
  use serde::{Deserialize, Serialize};

  #[derive(Debug, Deserialize, Serialize)]
  pub struct Config {
      pub general: GeneralConfig,
      pub discovery: DiscoveryConfig,
      pub parsing: ParsingConfig,
      pub output: OutputConfig,
      pub time_ranges: TimeRangesConfig,
  }

  #[derive(Debug, Deserialize, Serialize)]
  pub struct GeneralConfig {
      pub default_path: String,
      pub default_format: String,
      pub colored_output: bool,
  }

  // ... other config sections
  ```

- [ ] Implement config loading:
  ```rust
  impl Config {
      pub fn load_from_file(path: &Path) -> Result<Self> { ... }
      pub fn load_default() -> Result<Option<Self>> { ... }
      pub fn merge_with_cli(&self, cli: &Cli) -> Config { ... }
  }
  ```

- [ ] Load from `~/.jrnrvw.toml`
- [ ] Load from `./.jrnrvw.toml` (project-level)
- [ ] Merge configurations (priority: CLI > project > user > default)
- [ ] Validate configuration values
- [ ] Provide meaningful error messages for invalid config

#### 5.2 Configuration File Resolution
File: `src/config/loader.rs`

- [ ] Implement config file search:
  ```rust
  pub fn find_config_file(cli_path: Option<&Path>) -> Option<PathBuf> {
      // 1. CLI-specified config (highest priority)
      // 2. ./.jrnrvw.toml (project)
      // 3. ~/.jrnrvw.toml (user)
      // 4. None (use defaults)
  }
  ```

- [ ] Load and parse TOML files
- [ ] Handle missing files gracefully
- [ ] Report config syntax errors clearly

#### 5.3 Enhanced Error Messages
File: `src/error.rs` (enhance)

- [ ] Add context to errors using `anyhow`
- [ ] Implement detailed error reporting
- [ ] Add suggestions for common errors
- [ ] Create error codes for documentation reference
- [ ] Implement verbose error mode

Example:
```rust
Error: Failed to parse journal file: 2025.11.13 - JRN - invalid.md

Caused by:
    Invalid date format in section header

Suggestion:
    Ensure the markdown file contains a valid date header:
    # 2025.11.13 - Journal: Title
```

#### 5.4 Output Enhancements - Colored Output
File: `src/output/text.rs` (enhance)

- [ ] Add color theme support:
  - Repository names: Blue/Cyan
  - Task names: Green
  - Dates: Yellow
  - Activities: White
  - Statistics: Magenta
  - Errors/Warnings: Red

- [ ] Respect `--no-color` flag
- [ ] Detect terminal capabilities
- [ ] Add bold/italic formatting where appropriate

#### 5.5 Output Enhancements - Table Formatting
File: `src/output/table.rs`

- [ ] Create statistics table using `comfy-table`:
  ```rust
  pub fn format_statistics_table(stats: &Statistics) -> String {
      let mut table = Table::new();
      table.set_header(vec!["Metric", "Value"]);
      // Add rows...
      table.to_string()
  }
  ```

- [ ] Format summary data as tables
- [ ] Add borders and styling
- [ ] Support different table styles (ASCII, Unicode)

#### 5.6 Summary Mode Implementation
File: `src/output/summary.rs`

- [ ] Implement concise summary output:
  ```
  Journal Review Summary
  =====================
  Period: 2025-11-07 to 2025-11-13 (7 days, 4 active)

  Repositories: 3
    - myapp: 5 entries, 2 tasks
    - infrastructure: 2 entries, 1 task
    - docs: 1 entry, 1 task

  Total Entries: 8
  Total Tasks: 4
  Time Spent: 28h 30m
  ```

- [ ] Create high-level overview
- [ ] Aggregate key metrics
- [ ] Support all output formats in summary mode

#### 5.7 Verbose Mode
File: `src/main.rs` (enhance)

- [ ] Add logging framework (optional: `env_logger`)
- [ ] Log discovery progress
- [ ] Log parsing errors (with context)
- [ ] Show filtering statistics
- [ ] Display timing information
- [ ] Show configuration being used

#### 5.8 Unit Tests for Config and Enhancements
- [ ] Test config loading and merging
- [ ] Test config file resolution
- [ ] Test colored output (with/without colors)
- [ ] Test summary mode output
- [ ] Test verbose logging
- [ ] Test error message formatting

### Deliverables
- ✅ Configuration file support (TOML)
- ✅ Enhanced error messages
- ✅ Colored terminal output
- ✅ Table formatting for statistics
- ✅ Summary mode
- ✅ Verbose mode
- ✅ Unit tests for new features

### Acceptance Criteria
- Config files load correctly
- CLI args override config settings
- Error messages are clear and helpful
- Colors work in terminals that support them
- Summary mode provides useful overview
- Verbose mode aids debugging
- All tests pass

### Time Estimate: 12 hours

---

## Stage 6: Testing and Quality Assurance

**Duration:** 2 days
**Dependencies:** Stages 1-5
**Status:** Quality Assurance

### Objectives
- Achieve comprehensive test coverage
- Perform integration testing
- Conduct performance testing
- Fix bugs and edge cases
- Perform code review and refactoring

### Tasks

#### 6.1 Unit Test Coverage
- [ ] Review test coverage using `cargo tarpaulin` or `cargo llvm-cov`
- [ ] Achieve >80% code coverage overall
- [ ] Achieve >90% coverage for critical modules:
  - Models
  - Parser
  - Analyzer
  - Formatters
- [ ] Add tests for untested edge cases
- [ ] Add tests for error paths

#### 6.2 Integration Test Suite
File: `tests/integration/`

- [ ] Create comprehensive test fixtures:
  - [ ] Well-formed journals (various structures)
  - [ ] Malformed journals (missing sections, invalid dates)
  - [ ] Empty journals
  - [ ] Large journals (>1MB)
  - [ ] Journals with special characters
  - [ ] Multi-repository test tree
  - [ ] Journals with various date ranges

- [ ] Test discovery scenarios:
  - [ ] Nested directories
  - [ ] Excluded directories
  - [ ] Mixed file types
  - [ ] Permission issues (if possible)

- [ ] Test end-to-end workflows:
  - [ ] Default behavior (no args)
  - [ ] Each time range option
  - [ ] Each grouping option
  - [ ] Each output format
  - [ ] Combined filters
  - [ ] Config file + CLI args

- [ ] Test CLI using `assert_cmd`:
  ```rust
  #[test]
  fn test_last_week_flag() {
      let mut cmd = Command::cargo_bin("jrnrvw").unwrap();
      cmd.arg("--last-week")
         .arg("tests/fixtures")
         .assert()
         .success();
  }
  ```

#### 6.3 Performance Testing
File: `tests/performance/`

- [ ] Create performance test suite:
  - [ ] Generate large test dataset (1000+ journals)
  - [ ] Test discovery performance
  - [ ] Test parsing performance
  - [ ] Test grouping performance
  - [ ] Test formatting performance

- [ ] Benchmark critical operations:
  ```rust
  #[bench]
  fn bench_journal_discovery(b: &mut Bencher) {
      b.iter(|| {
          discover_journals(Path::new("tests/fixtures/large"))
      });
  }
  ```

- [ ] Set performance targets:
  - Discovery: <1s for 1000 files
  - Parsing: <5ms per file average
  - Report generation: <100ms for 100 entries
  - Memory usage: <50MB for 1000 entries

- [ ] Profile with `cargo flamegraph` (optional)

#### 6.4 Error Handling Tests
File: `tests/integration/error_cases.rs`

- [ ] Test all error scenarios:
  - Invalid date in filename
  - Malformed markdown
  - Invalid regex patterns
  - Missing directories
  - Invalid config files
  - Invalid CLI arguments
  - Write permission errors

- [ ] Verify error messages are helpful
- [ ] Ensure no panics or crashes

#### 6.5 Cross-Platform Testing
- [ ] Test on Linux
- [ ] Test on macOS
- [ ] Test on Windows
- [ ] Test path handling (Windows vs Unix)
- [ ] Test line ending handling (CRLF vs LF)
- [ ] Test color output on different terminals

#### 6.6 Regression Testing
- [ ] Create regression test suite for fixed bugs
- [ ] Document each regression test with issue reference
- [ ] Ensure all previous bugs remain fixed

#### 6.7 Code Review and Refactoring
- [ ] Run `cargo clippy` and fix all warnings
- [ ] Run `cargo fmt` to ensure consistent formatting
- [ ] Review code for:
  - Unnecessary allocations
  - Inefficient algorithms
  - Code duplication
  - Unclear variable names
  - Missing documentation

- [ ] Refactor identified issues
- [ ] Ensure all public APIs have rustdoc comments
- [ ] Add examples to documentation

#### 6.8 Security Review
- [ ] Review for potential security issues:
  - Path traversal vulnerabilities
  - Regex DoS (ReDoS) attacks
  - Resource exhaustion
  - Input validation

- [ ] Run `cargo audit` for dependency vulnerabilities
- [ ] Address any findings

### Deliverables
- ✅ >80% test coverage
- ✅ Comprehensive integration test suite
- ✅ Performance benchmarks
- ✅ All clippy warnings resolved
- ✅ Security review completed
- ✅ Refactored and optimized code

### Acceptance Criteria
- All tests pass on all platforms
- Test coverage meets targets
- No clippy warnings
- Performance targets met
- Security issues addressed
- Code is well-documented
- No known critical bugs

### Time Estimate: 16 hours

---

## Stage 7: Documentation and Release

**Duration:** 1.5 days
**Dependencies:** Stage 6
**Status:** Release Preparation

### Objectives
- Create comprehensive user documentation
- Write developer documentation
- Prepare release artifacts
- Set up package distribution
- Create release announcement

### Tasks

#### 7.1 User Documentation - README
File: `README.md`

- [ ] Write comprehensive README:
  ```markdown
  # jrnrvw - Journal Review Tool

  ## Overview
  Brief description and key features

  ## Installation
  - From source
  - From crates.io
  - Binary releases
  - Package managers

  ## Quick Start
  Basic usage examples

  ## Usage
  Detailed command-line options

  ## Configuration
  Config file documentation

  ## Examples
  Common use cases

  ## Contributing
  How to contribute

  ## License
  ```

- [ ] Add badges (build status, crates.io version, license)
- [ ] Add screenshots/examples of output
- [ ] Include troubleshooting section

#### 7.2 User Documentation - User Guide
File: `docs/user-guide.md`

- [ ] Write detailed user guide:
  - Installation instructions
  - Getting started tutorial
  - Command reference
  - Configuration guide
  - Advanced usage
  - FAQ
  - Troubleshooting

- [ ] Add practical examples
- [ ] Include best practices
- [ ] Document common pitfalls

#### 7.3 Developer Documentation
File: `docs/developer-guide.md`

- [ ] Write developer documentation:
  - Architecture overview
  - Module descriptions
  - Data flow diagrams
  - Building from source
  - Running tests
  - Contributing guidelines
  - Code style guide
  - Release process

- [ ] Document all public APIs with rustdoc:
  ```rust
  /// Discovers journal files in the given directory tree.
  ///
  /// # Arguments
  ///
  /// * `root` - The root directory to search
  /// * `excludes` - List of directory names to exclude
  ///
  /// # Examples
  ///
  /// ```
  /// use jrnrvw::discover_journals;
  /// let entries = discover_journals(Path::new("."), vec![]).unwrap();
  /// ```
  ///
  /// # Errors
  ///
  /// Returns an error if the directory cannot be accessed or if
  /// there are permission issues.
  pub fn discover_journals(
      root: &Path,
      excludes: Vec<String>
  ) -> Result<Vec<JournalEntry>> { ... }
  ```

- [ ] Generate rustdoc: `cargo doc --no-deps --open`
- [ ] Review and enhance generated docs

#### 7.4 Examples and Tutorials
File: `examples/`

- [ ] Create runnable examples:
  - `examples/basic_usage.rs` - Simple usage
  - `examples/custom_filter.rs` - Advanced filtering
  - `examples/library_usage.rs` - Using as a library
  - `examples/custom_formatter.rs` - Extending with custom formatter

- [ ] Document each example
- [ ] Ensure examples compile and run

#### 7.5 CHANGELOG
File: `CHANGELOG.md`

- [ ] Create changelog following Keep a Changelog format:
  ```markdown
  # Changelog

  ## [1.0.0] - 2025-11-XX

  ### Added
  - Initial release
  - Journal file discovery
  - Multiple output formats (text, markdown, JSON, HTML, CSV)
  - Time range filtering
  - Repository and task grouping
  - Configuration file support
  - Comprehensive CLI

  ### Fixed
  - N/A (initial release)

  ### Changed
  - N/A (initial release)
  ```

#### 7.6 License and Legal
- [ ] Choose license (MIT or Apache-2.0 or dual)
- [ ] Add LICENSE file
- [ ] Add copyright headers to source files
- [ ] Add NOTICE file if using Apache license
- [ ] Review dependencies for license compatibility

#### 7.7 Release Preparation
File: `Cargo.toml`

- [ ] Update version to 1.0.0
- [ ] Set package metadata:
  ```toml
  [package]
  name = "jrnrvw"
  version = "1.0.0"
  authors = ["Your Name <email@example.com>"]
  edition = "2021"
  description = "A command-line tool for finding and analyzing task journal files"
  readme = "README.md"
  homepage = "https://github.com/yourusername/jrnrvw"
  repository = "https://github.com/yourusername/jrnrvw"
  license = "MIT OR Apache-2.0"
  keywords = ["journal", "task-tracking", "productivity", "cli"]
  categories = ["command-line-utilities", "development-tools"]
  ```

- [ ] Verify all fields are correct
- [ ] Test `cargo publish --dry-run`

#### 7.8 Binary Releases
File: `.github/workflows/release.yml`

- [ ] Set up GitHub Actions for releases:
  - Build for Linux (x86_64, ARM64)
  - Build for macOS (Intel, Apple Silicon)
  - Build for Windows (x86_64)
  - Create release archives
  - Upload to GitHub Releases

- [ ] Test release process
- [ ] Create initial release (v1.0.0)

#### 7.9 Package Distribution
- [ ] Publish to crates.io:
  ```bash
  cargo publish
  ```

- [ ] Create Homebrew formula (macOS):
  ```ruby
  class Jrnrvw < Formula
    desc "Journal Review Tool - Analyze task journal files"
    homepage "https://github.com/yourusername/jrnrvw"
    url "https://github.com/yourusername/jrnrvw/archive/v1.0.0.tar.gz"
    sha256 "..."

    def install
      system "cargo", "install", *std_cargo_args
    end
  end
  ```

- [ ] Create AUR package (Arch Linux)
- [ ] Consider Debian packaging
- [ ] Consider Chocolatey (Windows)

#### 7.10 Release Announcement
- [ ] Write release announcement
- [ ] Prepare social media posts
- [ ] Submit to relevant communities (Reddit, Hacker News, etc.)
- [ ] Update project website (if applicable)

### Deliverables
- ✅ Complete user documentation
- ✅ Complete developer documentation
- ✅ Runnable examples
- ✅ CHANGELOG
- ✅ License files
- ✅ Published to crates.io
- ✅ Binary releases
- ✅ Release announcement

### Acceptance Criteria
- Documentation is clear and comprehensive
- All examples run correctly
- Package is published to crates.io
- Binaries are available for download
- License is properly applied
- Release announcement is ready

### Time Estimate: 12 hours

---

## Risk Management

### Technical Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Markdown parsing complexity varies | Medium | Medium | Use battle-tested `pulldown-cmark`, handle variations gracefully |
| Performance issues with large trees | Low | High | Implement early filtering, benchmark regularly |
| Cross-platform path handling | Medium | Medium | Use `std::path::PathBuf`, test on all platforms |
| Regex performance (ReDoS) | Low | Medium | Use simple patterns, test with large inputs |
| Date parsing edge cases | Medium | Low | Use `chrono`, comprehensive test cases |

### Schedule Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Scope creep | Medium | High | Stick to spec, defer enhancements to future versions |
| Testing takes longer than expected | Medium | Medium | Start testing early, integrate continuously |
| Dependencies have breaking changes | Low | Medium | Pin dependency versions |
| Documentation delayed | Low | Low | Document as you code, not at the end |

### Quality Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Insufficient test coverage | Low | High | Set coverage targets, enforce in CI |
| Bugs in production | Medium | Medium | Thorough testing, beta release period |
| Poor UX | Medium | Medium | Get early feedback, usability testing |
| Performance regressions | Low | Medium | Benchmark suite, performance tests |

---

## Resource Requirements

### Development Environment
- Rust toolchain (stable, latest)
- IDE/Editor (VS Code with rust-analyzer recommended)
- Git
- Testing tools (cargo-tarpaulin, cargo-llvm-cov)
- Platform access (Linux, macOS, Windows)

### Dependencies
All dependencies are open-source and freely available via crates.io.

### Testing Resources
- Test fixtures (to be created)
- Multiple operating systems for cross-platform testing
- CI/CD service (GitHub Actions - free for public repos)

### Time Resources
- Total estimated time: 4-5 weeks
- Assumes 1 full-time developer
- Can be parallelized with multiple developers:
  - Developer 1: Stages 1-3 (core functionality)
  - Developer 2: Stage 4 (output formatters)
  - Both: Stages 5-7 (polish and release)

---

## Success Metrics

### Code Quality Metrics
- [ ] >80% test coverage
- [ ] Zero clippy warnings (with default settings)
- [ ] All tests pass on all platforms
- [ ] <100ms startup time
- [ ] <1s processing time for 1000 journals

### Functionality Metrics
- [ ] All specified features implemented
- [ ] All output formats working
- [ ] All CLI options functional
- [ ] Configuration file support complete

### Documentation Metrics
- [ ] README with quick start guide
- [ ] User guide covering all features
- [ ] Developer documentation
- [ ] All public APIs documented
- [ ] >5 runnable examples

### Release Metrics
- [ ] Published to crates.io
- [ ] Binary releases for 3+ platforms
- [ ] >10 GitHub stars in first week (if public)
- [ ] Zero critical bugs in first release

---

## Post-Release Plan

### Version 1.1 (4-6 weeks after 1.0)
- Address user feedback
- Fix reported bugs
- Minor feature enhancements
- Performance optimizations

### Version 1.5 (3 months after 1.0)
- Interactive TUI mode
- Git integration (correlate with commits)
- Enhanced statistics and visualizations

### Version 2.0 (6 months after 1.0)
- Multi-user support
- Web dashboard
- Plugin system
- Advanced analytics

---

## Appendix A: Task Checklist

### Pre-Development
- [ ] Review specification
- [ ] Set up development environment
- [ ] Create project repository
- [ ] Plan sprint schedule

### Development Stages
- [ ] Stage 0: Project Setup
- [ ] Stage 1: Core Data Models
- [ ] Stage 2: Discovery and Parsing
- [ ] Stage 3: Analysis and Filtering
- [ ] Stage 4: Output and CLI
- [ ] Stage 5: Advanced Features
- [ ] Stage 6: Testing and QA
- [ ] Stage 7: Documentation and Release

### Post-Development
- [ ] Beta testing period
- [ ] Address beta feedback
- [ ] Final release
- [ ] Announce release
- [ ] Monitor for issues

---

## Appendix B: Milestones

| Milestone | Target Date | Deliverable |
|-----------|-------------|-------------|
| Project Setup Complete | Day 1 | Compiling Rust project |
| Core Models Complete | Day 2-3 | All data structures implemented |
| MVP (Basic CLI) | Week 2 | Working discovery, parsing, text output |
| Feature Complete | Week 3 | All output formats, all CLI options |
| Beta Release | Week 4 | Tested, documented, ready for feedback |
| 1.0 Release | Week 5 | Published, distributed, announced |

---

## Appendix C: Testing Matrix

| Feature | Unit Tests | Integration Tests | Manual Tests |
|---------|-----------|-------------------|--------------|
| File Discovery | ✓ | ✓ | ✓ |
| Date Parsing | ✓ | ✓ | - |
| Markdown Parsing | ✓ | ✓ | ✓ |
| Time Filtering | ✓ | ✓ | ✓ |
| Grouping | ✓ | ✓ | ✓ |
| Text Output | ✓ | ✓ | ✓ |
| Markdown Output | ✓ | ✓ | ✓ |
| JSON Output | ✓ | ✓ | - |
| HTML Output | ✓ | ✓ | ✓ |
| CSV Output | ✓ | ✓ | ✓ |
| CLI Parsing | ✓ | ✓ | ✓ |
| Config Loading | ✓ | ✓ | ✓ |

---

**Document Status:** Final
**Approved By:** Development Team
**Implementation Start Date:** TBD
**Target Completion:** 4-5 weeks from start
