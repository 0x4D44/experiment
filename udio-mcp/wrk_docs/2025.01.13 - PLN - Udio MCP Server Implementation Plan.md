# Multistage Implementation Plan: Udio MCP Server

**Document Version:** 1.0
**Date:** 2025-01-13
**Author:** Claude Code
**Status:** Implementation Plan
**Related:** 2025.01.13 - HLD - Udio Music MCP Server.md

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Project Setup](#project-setup)
3. [Stage 1: Foundation and MCP Protocol](#stage-1-foundation-and-mcp-protocol)
4. [Stage 2: Browser Automation Framework](#stage-2-browser-automation-framework)
5. [Stage 3: Authentication System](#stage-3-authentication-system)
6. [Stage 4: Playlist Operations](#stage-4-playlist-operations)
7. [Stage 5: Playback Control](#stage-5-playback-control)
8. [Stage 6: Resources and Prompts](#stage-6-resources-and-prompts)
9. [Stage 7: Testing and Quality Assurance](#stage-7-testing-and-quality-assurance)
10. [Stage 8: Polish and Documentation](#stage-8-polish-and-documentation)
11. [Stage 9: Deployment and Release](#stage-9-deployment-and-release)
12. [Risk Management](#risk-management)
13. [Success Metrics](#success-metrics)
14. [Resource Requirements](#resource-requirements)

---

## Executive Summary

This implementation plan outlines a 12-week development schedule for building the Udio MCP Server in Rust. The plan follows a phased approach with clear deliverables, testing criteria, and checkpoints at each stage.

**Key Objectives:**
- Build a production-ready MCP server for Udio music control
- Implement robust browser automation for playlist and playback management
- Ensure secure credential handling and reliable operation
- Provide comprehensive testing and documentation

**Timeline:** 12 weeks (3 months)
**Development Methodology:** Iterative with weekly milestones
**Primary Language:** Rust
**Team Size:** 1-2 developers (scalable to 3-4)

---

## Project Setup

### Prerequisites Installation

**Week 0 - Environment Setup**

#### Tasks:
```bash
# 1. Install Rust toolchain
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup default stable
rustup component add clippy rustfmt

# 2. Install Chrome/Chromium
# macOS
brew install --cask chromium

# Linux
sudo apt-get install chromium-browser

# Windows
# Download from https://www.chromium.org/

# 3. Install development tools
cargo install cargo-watch cargo-nextest cargo-audit

# 4. Install MCP Inspector for testing
npm install -g @modelcontextprotocol/inspector
```

### Project Structure Creation

```bash
# Create project structure
cargo new --bin udio-mcp-server
cd udio-mcp-server

# Create directory structure
mkdir -p {src/{auth,browser,cache,config,mcp,models,playback,playlist,utils},tests/{unit,integration},config,docs,wrk_docs,examples}

# Initialize git repository
git init
git add .
git commit -m "Initial project structure"
```

### Initial Cargo.toml

```toml
[package]
name = "udio-mcp-server"
version = "0.1.0"
edition = "2021"
authors = ["Your Name <your.email@example.com>"]
license = "MIT"
description = "MCP server for Udio music platform interaction"

[dependencies]
# Core async runtime
tokio = { version = "1.35", features = ["full"] }
tokio-stream = "0.1"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Error handling
anyhow = "1.0"
thiserror = "1.0"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }

# Configuration
config = "0.13"
toml = "0.8"

# Async trait
async-trait = "0.1"

# To be added in later stages
# chromiumoxide = "0.5"
# keyring = "2.0"
# sled = "0.34"

[dev-dependencies]
mockito = "1.2"
proptest = "1.4"
criterion = "0.5"
tempfile = "3.8"

[[bench]]
name = "performance"
harness = false
```

---

## Stage 1: Foundation and MCP Protocol

**Duration:** Week 1-2
**Dependencies:** None
**Team:** 1 developer

### Week 1: Core MCP Implementation

#### Day 1-2: Protocol Types and Structures

**Files to Create:**
- `src/mcp/types.rs` - Core MCP type definitions
- `src/mcp/protocol.rs` - Protocol constants and enums
- `src/mcp/error.rs` - MCP-specific error types

**Implementation:**
```rust
// src/mcp/types.rs
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Request {
    pub jsonrpc: String,
    pub id: RequestId,
    pub method: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub params: Option<Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequestId {
    String(String),
    Number(i64),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
    pub jsonrpc: String,
    pub id: RequestId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorObject>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Notification {
    pub jsonrpc: String,
    pub method: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub params: Option<Value>,
}
```

**Tests to Write:**
```rust
// tests/unit/mcp_types_test.rs
#[test]
fn test_request_serialization() {
    let request = Request {
        jsonrpc: "2.0".to_string(),
        id: RequestId::Number(1),
        method: "initialize".to_string(),
        params: Some(json!({"version": "1.0"})),
    };

    let json = serde_json::to_string(&request).unwrap();
    assert!(json.contains("\"jsonrpc\":\"2.0\""));
}
```

#### Day 3-4: Transport Layer

**Files to Create:**
- `src/mcp/transport/mod.rs` - Transport trait
- `src/mcp/transport/stdio.rs` - Stdio implementation
- `src/mcp/transport/message_handler.rs` - Message processing

**Implementation:**
```rust
// src/mcp/transport/mod.rs
use async_trait::async_trait;
use anyhow::Result;

#[async_trait]
pub trait Transport: Send + Sync {
    async fn start(&mut self) -> Result<()>;
    async fn send(&self, message: &str) -> Result<()>;
    async fn receive(&mut self) -> Result<Option<String>>;
    async fn close(&mut self) -> Result<()>;
}
```

#### Day 5: Server Core

**Files to Create:**
- `src/mcp/server.rs` - Main server implementation
- `src/mcp/handlers.rs` - Request handlers

**Deliverables:**
- Basic MCP server that can initialize
- Stdio transport working
- Can respond to `initialize` request
- Proper JSON-RPC message handling

**Testing Checklist:**
- [ ] Server starts without errors
- [ ] Responds to ping requests
- [ ] Handles malformed JSON gracefully
- [ ] Passes MCP Inspector basic tests

### Week 2: Capability Registration and Tool Framework

#### Day 1-2: Capability System

**Files to Create:**
- `src/mcp/capabilities.rs` - Capability definitions
- `src/mcp/registry.rs` - Tool/Resource registry

**Implementation:**
```rust
// src/mcp/capabilities.rs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerCapabilities {
    pub tools: Option<ToolCapabilities>,
    pub resources: Option<ResourceCapabilities>,
    pub prompts: Option<PromptCapabilities>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolCapabilities {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub list_changed: Option<bool>,
}
```

#### Day 3-4: Tool Registration Framework

**Files to Create:**
- `src/mcp/tools/mod.rs` - Tool trait and registry
- `src/mcp/tools/metadata.rs` - Tool metadata

**Implementation:**
```rust
// src/mcp/tools/mod.rs
use async_trait::async_trait;
use serde_json::{json, Value};

#[async_trait]
pub trait Tool: Send + Sync {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn input_schema(&self) -> Value;
    async fn execute(&self, params: Value) -> Result<Value>;
}

pub struct ToolRegistry {
    tools: HashMap<String, Box<dyn Tool>>,
}
```

#### Day 5: Integration and Testing

**Testing with MCP Inspector:**
```bash
# Start server with inspector
npx @modelcontextprotocol/inspector cargo run

# Verify:
# 1. Server initializes
# 2. Capabilities are reported correctly
# 3. Tool list is returned (even if empty)
```

**Milestone Deliverables:**
- [ ] Complete MCP protocol implementation
- [ ] Tool registration framework
- [ ] Resource registration framework
- [ ] Passes MCP Inspector validation
- [ ] Unit tests for all protocol components

---

## Stage 2: Browser Automation Framework

**Duration:** Week 3-4
**Dependencies:** Stage 1 complete
**Team:** 1-2 developers

### Week 3: Browser Integration

#### Day 1-2: Add Browser Dependencies

**Update Cargo.toml:**
```toml
[dependencies]
# Browser automation
chromiumoxide = { version = "0.5", features = ["tokio-runtime"] }
# Alternative: fantoccini = "0.20"

# Additional utilities
futures = "0.3"
url = "2.5"
```

**Files to Create:**
- `src/browser/mod.rs` - Browser module
- `src/browser/manager.rs` - Browser lifecycle
- `src/browser/config.rs` - Browser configuration

#### Day 3-4: Browser Manager Implementation

**Implementation:**
```rust
// src/browser/manager.rs
use chromiumoxide::{Browser, BrowserConfig};
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct BrowserManager {
    browser: Arc<RwLock<Option<Browser>>>,
    config: BrowserConfig,
}

impl BrowserManager {
    pub async fn new() -> Result<Self> {
        let config = BrowserConfig::builder()
            .window_size(1920, 1080)
            .build()?;

        Ok(Self {
            browser: Arc::new(RwLock::new(None)),
            config,
        })
    }

    pub async fn get_or_launch(&self) -> Result<Browser> {
        let mut browser_lock = self.browser.write().await;

        if browser_lock.is_none() {
            let (browser, mut handler) = Browser::launch(self.config.clone()).await?;

            tokio::spawn(async move {
                while let Some(_) = handler.next().await {
                    // Handle browser events
                }
            });

            *browser_lock = Some(browser);
        }

        Ok(browser_lock.clone().unwrap())
    }
}
```

#### Day 5: Testing Browser Launch

**Test Script:**
```rust
// tests/integration/browser_test.rs
#[tokio::test]
async fn test_browser_launch_and_navigate() {
    let manager = BrowserManager::new().await.unwrap();
    let browser = manager.get_or_launch().await.unwrap();
    let page = browser.new_page("https://example.com").await.unwrap();

    let title = page.title().await.unwrap();
    assert!(title.contains("Example"));
}
```

### Week 4: Page Automation and Selectors

#### Day 1-2: Selector Configuration

**Files to Create:**
- `src/browser/selectors.rs` - Selector management
- `config/selectors.toml` - Default selectors

**Implementation:**
```rust
// src/browser/selectors.rs
use serde::Deserialize;
use config::Config;

#[derive(Debug, Clone, Deserialize)]
pub struct Selectors {
    pub playlist: PlaylistSelectors,
    pub song: SongSelectors,
    pub player: PlayerSelectors,
    pub auth: AuthSelectors,
}

impl Selectors {
    pub fn load() -> Result<Self> {
        let config = Config::builder()
            .add_source(config::File::with_name("config/selectors"))
            .build()?;

        config.try_deserialize()
    }
}
```

#### Day 3-4: Page Automation Utilities

**Files to Create:**
- `src/browser/automation.rs` - Page automation helpers
- `src/browser/extractor.rs` - Data extraction

**Implementation:**
```rust
// src/browser/automation.rs
use chromiumoxide::Page;
use std::time::Duration;

pub struct PageAutomation {
    page: Page,
    selectors: Selectors,
}

impl PageAutomation {
    pub async fn wait_for_selector(&self, selector: &str) -> Result<()> {
        let deadline = tokio::time::Instant::now() + Duration::from_secs(30);

        loop {
            if self.page.find_element(selector).await?.is_some() {
                return Ok(());
            }

            if tokio::time::Instant::now() > deadline {
                return Err(anyhow!("Timeout waiting for selector: {}", selector));
            }

            tokio::time::sleep(Duration::from_millis(100)).await;
        }
    }

    pub async fn click(&self, selector: &str) -> Result<()> {
        self.wait_for_selector(selector).await?;
        self.page.find_element(selector).await?.unwrap().click().await?;
        Ok(())
    }
}
```

#### Day 5: Integration Testing

**Testing Checklist:**
- [ ] Browser launches successfully
- [ ] Can navigate to URLs
- [ ] Can wait for elements
- [ ] Can click elements
- [ ] Can extract text
- [ ] Handles timeouts properly

**Milestone Deliverables:**
- [ ] Browser manager implementation
- [ ] Selector configuration system
- [ ] Page automation utilities
- [ ] Data extraction framework
- [ ] Integration tests for browser operations

---

## Stage 3: Authentication System

**Duration:** Week 5
**Dependencies:** Stage 2 complete
**Team:** 1 developer

### Day 1-2: Credential Storage

**Add Dependencies:**
```toml
[dependencies]
keyring = "2.0"  # OS keychain integration
ring = "0.17"    # Encryption
base64 = "0.21"
```

**Files to Create:**
- `src/auth/mod.rs` - Auth module
- `src/auth/credentials.rs` - Credential management
- `src/auth/keychain.rs` - OS keychain integration

**Implementation:**
```rust
// src/auth/keychain.rs
use keyring::Entry;
use anyhow::Result;

pub struct KeychainManager {
    service_name: String,
}

impl KeychainManager {
    pub fn new(service_name: impl Into<String>) -> Self {
        Self {
            service_name: service_name.into(),
        }
    }

    pub fn store_password(&self, username: &str, password: &str) -> Result<()> {
        let entry = Entry::new(&self.service_name, username)?;
        entry.set_password(password)?;
        tracing::info!("Password stored securely for user: {}", username);
        Ok(())
    }

    pub fn get_password(&self, username: &str) -> Result<String> {
        let entry = Entry::new(&self.service_name, username)?;
        Ok(entry.get_password()?)
    }

    pub fn delete_password(&self, username: &str) -> Result<()> {
        let entry = Entry::new(&self.service_name, username)?;
        entry.delete_password()?;
        Ok(())
    }
}
```

### Day 3-4: Login Automation

**Files to Create:**
- `src/auth/login.rs` - Login flow implementation
- `src/auth/session.rs` - Session management

**Implementation:**
```rust
// src/auth/login.rs
use crate::browser::PageAutomation;

pub struct LoginAutomation {
    page_automation: PageAutomation,
    selectors: AuthSelectors,
}

impl LoginAutomation {
    pub async fn login(&self, email: &str, password: &str) -> Result<Session> {
        // Navigate to login page
        self.page_automation.navigate("https://www.udio.com/login").await?;

        // Fill email
        self.page_automation.wait_for_selector(&self.selectors.email_input).await?;
        self.page_automation.fill(&self.selectors.email_input, email).await?;

        // Fill password
        self.page_automation.fill(&self.selectors.password_input, password).await?;

        // Click submit
        self.page_automation.click(&self.selectors.submit_button).await?;

        // Wait for redirect/success
        self.wait_for_login_success().await?;

        // Extract session
        let cookies = self.page_automation.get_cookies().await?;

        Ok(Session {
            cookies,
            expires_at: Utc::now() + Duration::hours(24),
        })
    }
}
```

### Day 5: Session Persistence

**Files to Create:**
- `src/auth/storage.rs` - Session storage

**Testing Checklist:**
- [ ] Can store credentials securely
- [ ] Can retrieve credentials
- [ ] Login automation works
- [ ] Session persists across restarts
- [ ] Handles invalid credentials
- [ ] Re-authentication on expiry

**Milestone Deliverables:**
- [ ] Secure credential storage
- [ ] Login automation
- [ ] Session management
- [ ] Public playlist support (no auth)
- [ ] Unit tests for auth components

---

## Stage 4: Playlist Operations

**Duration:** Week 6-7
**Dependencies:** Stage 3 complete
**Team:** 1-2 developers

### Week 6: Playlist Data Extraction

#### Day 1-2: Playlist Manager

**Files to Create:**
- `src/playlist/mod.rs` - Playlist module
- `src/playlist/manager.rs` - Playlist management
- `src/models/playlist.rs` - Data models

**Implementation:**
```rust
// src/models/playlist.rs
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Playlist {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub song_count: usize,
    pub total_duration_seconds: u64,
    pub is_public: bool,
    pub songs: Vec<Song>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Song {
    pub id: String,
    pub title: String,
    pub artist: Option<String>,
    pub duration_seconds: u64,
    pub url: String,
    pub tags: Vec<String>,
    pub created_at: DateTime<Utc>,
}
```

#### Day 3-4: Data Extraction

**Files to Create:**
- `src/playlist/extractor.rs` - DOM extraction logic

**Implementation:**
```rust
// src/playlist/extractor.rs
pub async fn extract_playlist_songs(page: &Page) -> Result<Vec<Song>> {
    let script = r#"
        Array.from(document.querySelectorAll('.song-item')).map(item => ({
            id: item.dataset.songId,
            title: item.querySelector('.song-title')?.textContent?.trim(),
            artist: item.querySelector('.song-artist')?.textContent?.trim(),
            duration: item.dataset.duration,
            tags: Array.from(item.querySelectorAll('.tag')).map(t => t.textContent)
        }))
    "#;

    let result = page.evaluate(script).await?;
    let songs: Vec<Song> = serde_json::from_value(result)?;
    Ok(songs)
}
```

#### Day 5: Tool Implementation

**Files to Create:**
- `src/mcp/tools/list_playlist_songs.rs` - Tool implementation

**Implementation:**
```rust
// src/mcp/tools/list_playlist_songs.rs
pub struct ListPlaylistSongsTool {
    playlist_manager: Arc<PlaylistManager>,
}

#[async_trait]
impl Tool for ListPlaylistSongsTool {
    fn name(&self) -> &str {
        "list_playlist_songs"
    }

    fn description(&self) -> &str {
        "List all songs in a specific playlist"
    }

    fn input_schema(&self) -> Value {
        json!({
            "type": "object",
            "properties": {
                "playlist_name": {
                    "type": "string",
                    "default": "ToPlay"
                },
                "limit": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 100,
                    "default": 50
                }
            }
        })
    }

    async fn execute(&self, params: Value) -> Result<Value> {
        let playlist_name = params["playlist_name"].as_str().unwrap_or("ToPlay");
        let limit = params["limit"].as_u64().unwrap_or(50) as usize;

        let playlist = self.playlist_manager.get_playlist(playlist_name).await?;
        let songs: Vec<_> = playlist.songs.into_iter().take(limit).collect();

        Ok(json!({
            "playlist": {
                "name": playlist.name,
                "song_count": playlist.song_count
            },
            "songs": songs
        }))
    }
}
```

### Week 7: Cache Implementation

#### Day 1-2: Cache Infrastructure

**Add Dependencies:**
```toml
[dependencies]
sled = "0.34"  # Embedded database
bincode = "1.3"  # Binary serialization
```

**Files to Create:**
- `src/cache/mod.rs` - Cache module
- `src/cache/manager.rs` - Cache management

**Implementation:**
```rust
// src/cache/manager.rs
use sled::Db;
use serde::{Serialize, de::DeserializeOwned};
use std::time::{Duration, Instant};

pub struct CacheManager {
    db: Db,
    default_ttl: Duration,
}

impl CacheManager {
    pub async fn get<T: DeserializeOwned>(&self, key: &str) -> Result<Option<T>> {
        if let Some(data) = self.db.get(key)? {
            let entry: CacheEntry<T> = bincode::deserialize(&data)?;

            if entry.is_valid() {
                return Ok(Some(entry.data));
            }
        }
        Ok(None)
    }

    pub async fn set<T: Serialize>(&self, key: &str, value: &T, ttl: Option<Duration>) -> Result<()> {
        let entry = CacheEntry {
            data: value,
            expires_at: Instant::now() + ttl.unwrap_or(self.default_ttl),
        };

        let data = bincode::serialize(&entry)?;
        self.db.insert(key, data)?;
        Ok(())
    }
}
```

#### Day 3-4: Integration with Playlist Manager

**Update playlist manager to use cache:**
```rust
pub async fn get_playlist_with_cache(&self, name: &str) -> Result<Playlist> {
    let cache_key = format!("playlist:{}", name);

    // Check cache first
    if let Some(playlist) = self.cache.get::<Playlist>(&cache_key).await? {
        tracing::debug!("Returning cached playlist: {}", name);
        return Ok(playlist);
    }

    // Fetch fresh data
    let playlist = self.fetch_playlist(name).await?;

    // Update cache
    self.cache.set(&cache_key, &playlist, Some(Duration::from_secs(3600))).await?;

    Ok(playlist)
}
```

#### Day 5: Testing and Optimization

**Testing Checklist:**
- [ ] Can list playlists
- [ ] Can list songs in playlist
- [ ] Cache reduces browser calls
- [ ] Handles missing playlists
- [ ] Pagination works correctly

**Milestone Deliverables:**
- [ ] Playlist extraction working
- [ ] Song extraction working
- [ ] Cache implementation
- [ ] list_playlist_songs tool
- [ ] list_all_playlists tool
- [ ] search_playlist_songs tool

---

## Stage 5: Playback Control

**Duration:** Week 8
**Dependencies:** Stage 4 complete
**Team:** 1 developer

### Day 1-2: Playback Controller

**Files to Create:**
- `src/playback/mod.rs` - Playback module
- `src/playback/controller.rs` - Playback control
- `src/models/playback.rs` - Playback models

**Implementation:**
```rust
// src/playback/controller.rs
use crate::browser::PageAutomation;
use crate::models::playback::{PlaybackState, PlaybackStatus};

pub struct PlaybackController {
    page_automation: Arc<PageAutomation>,
    selectors: PlayerSelectors,
}

impl PlaybackController {
    pub async fn play_song(&self, song_id: &str) -> Result<PlaybackState> {
        // Find and click the song's play button
        let selector = format!("[data-song-id='{}'] .play-button", song_id);
        self.page_automation.click(&selector).await?;

        // Wait for playback to start
        tokio::time::sleep(Duration::from_millis(500)).await;

        // Get playback state
        self.get_current_state().await
    }

    pub async fn pause(&self) -> Result<()> {
        self.page_automation.click(&self.selectors.pause_button).await
    }

    pub async fn resume(&self) -> Result<()> {
        self.page_automation.click(&self.selectors.play_button).await
    }

    pub async fn get_current_state(&self) -> Result<PlaybackState> {
        let script = r#"
            (() => {
                const player = document.querySelector('.player-bar');
                if (!player) return null;

                return {
                    isPlaying: player.classList.contains('playing'),
                    currentTime: parseFloat(player.dataset.currentTime || 0),
                    duration: parseFloat(player.dataset.duration || 0),
                    volume: parseInt(player.dataset.volume || 100),
                    songTitle: player.querySelector('.current-song-title')?.textContent
                };
            })()
        "#;

        let result = self.page_automation.evaluate(script).await?;
        // Parse result into PlaybackState
        Ok(parse_playback_state(result)?)
    }
}
```

### Day 3-4: Playback Tools

**Files to Create:**
- `src/mcp/tools/play_song.rs` - Play song tool
- `src/mcp/tools/control_playback.rs` - Control tool
- `src/mcp/tools/get_playback_status.rs` - Status tool

**Implementation:**
```rust
// src/mcp/tools/play_song.rs
pub struct PlaySongTool {
    playback_controller: Arc<PlaybackController>,
}

#[async_trait]
impl Tool for PlaySongTool {
    fn name(&self) -> &str {
        "play_song"
    }

    async fn execute(&self, params: Value) -> Result<Value> {
        let song_id = params["song_id"]
            .as_str()
            .ok_or_else(|| anyhow!("song_id is required"))?;

        let state = self.playback_controller.play_song(song_id).await?;

        Ok(json!({
            "status": "playing",
            "song": {
                "id": song_id,
                "current_time_seconds": state.position_seconds,
                "duration_seconds": state.duration_seconds
            }
        }))
    }
}
```

### Day 5: State Monitoring

**Implementation of state monitoring:**
```rust
// Periodic state updates
pub async fn monitor_playback_state(controller: Arc<PlaybackController>) {
    let mut interval = tokio::time::interval(Duration::from_secs(1));

    loop {
        interval.tick().await;

        match controller.get_current_state().await {
            Ok(state) => {
                // Update cached state
                // Send notifications if subscribed
            }
            Err(e) => {
                tracing::warn!("Failed to get playback state: {}", e);
            }
        }
    }
}
```

**Testing Checklist:**
- [ ] Can play specific song
- [ ] Can pause playback
- [ ] Can resume playback
- [ ] Can stop playback
- [ ] State monitoring works
- [ ] Handles playback errors

**Milestone Deliverables:**
- [ ] Playback controller implementation
- [ ] play_song tool
- [ ] control_playback tool
- [ ] get_playback_status tool
- [ ] State monitoring system

---

## Stage 6: Resources and Prompts

**Duration:** Week 9
**Dependencies:** Stage 5 complete
**Team:** 1 developer

### Day 1-2: Resource Implementation

**Files to Create:**
- `src/mcp/resources/mod.rs` - Resource module
- `src/mcp/resources/playlist_resource.rs` - Playlist resource
- `src/mcp/resources/playback_resource.rs` - Playback resource

**Implementation:**
```rust
// src/mcp/resources/playlist_resource.rs
use async_trait::async_trait;

pub struct PlaylistResource {
    playlist_manager: Arc<PlaylistManager>,
}

#[async_trait]
impl Resource for PlaylistResource {
    fn uri_pattern(&self) -> &str {
        "udio://playlist/{name}"
    }

    async fn read(&self, uri: &str) -> Result<ResourceContent> {
        let name = extract_playlist_name(uri)?;
        let playlist = self.playlist_manager.get_playlist(&name).await?;

        Ok(ResourceContent {
            uri: uri.to_string(),
            mime_type: "application/json".to_string(),
            text: serde_json::to_string_pretty(&playlist)?,
        })
    }

    fn supports_subscription(&self) -> bool {
        true
    }
}
```

### Day 3-4: Prompt Implementation

**Files to Create:**
- `src/mcp/prompts/mod.rs` - Prompt module
- `src/mcp/prompts/music_assistant.rs` - Assistant prompt

**Implementation:**
```rust
// src/mcp/prompts/music_assistant.rs
pub struct MusicAssistantPrompt;

impl Prompt for MusicAssistantPrompt {
    fn name(&self) -> &str {
        "music_playback_assistant"
    }

    fn description(&self) -> &str {
        "Guide for interacting with Udio playlists"
    }

    fn arguments(&self) -> Vec<PromptArgument> {
        vec![
            PromptArgument {
                name: "playlist_name".to_string(),
                description: "Playlist to focus on".to_string(),
                required: false,
            }
        ]
    }

    fn generate(&self, args: &HashMap<String, String>) -> String {
        let playlist = args.get("playlist_name").unwrap_or(&"ToPlay".to_string());

        format!(
            "I can help you interact with your Udio music collection. \
             I have access to your playlists (especially '{}'). \
             What would you like to do?",
            playlist
        )
    }
}
```

### Day 5: Integration

**Testing Checklist:**
- [ ] Resources accessible via MCP
- [ ] Resource subscription works
- [ ] Prompts return expected templates
- [ ] All MCP primitives integrated

**Milestone Deliverables:**
- [ ] Playlist resource
- [ ] Song resource
- [ ] Playback state resource
- [ ] Music assistant prompt
- [ ] Playlist explorer prompt

---

## Stage 7: Testing and Quality Assurance

**Duration:** Week 10
**Dependencies:** Stage 6 complete
**Team:** 1-2 developers

### Day 1-2: Unit Tests

**Test Coverage Goals:**
- Protocol handlers: 90%
- Browser automation: 80%
- Business logic: 85%
- Cache: 90%
- Auth: 85%

**Example Unit Tests:**
```rust
// tests/unit/playlist_manager_test.rs
#[cfg(test)]
mod tests {
    use super::*;
    use mockito::mock;

    #[tokio::test]
    async fn test_get_playlist_success() {
        let _m = mock("GET", "/playlist/ToPlay")
            .with_status(200)
            .with_body(r#"{"name": "ToPlay", "songs": []}"#)
            .create();

        let manager = PlaylistManager::new();
        let playlist = manager.get_playlist("ToPlay").await.unwrap();

        assert_eq!(playlist.name, "ToPlay");
    }

    #[tokio::test]
    async fn test_cache_hit() {
        let cache = MockCache::new();
        cache.set("playlist:ToPlay", test_playlist()).await;

        let manager = PlaylistManager::with_cache(cache);
        let playlist = manager.get_playlist("ToPlay").await.unwrap();

        assert_eq!(playlist.name, "ToPlay");
        assert_eq!(cache.hit_count(), 1);
    }
}
```

### Day 3-4: Integration Tests

**Integration Test Suite:**
```rust
// tests/integration/full_workflow_test.rs
#[tokio::test]
#[ignore] // Run with --ignored flag
async fn test_complete_workflow() {
    // 1. Initialize server
    let server = create_test_server().await;

    // 2. Authenticate (or use test account)
    server.authenticate(test_credentials()).await.unwrap();

    // 3. List playlists
    let playlists = server.list_playlists().await.unwrap();
    assert!(!playlists.is_empty());

    // 4. Get songs from first playlist
    let songs = server.list_songs(&playlists[0].name).await.unwrap();
    assert!(!songs.is_empty());

    // 5. Play first song
    let state = server.play_song(&songs[0].id).await.unwrap();
    assert_eq!(state.status, PlaybackStatus::Playing);

    // 6. Pause playback
    server.pause().await.unwrap();

    // 7. Check state
    let state = server.get_playback_state().await.unwrap();
    assert_eq!(state.status, PlaybackStatus::Paused);
}
```

### Day 5: Performance Testing

**Benchmark Tests:**
```rust
// benches/performance.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_playlist_extraction(c: &mut Criterion) {
    c.bench_function("extract_100_songs", |b| {
        b.iter(|| {
            extract_playlist_songs(black_box(mock_page_with_100_songs()))
        });
    });
}

fn benchmark_cache_operations(c: &mut Criterion) {
    let runtime = tokio::runtime::Runtime::new().unwrap();

    c.bench_function("cache_get", |b| {
        b.to_async(&runtime).iter(|| async {
            cache.get::<Playlist>(black_box("playlist:test")).await
        });
    });
}

criterion_group!(benches, benchmark_playlist_extraction, benchmark_cache_operations);
criterion_main!(benches);
```

**Testing Checklist:**
- [ ] Unit test coverage >80%
- [ ] Integration tests pass
- [ ] Performance benchmarks meet targets
- [ ] MCP Inspector validation passes
- [ ] Error scenarios tested

**Milestone Deliverables:**
- [ ] Complete unit test suite
- [ ] Integration test suite
- [ ] Performance benchmarks
- [ ] Test documentation
- [ ] CI/CD pipeline configuration

---

## Stage 8: Polish and Documentation

**Duration:** Week 11
**Dependencies:** Stage 7 complete
**Team:** 1-2 developers

### Day 1-2: Code Quality

**Tasks:**
```bash
# Run automated fixes
cargo fmt -- --check
cargo clippy -- -D warnings
cargo audit

# Update dependencies
cargo update

# Check for unused dependencies
cargo machete
```

**Code Review Checklist:**
- [ ] All clippy warnings resolved
- [ ] Code formatted with rustfmt
- [ ] No security vulnerabilities (cargo audit)
- [ ] Dependencies up to date
- [ ] Dead code removed
- [ ] TODO comments addressed

### Day 3-4: Documentation

**Documentation to Write:**

**1. README.md:**
```markdown
# Udio MCP Server

MCP server for controlling Udio music playback through AI assistants.

## Features
- List and browse playlists
- Play, pause, and control playback
- Search for songs
- Secure credential management

## Installation
...

## Configuration
...

## Usage
...
```

**2. API Documentation:**
```rust
// Generate with rustdoc
/// Lists all songs in a specified playlist.
///
/// # Arguments
/// * `playlist_name` - Name of the playlist (default: "ToPlay")
/// * `limit` - Maximum number of songs to return
///
/// # Returns
/// A list of songs with metadata
///
/// # Example
/// ```
/// let songs = list_playlist_songs("ToPlay", 50).await?;
/// ```
pub async fn list_playlist_songs(playlist_name: &str, limit: usize) -> Result<Vec<Song>>
```

**3. User Guide:**
- Installation instructions
- Configuration guide
- Common use cases
- Troubleshooting

### Day 5: Examples and Templates

**Create Example Files:**

**examples/basic_usage.rs:**
```rust
use udio_mcp_server::{Server, Config};

#[tokio::main]
async fn main() -> Result<()> {
    // Load configuration
    let config = Config::from_file("config.toml")?;

    // Create and start server
    let server = Server::new(config).await?;
    server.run().await?;

    Ok(())
}
```

**examples/config.toml:**
```toml
[auth]
mode = "credentials"
email = "user@example.com"
use_keychain = true

[browser]
headless = true

[cache]
enabled = true
playlist_ttl = 3600
```

**Milestone Deliverables:**
- [ ] Code quality checks pass
- [ ] README.md complete
- [ ] API documentation
- [ ] User guide
- [ ] Configuration examples
- [ ] Troubleshooting guide

---

## Stage 9: Deployment and Release

**Duration:** Week 12
**Dependencies:** Stage 8 complete
**Team:** 1-2 developers

### Day 1-2: Build and Package

**Build Configurations:**

**Cross-compilation setup:**
```bash
# Install cross-compilation tools
cargo install cross

# Build for multiple platforms
cross build --release --target x86_64-pc-windows-gnu
cross build --release --target x86_64-apple-darwin
cross build --release --target x86_64-unknown-linux-gnu
```

**Create release script:**
```bash
#!/bin/bash
# scripts/build-release.sh

VERSION=$(cargo pkgid | cut -d# -f2)

# Build for all platforms
platforms=(
    "x86_64-unknown-linux-gnu"
    "x86_64-apple-darwin"
    "x86_64-pc-windows-gnu"
)

for platform in "${platforms[@]}"; do
    echo "Building for $platform..."
    cross build --release --target $platform

    # Package with configuration files
    mkdir -p "dist/udio-mcp-server-$VERSION-$platform"
    cp "target/$platform/release/udio-mcp-server" "dist/udio-mcp-server-$VERSION-$platform/"
    cp -r config examples docs "dist/udio-mcp-server-$VERSION-$platform/"

    # Create archive
    tar czf "dist/udio-mcp-server-$VERSION-$platform.tar.gz" "dist/udio-mcp-server-$VERSION-$platform"
done
```

### Day 3-4: Installation Scripts

**Create installers:**

**install.sh (Unix):**
```bash
#!/bin/bash
set -e

INSTALL_DIR="$HOME/.local/bin"
CONFIG_DIR="$HOME/.config/udio-mcp"

# Create directories
mkdir -p "$INSTALL_DIR" "$CONFIG_DIR"

# Copy binary
cp udio-mcp-server "$INSTALL_DIR/"
chmod +x "$INSTALL_DIR/udio-mcp-server"

# Copy configuration
cp -n config/config.toml "$CONFIG_DIR/" || true
cp config/selectors.toml "$CONFIG_DIR/"

echo "Installation complete!"
echo "Add $INSTALL_DIR to your PATH if not already done."
echo "Configure Claude Desktop by adding to claude_desktop_config.json:"
echo '
{
  "mcpServers": {
    "udio": {
      "command": "'$INSTALL_DIR'/udio-mcp-server",
      "args": ["--config", "'$CONFIG_DIR'/config.toml"]
    }
  }
}
'
```

**install.ps1 (Windows):**
```powershell
$InstallDir = "$env:LOCALAPPDATA\UdioMCP"
$ConfigDir = "$env:APPDATA\UdioMCP"

# Create directories
New-Item -ItemType Directory -Force -Path $InstallDir
New-Item -ItemType Directory -Force -Path $ConfigDir

# Copy files
Copy-Item "udio-mcp-server.exe" -Destination $InstallDir
Copy-Item "config\*.toml" -Destination $ConfigDir

Write-Host "Installation complete!"
Write-Host "Configure Claude Desktop with:"
Write-Host @"
{
  "mcpServers": {
    "udio": {
      "command": "$InstallDir\udio-mcp-server.exe",
      "args": ["--config", "$ConfigDir\config.toml"]
    }
  }
}
"@
```

### Day 5: Testing and Release

**Release Checklist:**
- [ ] All tests pass on all platforms
- [ ] Documentation complete
- [ ] Version numbers updated
- [ ] CHANGELOG.md updated
- [ ] Release notes prepared
- [ ] Binaries built for all platforms
- [ ] Installation tested on clean systems

**GitHub Release:**
```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Build releases
        run: ./scripts/build-release.sh

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*.tar.gz
          body_path: RELEASE_NOTES.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

**Milestone Deliverables:**
- [ ] Release binaries for all platforms
- [ ] Installation scripts
- [ ] Deployment documentation
- [ ] GitHub release created
- [ ] User testing complete

---

## Risk Management

### Technical Risks and Mitigation

| Risk | Probability | Impact | Mitigation Strategy |
|------|------------|--------|-------------------|
| Udio UI changes break selectors | High | High | Configurable selectors, version detection, quick updates |
| Browser detection/blocking | Medium | High | Stealth mode, realistic behavior, fallback strategies |
| Authentication complexity | Medium | Medium | Support public playlists, clear error messages |
| Performance issues | Low | Medium | Caching, async operations, resource pooling |
| Cross-platform compatibility | Low | Low | Thorough testing, CI/CD pipeline |

### Contingency Plans

**If Udio UI Changes:**
1. Update selector configuration
2. Push hotfix release
3. Consider implementing auto-selector discovery

**If Browser Automation Blocked:**
1. Implement more realistic user behavior
2. Add random delays and mouse movements
3. Consider alternative browsers

**If Performance Inadequate:**
1. Optimize browser operations
2. Increase cache usage
3. Implement request batching

---

## Success Metrics

### Technical Metrics

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Test Coverage | >80% | cargo tarpaulin |
| Response Time (cached) | <100ms | Performance benchmarks |
| Response Time (fresh) | <3s | Performance benchmarks |
| Memory Usage | <100MB | System monitoring |
| Error Rate | <1% | Log analysis |
| Uptime | >99.9% | Monitoring |

### User Experience Metrics

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Setup Time | <5 minutes | User testing |
| Tool Success Rate | >95% | Log analysis |
| User Satisfaction | >4/5 | User feedback |
| Documentation Completeness | 100% | Review checklist |

### Development Metrics

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Sprint Velocity | Consistent | Story points completed |
| Bug Rate | <5 per week | Issue tracking |
| Code Review Turnaround | <24 hours | PR metrics |
| Build Success Rate | >95% | CI/CD metrics |

---

## Resource Requirements

### Human Resources

**Core Team:**
- **Lead Developer** (100%): Rust expertise, MCP knowledge
- **Browser Automation Developer** (50-100%): Web scraping experience
- **QA Engineer** (25% starting week 10): Testing and quality assurance

**Optional/Part-time:**
- **Technical Writer** (25% weeks 11-12): Documentation
- **DevOps Engineer** (10%): CI/CD setup

### Infrastructure

**Development:**
- Development machines with Chrome/Chromium
- GitHub repository
- CI/CD pipeline (GitHub Actions)

**Testing:**
- Test Udio accounts (or public playlists)
- Multiple OS environments for testing
- MCP Inspector license

### Tools and Services

**Required:**
- Rust toolchain
- Chrome/Chromium browsers
- Git/GitHub
- VS Code or similar IDE

**Recommended:**
- cargo-watch for development
- cargo-nextest for testing
- Sentry for error tracking (production)

### Budget Considerations

**One-time Costs:**
- Developer tools/licenses: ~$500
- Testing infrastructure: ~$200/month

**Ongoing Costs:**
- CI/CD (GitHub Actions): Free tier sufficient
- Error tracking (Sentry): ~$26/month
- Monitoring: ~$50/month

**Total Estimated Cost:** ~$5,000 for 3-month development

---

## Appendices

### Appendix A: Development Environment Setup

```bash
# Complete setup script
#!/bin/bash

# Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env

# Install required tools
cargo install cargo-watch cargo-nextest cargo-tarpaulin cargo-audit

# Install Node.js for MCP Inspector
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install node
npm install -g @modelcontextprotocol/inspector

# Clone repository
git clone https://github.com/yourusername/udio-mcp-server.git
cd udio-mcp-server

# Build project
cargo build

# Run tests
cargo test

# Start development server
cargo watch -x run
```

### Appendix B: Testing Commands

```bash
# Unit tests
cargo test --lib

# Integration tests
cargo test --test '*' -- --ignored

# Specific test
cargo test test_playlist_manager

# With coverage
cargo tarpaulin --out Html

# Benchmarks
cargo bench

# MCP Inspector
npx @modelcontextprotocol/inspector cargo run

# Memory profiling
valgrind --tool=massif target/release/udio-mcp-server
```

### Appendix C: Troubleshooting Guide

**Common Issues:**

1. **Browser won't launch:**
   - Check Chrome/Chromium is installed
   - Verify path in configuration
   - Try with `headless: false` for debugging

2. **Authentication fails:**
   - Verify credentials
   - Check for 2FA requirements
   - Try public playlist mode

3. **Selectors not working:**
   - Update selectors.toml
   - Check Udio UI hasn't changed
   - Use browser developer tools to find new selectors

4. **Performance issues:**
   - Increase cache TTL
   - Check browser memory usage
   - Enable connection pooling

### Appendix D: Release Process

1. **Version Bump:**
   ```bash
   # Update version in Cargo.toml
   cargo bump minor
   ```

2. **Update CHANGELOG:**
   ```markdown
   ## [0.2.0] - 2025-04-01
   ### Added
   - Feature X
   ### Fixed
   - Bug Y
   ```

3. **Create Tag:**
   ```bash
   git tag -a v0.2.0 -m "Release version 0.2.0"
   git push origin v0.2.0
   ```

4. **Build Release:**
   ```bash
   ./scripts/build-release.sh
   ```

5. **Create GitHub Release:**
   - Upload binaries
   - Add release notes
   - Publish

---

## Conclusion

This implementation plan provides a structured approach to building the Udio MCP Server over 12 weeks. The phased approach ensures steady progress with regular milestones and testing at each stage.

**Key Success Factors:**
1. Modular architecture allowing parallel development
2. Early and continuous testing
3. Robust error handling and fallback mechanisms
4. Comprehensive documentation
5. Active monitoring and quick response to Udio changes

**Next Steps:**
1. Set up development environment
2. Create GitHub repository
3. Begin Stage 1 implementation
4. Establish weekly progress reviews
5. Engage with MCP community for feedback

The plan is designed to be flexible and can be adjusted based on progress and discoveries during implementation.

---

**Document History:**
- v1.0 (2025-01-13): Initial implementation plan

**Approval:**
- [ ] Technical Lead
- [ ] Project Manager
- [ ] Stakeholders

**Status:** Ready for Review