# High-Level Design: Udio Music MCP Server

**Document Version:** 1.0
**Date:** 2025-01-13
**Author:** Claude Code
**Status:** Design Proposal

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Goals and Non-Goals](#goals-and-non-goals)
3. [Architecture Overview](#architecture-overview)
4. [Technology Stack](#technology-stack)
5. [System Components](#system-components)
6. [MCP Primitives Design](#mcp-primitives-design)
7. [Authentication Strategy](#authentication-strategy)
8. [Data Models](#data-models)
9. [Headless Browser Integration](#headless-browser-integration)
10. [Error Handling and Resilience](#error-handling-and-resilience)
11. [Security Considerations](#security-considerations)
12. [Performance Considerations](#performance-considerations)
13. [Implementation Phases](#implementation-phases)
14. [Testing Strategy](#testing-strategy)
15. [Configuration Management](#configuration-management)
16. [Future Enhancements](#future-enhancements)
17. [Dependencies and Risks](#dependencies-and-risks)
18. [Appendices](#appendices)

---

## Executive Summary

This document describes the high-level design for a Model Context Protocol (MCP) server that enables AI assistants to interact with the Udio music platform (udio.com). The server will use a headless browser to automate interactions with Udio's web interface, allowing users to:

- Access and list songs in specific playlists (initially focusing on a "ToPlay" playlist)
- Play one or more songs from the playlist
- Manage playlist operations through natural language commands
- Provide rich context about music content to AI assistants

The server will be implemented in Rust for performance, safety, and reliability, using the MCP protocol to provide a standardized interface for AI applications.

**Key Benefits:**
- Natural language control of Udio music playback
- Integration with Claude and other MCP-compatible AI assistants
- Type-safe, performant implementation in Rust
- Secure credential management
- Extensible architecture for future Udio features

---

## Goals and Non-Goals

### Goals

**Primary Goals:**
1. Enable AI assistants to list songs from a Udio playlist named "ToPlay"
2. Provide playback control (play, pause, stop) for songs in the playlist
3. Support both authenticated (private playlists) and public playlist access
4. Implement robust error handling for network issues and UI changes
5. Provide detailed song metadata (title, artist, duration, etc.)
6. Support stdio transport for local development and SSE for remote access

**Secondary Goals:**
1. Cache playlist and song data to minimize browser automation overhead
2. Support multiple playlists (not just "ToPlay")
3. Provide progress reporting for long-running operations
4. Enable playlist search and filtering
5. Support song playback state monitoring

### Non-Goals

1. **Not implementing audio streaming:** The server controls the web player, not direct audio streaming
2. **Not supporting song creation:** Focus is on playback and organization, not AI music generation
3. **Not implementing full Udio API wrapper:** Only features needed for playlist/playback control
4. **Not providing audio transcoding:** Using Udio's native playback capabilities
5. **Not implementing user management:** Single user focus initially
6. **Not supporting offline playback:** Requires active internet connection

---

## Architecture Overview

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     MCP Client (Claude, etc.)                │
└────────────────────────────┬────────────────────────────────┘
                             │ JSON-RPC 2.0 (stdio/SSE)
                             │
┌────────────────────────────▼────────────────────────────────┐
│                    Udio MCP Server (Rust)                    │
│  ┌───────────────────────────────────────────────────────┐  │
│  │              MCP Protocol Handler                      │  │
│  │  ├─ Tools Handler                                      │  │
│  │  ├─ Resources Handler                                  │  │
│  │  └─ Prompts Handler                                    │  │
│  └───────────────────────────────────────────────────────┘  │
│                             │                                │
│  ┌───────────────────────────────────────────────────────┐  │
│  │           Business Logic Layer                         │  │
│  │  ├─ Playlist Manager                                   │  │
│  │  ├─ Playback Controller                                │  │
│  │  ├─ Authentication Manager                             │  │
│  │  ├─ Cache Manager                                      │  │
│  │  └─ Session Manager                                    │  │
│  └───────────────────────────────────────────────────────┘  │
│                             │                                │
│  ┌───────────────────────────────────────────────────────┐  │
│  │        Headless Browser Automation Layer               │  │
│  │  ├─ Browser Instance Manager                           │  │
│  │  ├─ Page Navigator                                     │  │
│  │  ├─ Element Selector Engine                            │  │
│  │  └─ JavaScript Executor                                │  │
│  └───────────────────────────────────────────────────────┘  │
│                             │                                │
│  ┌───────────────────────────────────────────────────────┐  │
│  │              Data Persistence Layer                    │  │
│  │  ├─ Configuration Store                                │  │
│  │  ├─ Credentials Store (Encrypted)                      │  │
│  │  └─ Cache Store (SQLite/File-based)                    │  │
│  └───────────────────────────────────────────────────────┘  │
└────────────────────────────┬────────────────────────────────┘
                             │
                             │ HTTPS/WebSocket
                             │
┌────────────────────────────▼────────────────────────────────┐
│                  Udio.com Web Application                    │
│  ├─ Authentication                                           │
│  ├─ Playlist Management                                      │
│  ├─ Music Player                                             │
│  └─ Library/Folders                                          │
└──────────────────────────────────────────────────────────────┘
```

### Component Interaction Flow

**Typical Request Flow:**
1. MCP client sends a tool call request (e.g., "list_playlist_songs")
2. MCP Protocol Handler validates and routes the request
3. Business Logic Layer processes the request:
   - Checks cache for recent data
   - If cache miss, initiates browser automation
4. Headless Browser Layer:
   - Navigates to appropriate Udio page
   - Authenticates if needed
   - Executes DOM queries/interactions
   - Extracts data
5. Business Logic Layer:
   - Processes extracted data
   - Updates cache
   - Formats response
6. MCP Protocol Handler sends response back to client

---

## Technology Stack

### Core Technologies

#### Language and Runtime
- **Rust** (Edition 2021+)
  - **Rationale:** Type safety, performance, excellent async support, strong ecosystem
  - **Alternatives Considered:** Python (easier but slower), TypeScript (good but less performant)

#### MCP Framework
- **Crate:** Custom implementation using `tokio` for async runtime
- **Protocol:** JSON-RPC 2.0 over stdio/SSE
- **Serialization:** `serde_json` for JSON handling

#### Headless Browser
- **Primary Choice:** `chromiumoxide` or `fantoccini`
  - **chromiumoxide:** Native Chrome DevTools Protocol implementation
  - **fantoccini:** WebDriver protocol (more stable, wider adoption)
- **Alternative:** `headless_chrome` (older but battle-tested)
- **Browser:** Chromium (via Chrome/Chromium installed on system)

#### Key Rust Crates

```toml
[dependencies]
# MCP and async runtime
tokio = { version = "1.35", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
async-trait = "0.1"

# Headless browser
chromiumoxide = "0.5"  # or fantoccini = "0.20"

# Error handling
anyhow = "1.0"
thiserror = "1.0"

# Logging
tracing = "0.1"
tracing-subscriber = "0.3"

# Configuration
config = "0.13"
toml = "0.8"

# Credentials/secrets
keyring = "2.0"  # OS keychain integration
ring = "0.17"     # Encryption

# Cache
sled = "0.34"     # Embedded key-value store
# OR sqlite with rusqlite = "0.30"

# HTTP client (for potential API calls)
reqwest = { version = "0.11", features = ["json"] }

# Time handling
chrono = "0.4"

# CLI parsing (for standalone testing)
clap = { version = "4.4", features = ["derive"] }
```

### Development Tools
- **Build System:** Cargo
- **Testing:** `cargo test`, `cargo-nextest`
- **Linting:** Clippy
- **Formatting:** rustfmt
- **CI/CD:** GitHub Actions
- **Documentation:** rustdoc

---

## System Components

### 1. MCP Protocol Handler

**Responsibility:** Handle all MCP protocol communication

**Key Modules:**
- `protocol/mod.rs` - Core protocol implementation
- `protocol/transport.rs` - Stdio/SSE transport implementations
- `protocol/handlers.rs` - Request/response handlers
- `protocol/types.rs` - MCP type definitions

**Capabilities:**
```rust
pub struct ServerCapabilities {
    pub tools: ToolCapabilities,
    pub resources: ResourceCapabilities,
    pub prompts: Option<PromptCapabilities>,
}
```

### 2. Business Logic Layer

#### Playlist Manager
**File:** `src/playlist/manager.rs`

**Responsibilities:**
- Fetch playlist metadata
- List songs in playlist
- Search/filter songs
- Handle pagination
- Cache playlist data

**Key Methods:**
```rust
pub trait PlaylistManager {
    async fn get_playlist(&self, name: &str) -> Result<Playlist>;
    async fn list_songs(&self, playlist_id: &str) -> Result<Vec<Song>>;
    async fn search_songs(&self, query: &str) -> Result<Vec<Song>>;
    async fn refresh_playlist(&self, playlist_id: &str) -> Result<()>;
}
```

#### Playback Controller
**File:** `src/playback/controller.rs`

**Responsibilities:**
- Start/stop song playback
- Track playback state
- Handle playback errors
- Monitor playback progress

**Key Methods:**
```rust
pub trait PlaybackController {
    async fn play_song(&self, song_id: &str) -> Result<PlaybackState>;
    async fn pause(&self) -> Result<()>;
    async fn resume(&self) -> Result<()>;
    async fn stop(&self) -> Result<()>;
    async fn get_playback_state(&self) -> Result<PlaybackState>;
}
```

#### Authentication Manager
**File:** `src/auth/manager.rs`

**Responsibilities:**
- Handle login flow
- Store/retrieve credentials securely
- Manage session tokens/cookies
- Handle re-authentication

**Key Methods:**
```rust
pub trait AuthManager {
    async fn login(&self, credentials: Credentials) -> Result<Session>;
    async fn logout(&self) -> Result<()>;
    async fn is_authenticated(&self) -> bool;
    async fn refresh_session(&self) -> Result<()>;
}
```

### 3. Headless Browser Automation Layer

**File:** `src/browser/mod.rs`

**Responsibilities:**
- Manage browser lifecycle
- Navigate pages
- Execute JavaScript
- Extract DOM data
- Handle wait conditions

**Architecture:**
```rust
pub struct BrowserAutomation {
    browser: Browser,
    context: BrowserContext,
    selectors: SelectorConfig,
}

impl BrowserAutomation {
    pub async fn navigate_to(&self, url: &str) -> Result<Page>;
    pub async fn wait_for_selector(&self, selector: &str) -> Result<Element>;
    pub async fn click(&self, selector: &str) -> Result<()>;
    pub async fn get_text(&self, selector: &str) -> Result<String>;
    pub async fn execute_js(&self, script: &str) -> Result<Value>;
}
```

### 4. Cache Manager

**File:** `src/cache/mod.rs`

**Responsibilities:**
- Cache playlist metadata
- Cache song information
- TTL management
- Cache invalidation

**Schema:**
```rust
pub struct CacheEntry<T> {
    pub data: T,
    pub timestamp: DateTime<Utc>,
    pub ttl_seconds: u64,
}

pub trait CacheManager {
    async fn get<T>(&self, key: &str) -> Result<Option<CacheEntry<T>>>;
    async fn set<T>(&self, key: &str, value: T, ttl: u64) -> Result<()>;
    async fn invalidate(&self, pattern: &str) -> Result<()>;
}
```

---

## MCP Primitives Design

### Tools

#### 1. `list_playlist_songs`
**Description:** List all songs in a specific playlist

**Input Schema:**
```json
{
  "type": "object",
  "properties": {
    "playlist_name": {
      "type": "string",
      "description": "Name of the playlist (default: 'ToPlay')",
      "default": "ToPlay"
    },
    "limit": {
      "type": "integer",
      "description": "Maximum number of songs to return",
      "minimum": 1,
      "maximum": 100,
      "default": 50
    },
    "offset": {
      "type": "integer",
      "description": "Number of songs to skip for pagination",
      "minimum": 0,
      "default": 0
    }
  }
}
```

**Output:**
```json
{
  "playlist": {
    "name": "ToPlay",
    "id": "2S1Z6YjLXsL6JAnxf3VdMF",
    "song_count": 25,
    "is_public": false
  },
  "songs": [
    {
      "id": "song_123",
      "title": "Summer Vibes",
      "artist": "AI Artist",
      "duration_seconds": 210,
      "url": "https://www.udio.com/songs/song_123",
      "created_at": "2025-01-10T14:30:00Z",
      "tags": ["pop", "upbeat"]
    }
  ],
  "pagination": {
    "total": 25,
    "offset": 0,
    "limit": 50,
    "has_more": false
  }
}
```

#### 2. `play_song`
**Description:** Play a specific song from the playlist

**Input Schema:**
```json
{
  "type": "object",
  "properties": {
    "song_id": {
      "type": "string",
      "description": "Unique identifier of the song"
    },
    "playlist_name": {
      "type": "string",
      "description": "Playlist containing the song",
      "default": "ToPlay"
    }
  },
  "required": ["song_id"]
}
```

**Output:**
```json
{
  "status": "playing",
  "song": {
    "id": "song_123",
    "title": "Summer Vibes",
    "current_time_seconds": 0,
    "duration_seconds": 210
  },
  "message": "Now playing: Summer Vibes"
}
```

#### 3. `control_playback`
**Description:** Control playback (pause, resume, stop)

**Input Schema:**
```json
{
  "type": "object",
  "properties": {
    "action": {
      "type": "string",
      "enum": ["pause", "resume", "stop"],
      "description": "Playback action to perform"
    }
  },
  "required": ["action"]
}
```

#### 4. `get_playback_status`
**Description:** Get current playback status

**Output:**
```json
{
  "status": "playing",
  "current_song": {
    "id": "song_123",
    "title": "Summer Vibes",
    "artist": "AI Artist"
  },
  "position_seconds": 45,
  "duration_seconds": 210,
  "volume": 80,
  "is_muted": false
}
```

#### 5. `search_playlist_songs`
**Description:** Search for songs within a playlist

**Input Schema:**
```json
{
  "type": "object",
  "properties": {
    "query": {
      "type": "string",
      "description": "Search query (matches title, artist, tags)"
    },
    "playlist_name": {
      "type": "string",
      "default": "ToPlay"
    }
  },
  "required": ["query"]
}
```

#### 6. `list_all_playlists`
**Description:** List all available playlists

**Output:**
```json
{
  "playlists": [
    {
      "name": "ToPlay",
      "id": "playlist_1",
      "song_count": 25,
      "is_public": false,
      "created_at": "2025-01-01T00:00:00Z"
    }
  ]
}
```

### Resources

#### 1. `udio://playlist/{playlist_name}`
**Description:** Get playlist metadata and current state

**MIME Type:** `application/json`

**Example URI:** `udio://playlist/ToPlay`

**Content:**
```json
{
  "name": "ToPlay",
  "id": "playlist_1",
  "song_count": 25,
  "total_duration_seconds": 5250,
  "is_public": false,
  "last_updated": "2025-01-13T10:30:00Z",
  "description": "My favorite tracks to play"
}
```

#### 2. `udio://song/{song_id}`
**Description:** Get detailed information about a specific song

**MIME Type:** `application/json`

**Example URI:** `udio://song/song_123`

#### 3. `udio://playback/state`
**Description:** Current playback state (subscribable resource)

**MIME Type:** `application/json`

**Supports Subscriptions:** Yes (updates when playback state changes)

### Prompts

#### 1. `music_playback_assistant`
**Description:** Guide for interacting with Udio playlists

**Arguments:**
- `playlist_name` (optional): Specific playlist to focus on

**Template:**
```
I can help you interact with your Udio music collection. I have access to your playlists
and can help you:

1. List songs in your playlists (especially the "{{playlist_name}}" playlist)
2. Play specific songs
3. Control playback (pause, resume, stop)
4. Search for songs by title, artist, or tags
5. Get information about your music collection

What would you like to do with your music?
```

#### 2. `playlist_explorer`
**Description:** Detailed playlist exploration prompt

**Arguments:**
- `playlist_name` (required): Playlist to explore

---

## Authentication Strategy

### Supported Authentication Modes

#### Mode 1: Credential-Based Authentication (Private Playlists)

**Flow:**
1. User provides credentials via configuration file or environment variables
2. Server stores encrypted credentials in OS keychain
3. On first run, browser automation performs login:
   - Navigate to `https://www.udio.com/login`
   - Fill in email/password fields
   - Handle 2FA if required (interactive prompt)
   - Save session cookies
4. Subsequent requests reuse saved session
5. Re-authenticate if session expires

**Security Measures:**
- Credentials encrypted using OS keychain (macOS Keychain, Windows Credential Manager, Linux Secret Service)
- Session cookies stored securely
- No plaintext credentials in logs
- Optional support for OAuth/Google login (future enhancement)

**Configuration:**
```toml
[auth]
mode = "credentials"
email = "user@example.com"
# Password stored in OS keychain, not in config file
use_keychain = true
```

**Credential Storage:**
```rust
use keyring::Entry;

pub struct CredentialStore {
    service_name: String,
}

impl CredentialStore {
    pub fn store_password(&self, username: &str, password: &str) -> Result<()> {
        let entry = Entry::new(&self.service_name, username)?;
        entry.set_password(password)?;
        Ok(())
    }

    pub fn get_password(&self, username: &str) -> Result<String> {
        let entry = Entry::new(&self.service_name, username)?;
        Ok(entry.get_password()?)
    }
}
```

#### Mode 2: Public Playlist Mode (No Authentication)

**Flow:**
1. User provides public playlist URL or ID
2. Server accesses playlist without authentication
3. Limited to public playlists only

**Configuration:**
```toml
[auth]
mode = "public"
playlist_url = "https://www.udio.com/playlists/6028ad08-68cb-406d-aa35-a4917b6467d6"
```

**Limitations:**
- Cannot access private playlists
- Cannot modify playlists
- May have rate limiting

### Session Management

**Implementation:**
```rust
pub struct SessionManager {
    cookies: CookieStore,
    token: Option<String>,
    expires_at: Option<DateTime<Utc>>,
}

impl SessionManager {
    pub async fn is_valid(&self) -> bool {
        if let Some(expires) = self.expires_at {
            Utc::now() < expires
        } else {
            false
        }
    }

    pub async fn refresh(&mut self) -> Result<()> {
        // Re-authenticate if needed
        if !self.is_valid() {
            // Trigger re-login
        }
        Ok(())
    }
}
```

---

## Data Models

### Core Domain Models

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

/// Represents a music playlist
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Playlist {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub song_count: usize,
    pub total_duration_seconds: u64,
    pub is_public: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub songs: Vec<Song>,
}

/// Represents a song/track
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Song {
    pub id: String,
    pub title: String,
    pub artist: Option<String>,
    pub duration_seconds: u64,
    pub url: String,
    pub cover_art_url: Option<String>,
    pub created_at: DateTime<Utc>,
    pub tags: Vec<String>,
    pub lyrics: Option<String>,
    pub bpm: Option<u32>,
    pub key: Option<String>,
}

/// Playback state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PlaybackStatus {
    Playing,
    Paused,
    Stopped,
    Buffering,
    Error(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackState {
    pub status: PlaybackStatus,
    pub current_song: Option<Song>,
    pub position_seconds: f64,
    pub duration_seconds: f64,
    pub volume: u8,
    pub is_muted: bool,
    pub repeat_mode: RepeatMode,
    pub shuffle_enabled: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RepeatMode {
    Off,
    One,
    All,
}

/// User session information
#[derive(Debug, Clone)]
pub struct Session {
    pub user_id: String,
    pub session_token: String,
    pub cookies: Vec<Cookie>,
    pub expires_at: DateTime<Utc>,
}

/// Authentication credentials
#[derive(Debug, Clone)]
pub struct Credentials {
    pub email: String,
    pub password: String,
}
```

### Browser Automation Models

```rust
/// Browser selector configuration
#[derive(Debug, Clone, Deserialize)]
pub struct SelectorConfig {
    pub playlist_container: String,
    pub song_item: String,
    pub song_title: String,
    pub play_button: String,
    pub pause_button: String,
    pub progress_bar: String,
    pub login_email_input: String,
    pub login_password_input: String,
    pub login_submit_button: String,
}

impl Default for SelectorConfig {
    fn default() -> Self {
        Self {
            // These are example selectors - will need to be updated based on actual Udio DOM
            playlist_container: ".playlist-container".to_string(),
            song_item: ".song-item".to_string(),
            song_title: ".song-title".to_string(),
            play_button: "[data-action='play']".to_string(),
            pause_button: "[data-action='pause']".to_string(),
            progress_bar: ".progress-bar".to_string(),
            login_email_input: "input[type='email']".to_string(),
            login_password_input: "input[type='password']".to_string(),
            login_submit_button: "button[type='submit']".to_string(),
        }
    }
}
```

---

## Headless Browser Integration

### Browser Lifecycle Management

**Initialization:**
```rust
use chromiumoxide::Browser;
use chromiumoxide::browser::BrowserConfig;

pub struct BrowserManager {
    browser: Option<Browser>,
    config: BrowserConfig,
}

impl BrowserManager {
    pub async fn new() -> Result<Self> {
        let config = BrowserConfig::builder()
            .chrome_executable("/usr/bin/chromium") // Or auto-detect
            .window_size(1920, 1080)
            .with_head() // Or headless for production
            .build()
            .map_err(|e| anyhow!("Failed to build browser config: {}", e))?;

        Ok(Self {
            browser: None,
            config,
        })
    }

    pub async fn launch(&mut self) -> Result<&Browser> {
        if self.browser.is_none() {
            let (browser, mut handler) = Browser::launch(self.config.clone()).await?;

            // Spawn handler task
            tokio::spawn(async move {
                while let Some(event) = handler.next().await {
                    tracing::debug!("Browser event: {:?}", event);
                }
            });

            self.browser = Some(browser);
        }

        Ok(self.browser.as_ref().unwrap())
    }

    pub async fn shutdown(&mut self) -> Result<()> {
        if let Some(browser) = self.browser.take() {
            browser.close().await?;
        }
        Ok(())
    }
}
```

### Page Automation Patterns

**Navigation and Wait:**
```rust
use chromiumoxide::Page;
use chromiumoxide::cdp::browser_protocol::page::NavigateParams;

pub struct PageAutomation<'a> {
    page: &'a Page,
    selectors: &'a SelectorConfig,
}

impl<'a> PageAutomation<'a> {
    pub async fn navigate_and_wait(&self, url: &str) -> Result<()> {
        self.page.goto(url).await?;
        self.page.wait_for_navigation().await?;

        // Wait for page to be fully loaded
        self.page
            .execute("return document.readyState")
            .await?;

        Ok(())
    }

    pub async fn wait_for_selector_with_timeout(
        &self,
        selector: &str,
        timeout_ms: u64,
    ) -> Result<Element> {
        let start = std::time::Instant::now();

        loop {
            if let Ok(Some(element)) = self.page.find_element(selector).await {
                return Ok(element);
            }

            if start.elapsed().as_millis() > timeout_ms as u128 {
                return Err(anyhow!("Timeout waiting for selector: {}", selector));
            }

            tokio::time::sleep(Duration::from_millis(100)).await;
        }
    }
}
```

### Data Extraction

**Extract Playlist Songs:**
```rust
pub async fn extract_playlist_songs(page: &Page, selectors: &SelectorConfig) -> Result<Vec<Song>> {
    // Execute JavaScript to extract all song data
    let script = format!(
        r#"
        Array.from(document.querySelectorAll('{}'))
            .map(song => {{
                const titleElem = song.querySelector('{}');
                const playButton = song.querySelector('{}');

                return {{
                    id: song.dataset.songId || playButton?.dataset.songId,
                    title: titleElem?.textContent?.trim(),
                    duration: song.dataset.duration,
                    url: song.href || song.dataset.url
                }};
            }})
        "#,
        selectors.song_item, selectors.song_title, selectors.play_button
    );

    let result = page.evaluate(script).await?;
    let songs: Vec<Song> = serde_json::from_value(result.value)?;

    Ok(songs)
}
```

### DOM Selector Strategy

**Robust Selector Approach:**
1. **Primary selectors:** Use data attributes when available (`data-testid`, `data-song-id`)
2. **Fallback selectors:** Class names and element structure
3. **Multiple selector attempts:** Try multiple selectors in order of reliability
4. **Selector versioning:** Configuration file allows updating selectors without code changes

**Configuration-Driven Selectors:**
```toml
# config/selectors.toml
[selectors]
# Version tracking for selector changes
version = "1.0.0"
last_verified = "2025-01-13"

[selectors.playlist]
container = [
    ".playlist-songs-container",  # Primary
    "[data-testid='playlist-container']",  # Fallback 1
    ".library-content"  # Fallback 2
]

[selectors.song]
item = ".song-item, [data-song], .track-row"
title = ".song-title, .track-name, h3"
duration = ".duration, .track-length"
```

---

## Error Handling and Resilience

### Error Categories

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum UdioMcpError {
    #[error("Browser automation error: {0}")]
    BrowserError(String),

    #[error("Authentication failed: {0}")]
    AuthError(String),

    #[error("Playlist not found: {0}")]
    PlaylistNotFound(String),

    #[error("Song not found: {0}")]
    SongNotFound(String),

    #[error("Playback error: {0}")]
    PlaybackError(String),

    #[error("Network error: {0}")]
    NetworkError(#[from] reqwest::Error),

    #[error("Cache error: {0}")]
    CacheError(String),

    #[error("Configuration error: {0}")]
    ConfigError(#[from] config::ConfigError),

    #[error("Selector not found: {0}")]
    SelectorNotFound(String),

    #[error("Timeout: {0}")]
    Timeout(String),

    #[error("Rate limit exceeded")]
    RateLimitExceeded,

    #[error("Invalid operation: {0}")]
    InvalidOperation(String),
}
```

### Retry Strategy

```rust
use backoff::ExponentialBackoff;

pub async fn retry_with_backoff<F, T>(
    operation: F,
    max_retries: u32,
) -> Result<T>
where
    F: Fn() -> Pin<Box<dyn Future<Output = Result<T>> + Send>>,
{
    let backoff = ExponentialBackoff {
        max_elapsed_time: Some(Duration::from_secs(60)),
        max_interval: Duration::from_secs(10),
        ..Default::default()
    };

    backoff::future::retry(backoff, || async {
        match operation().await {
            Ok(result) => Ok(result),
            Err(e) => {
                tracing::warn!("Operation failed, retrying: {}", e);
                Err(backoff::Error::transient(e))
            }
        }
    })
    .await
}
```

### Graceful Degradation

**Strategy:**
1. **Cache fallback:** Return cached data if browser automation fails
2. **Partial results:** Return available data even if some operations fail
3. **Error context:** Provide detailed error messages to help users
4. **Health checks:** Periodic verification of Udio availability

```rust
pub async fn get_playlist_with_fallback(
    manager: &PlaylistManager,
    cache: &CacheManager,
    playlist_name: &str,
) -> Result<Playlist> {
    // Try to get fresh data
    match manager.get_playlist(playlist_name).await {
        Ok(playlist) => {
            // Update cache
            cache.set(&format!("playlist:{}", playlist_name), &playlist, 3600).await?;
            Ok(playlist)
        }
        Err(e) => {
            tracing::warn!("Failed to fetch playlist, trying cache: {}", e);

            // Fallback to cache
            if let Some(cached) = cache.get::<Playlist>(&format!("playlist:{}", playlist_name)).await? {
                tracing::info!("Returning cached playlist data (age: {:?})",
                    Utc::now() - cached.timestamp);
                Ok(cached.data)
            } else {
                Err(e)
            }
        }
    }
}
```

---

## Security Considerations

### Credential Management

**Secure Storage:**
- Use OS native keychain/credential manager
- Never store plaintext passwords in configuration files
- Encrypt session tokens at rest
- Support for credential rotation

**Implementation:**
```rust
use keyring::Entry;
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

pub struct SecureCredentialStore {
    keyring_service: String,
    encryption_key: LessSafeKey,
}

impl SecureCredentialStore {
    pub fn store_credentials(&self, username: &str, password: &str) -> Result<()> {
        // Store in OS keychain
        let entry = Entry::new(&self.keyring_service, username)?;
        entry.set_password(password)?;

        tracing::info!("Credentials stored securely for user: {}", username);
        Ok(())
    }

    pub fn get_credentials(&self, username: &str) -> Result<String> {
        let entry = Entry::new(&self.keyring_service, username)?;
        let password = entry.get_password()?;
        Ok(password)
    }
}
```

### Input Validation

**Validation Rules:**
```rust
pub fn validate_playlist_name(name: &str) -> Result<()> {
    if name.is_empty() {
        return Err(anyhow!("Playlist name cannot be empty"));
    }

    if name.len() > 255 {
        return Err(anyhow!("Playlist name too long (max 255 characters)"));
    }

    // Prevent path traversal
    if name.contains("..") || name.contains("/") || name.contains("\\") {
        return Err(anyhow!("Invalid characters in playlist name"));
    }

    Ok(())
}

pub fn validate_song_id(id: &str) -> Result<()> {
    // Ensure song ID matches expected format
    let id_regex = Regex::new(r"^[a-zA-Z0-9_-]+$")?;

    if !id_regex.is_match(id) {
        return Err(anyhow!("Invalid song ID format"));
    }

    Ok(())
}
```

### Rate Limiting

```rust
use governor::{Quota, RateLimiter as GovernorRateLimiter};
use std::num::NonZeroU32;

pub struct RateLimiter {
    limiter: GovernorRateLimiter<String, DefaultKeyedStateStore<String>>,
}

impl RateLimiter {
    pub fn new(requests_per_minute: u32) -> Self {
        let quota = Quota::per_minute(NonZeroU32::new(requests_per_minute).unwrap());
        let limiter = GovernorRateLimiter::keyed(quota);

        Self { limiter }
    }

    pub fn check_limit(&self, key: &str) -> Result<()> {
        match self.limiter.check_key(&key.to_string()) {
            Ok(_) => Ok(()),
            Err(_) => Err(UdioMcpError::RateLimitExceeded.into()),
        }
    }
}
```

### Logging and Audit

**Security Logging:**
- Log all authentication attempts
- Log tool invocations with sanitized parameters
- Never log passwords or tokens
- Structured logging for audit trails

```rust
pub fn log_tool_invocation(tool_name: &str, params: &Value, user: &str) {
    // Sanitize sensitive parameters
    let sanitized_params = sanitize_log_params(params);

    tracing::info!(
        target: "audit",
        tool = tool_name,
        user = user,
        params = ?sanitized_params,
        timestamp = %Utc::now(),
        "Tool invocation"
    );
}
```

---

## Performance Considerations

### Caching Strategy

**Multi-Level Cache:**
1. **Memory cache:** Hot data (current playlist, playback state)
2. **Persistent cache:** Playlist metadata, song information (SQLite/Sled)
3. **TTL-based invalidation:** Configurable cache lifetimes

**Cache Implementation:**
```rust
use sled::Db;

pub struct MultiLevelCache {
    memory_cache: Arc<RwLock<HashMap<String, (Value, Instant)>>>,
    persistent_cache: Db,
    config: CacheConfig,
}

impl MultiLevelCache {
    pub async fn get<T: DeserializeOwned>(&self, key: &str) -> Result<Option<T>> {
        // Check memory cache first
        {
            let cache = self.memory_cache.read().await;
            if let Some((value, inserted_at)) = cache.get(key) {
                if inserted_at.elapsed() < self.config.memory_ttl {
                    return Ok(Some(serde_json::from_value(value.clone())?));
                }
            }
        }

        // Check persistent cache
        if let Some(data) = self.persistent_cache.get(key.as_bytes())? {
            let entry: CacheEntry<T> = bincode::deserialize(&data)?;

            if Utc::now().timestamp() < entry.timestamp.timestamp() + entry.ttl_seconds as i64 {
                // Update memory cache
                let mut cache = self.memory_cache.write().await;
                cache.insert(
                    key.to_string(),
                    (serde_json::to_value(&entry.data)?, Instant::now())
                );

                return Ok(Some(entry.data));
            }
        }

        Ok(None)
    }
}
```

### Browser Instance Pooling

**Strategy:**
- Maintain a pool of browser instances
- Reuse instances for multiple requests
- Limit concurrent browser operations
- Automatic cleanup of idle instances

```rust
pub struct BrowserPool {
    instances: Arc<RwLock<Vec<Browser>>>,
    max_instances: usize,
    idle_timeout: Duration,
}

impl BrowserPool {
    pub async fn acquire(&self) -> Result<BrowserGuard> {
        let mut instances = self.instances.write().await;

        if let Some(browser) = instances.pop() {
            Ok(BrowserGuard::new(browser, self.instances.clone()))
        } else if instances.len() < self.max_instances {
            // Launch new instance
            let browser = Browser::launch(BrowserConfig::default()).await?.0;
            Ok(BrowserGuard::new(browser, self.instances.clone()))
        } else {
            Err(anyhow!("Browser pool exhausted"))
        }
    }
}
```

### Async Operations

**Parallel Data Fetching:**
```rust
pub async fn fetch_multiple_playlists(
    manager: &PlaylistManager,
    playlist_names: Vec<String>,
) -> Result<Vec<Playlist>> {
    let futures: Vec<_> = playlist_names
        .iter()
        .map(|name| manager.get_playlist(name))
        .collect();

    let results = futures::future::join_all(futures).await;

    // Collect successes, log failures
    let playlists: Vec<_> = results
        .into_iter()
        .filter_map(|result| match result {
            Ok(playlist) => Some(playlist),
            Err(e) => {
                tracing::error!("Failed to fetch playlist: {}", e);
                None
            }
        })
        .collect();

    Ok(playlists)
}
```

---

## Implementation Phases

### Phase 1: Foundation (Week 1-2)

**Goals:**
- Set up Rust project structure
- Implement basic MCP protocol handler
- Implement stdio transport
- Basic error handling and logging

**Deliverables:**
- Project scaffolding with Cargo workspace
- MCP initialization and capability negotiation
- Basic tool registration framework
- Logging infrastructure

**Success Criteria:**
- Server can start and respond to MCP protocol messages
- Can list available tools (even if not implemented)
- Passes MCP Inspector validation

### Phase 2: Browser Automation (Week 3-4)

**Goals:**
- Implement headless browser integration
- Develop robust selector system
- Implement navigation and wait strategies
- Create page automation utilities

**Deliverables:**
- Browser lifecycle management
- Page navigation framework
- Element selection and interaction
- JavaScript execution capabilities

**Success Criteria:**
- Can launch browser and navigate to Udio
- Can wait for elements and extract text
- Handles timeouts gracefully

### Phase 3: Authentication (Week 5)

**Goals:**
- Implement credential storage
- Develop login automation
- Session management
- Handle authentication errors

**Deliverables:**
- Secure credential storage using OS keychain
- Automated login flow
- Session persistence
- Re-authentication logic

**Success Criteria:**
- Can log in to Udio with credentials
- Session persists across server restarts
- Handles invalid credentials gracefully

### Phase 4: Playlist Operations (Week 6-7)

**Goals:**
- Implement playlist listing
- Song enumeration
- Playlist metadata extraction
- Caching layer

**Deliverables:**
- `list_playlist_songs` tool
- `list_all_playlists` tool
- Playlist and song data models
- Basic cache implementation

**Success Criteria:**
- Can list songs from "ToPlay" playlist
- Returns accurate song metadata
- Cache reduces repeated browser operations

### Phase 5: Playback Control (Week 8)

**Goals:**
- Implement playback controls
- Playback state monitoring
- Error handling for playback issues

**Deliverables:**
- `play_song` tool
- `control_playback` tool
- `get_playback_status` tool
- Playback state tracking

**Success Criteria:**
- Can initiate song playback
- Can pause/resume/stop playback
- Accurately reports playback state

### Phase 6: Resources and Prompts (Week 9)

**Goals:**
- Implement MCP resources
- Create helpful prompts
- Documentation

**Deliverables:**
- `udio://playlist/{name}` resource
- `udio://song/{id}` resource
- `music_playback_assistant` prompt
- Resource subscriptions (if time permits)

**Success Criteria:**
- Resources accessible via MCP
- Prompts provide helpful guidance

### Phase 7: Polish and Testing (Week 10-11)

**Goals:**
- Comprehensive testing
- Performance optimization
- Documentation
- Example configurations

**Deliverables:**
- Unit tests for all components
- Integration tests
- Performance benchmarks
- User documentation
- Configuration examples

**Success Criteria:**
- >80% test coverage
- Handles edge cases gracefully
- Documentation is clear and complete
- Ready for production use

### Phase 8: Advanced Features (Week 12+)

**Optional enhancements:**
- SSE transport for remote access
- Advanced search capabilities
- Playlist modification (create, delete, reorder)
- Multiple user support
- Metrics and monitoring

---

## Testing Strategy

### Unit Tests

**Component Coverage:**
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_playlist_manager_get_playlist() {
        let mock_browser = MockBrowser::new();
        let manager = PlaylistManager::new(mock_browser);

        let playlist = manager.get_playlist("ToPlay").await.unwrap();

        assert_eq!(playlist.name, "ToPlay");
        assert!(!playlist.songs.is_empty());
    }

    #[test]
    fn test_validate_playlist_name() {
        assert!(validate_playlist_name("ToPlay").is_ok());
        assert!(validate_playlist_name("").is_err());
        assert!(validate_playlist_name("../etc/passwd").is_err());
    }

    #[tokio::test]
    async fn test_cache_get_set() {
        let cache = MultiLevelCache::new(CacheConfig::default()).await.unwrap();

        let song = Song {
            id: "test123".to_string(),
            title: "Test Song".to_string(),
            // ...
        };

        cache.set("song:test123", &song, 3600).await.unwrap();

        let retrieved = cache.get::<Song>("song:test123").await.unwrap();
        assert!(retrieved.is_some());
        assert_eq!(retrieved.unwrap().id, "test123");
    }
}
```

### Integration Tests

**Test Scenarios:**
1. Full authentication flow
2. Playlist listing and song extraction
3. Playback control sequence
4. Cache invalidation and refresh
5. Error handling and recovery

**Integration Test Example:**
```rust
#[tokio::test]
#[ignore] // Run separately with real browser
async fn test_full_playlist_workflow() {
    // This test requires real Udio access
    let config = load_test_config();
    let server = UdioMcpServer::new(config).await.unwrap();

    // Test playlist listing
    let playlists = server.list_all_playlists().await.unwrap();
    assert!(!playlists.is_empty());

    // Test song listing
    let songs = server.list_playlist_songs("ToPlay", 10, 0).await.unwrap();
    assert!(!songs.is_empty());

    // Test playback (if allowed in test environment)
    if let Some(first_song) = songs.first() {
        let state = server.play_song(&first_song.id).await.unwrap();
        assert_eq!(state.status, PlaybackStatus::Playing);

        // Stop playback
        server.control_playback("stop").await.unwrap();
    }
}
```

### End-to-End Tests

**MCP Protocol Tests:**
```bash
# Using MCP Inspector
npx @modelcontextprotocol/inspector cargo run --release

# Manual testing with Claude Desktop
# 1. Configure server in claude_desktop_config.json
# 2. Restart Claude
# 3. Test tool invocations through chat
```

### Performance Tests

**Benchmarks:**
```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_playlist_extraction(c: &mut Criterion) {
    let runtime = tokio::runtime::Runtime::new().unwrap();

    c.bench_function("extract_playlist_songs", |b| {
        b.to_async(&runtime).iter(|| async {
            let mock_page = create_mock_page_with_songs(50);
            extract_playlist_songs(black_box(&mock_page), &SelectorConfig::default()).await
        });
    });
}

criterion_group!(benches, benchmark_playlist_extraction);
criterion_main!(benches);
```

---

## Configuration Management

### Configuration File Structure

**Location:** `~/.config/udio-mcp/config.toml` (or via environment variable)

```toml
# Udio MCP Server Configuration

[server]
name = "udio-mcp-server"
version = "0.1.0"

[auth]
# Authentication mode: "credentials" or "public"
mode = "credentials"

# Email for login (password stored in OS keychain)
email = "user@example.com"

# Use OS keychain for secure credential storage
use_keychain = true

# Keychain service name
keychain_service = "udio-mcp-server"

# For public playlist mode
# playlist_url = "https://www.udio.com/playlists/PLAYLIST_ID"

[browser]
# Browser executable path (auto-detect if not specified)
# executable = "/usr/bin/chromium"

# Run in headless mode
headless = true

# Window size (for consistency)
window_width = 1920
window_height = 1080

# User agent (optional)
# user_agent = "Mozilla/5.0 ..."

# Browser arguments
args = [
    "--disable-blink-features=AutomationControlled",
    "--disable-dev-shm-usage"
]

[cache]
# Enable caching
enabled = true

# Cache directory
path = "~/.cache/udio-mcp"

# Cache TTL for playlists (seconds)
playlist_ttl = 3600  # 1 hour

# Cache TTL for songs (seconds)
song_ttl = 86400  # 24 hours

# Memory cache size (MB)
memory_cache_size = 50

[selectors]
# DOM selector configuration file
config_file = "./config/selectors.toml"

# Auto-update selectors from repository
auto_update = true

[logging]
# Log level: trace, debug, info, warn, error
level = "info"

# Log to file
log_file = "~/.local/share/udio-mcp/udio-mcp.log"

# Log to stderr (for MCP debugging)
log_stderr = true

# Structured JSON logging
json_format = false

[performance]
# Maximum concurrent browser instances
max_browser_instances = 3

# Request timeout (seconds)
request_timeout = 30

# Browser idle timeout (seconds)
browser_idle_timeout = 300

# Enable rate limiting
rate_limiting_enabled = true

# Requests per minute
rate_limit_rpm = 30

[features]
# Enable experimental features
enable_subscriptions = false

# Enable advanced search
enable_advanced_search = true

# Enable playlist modification
enable_playlist_modification = false
```

### Environment Variables

```bash
# Override configuration file location
export UDIO_MCP_CONFIG=/path/to/config.toml

# Override specific settings
export UDIO_MCP_AUTH_EMAIL=user@example.com
export UDIO_MCP_BROWSER_HEADLESS=true
export UDIO_MCP_LOG_LEVEL=debug

# Provide password (not recommended, use keychain instead)
# export UDIO_MCP_AUTH_PASSWORD=secret
```

### Runtime Configuration Updates

**Dynamic Configuration Reload:**
```rust
pub struct ConfigManager {
    config: Arc<RwLock<Config>>,
    watcher: notify::RecommendedWatcher,
}

impl ConfigManager {
    pub async fn reload(&self) -> Result<()> {
        let new_config = Config::load()?;
        let mut config = self.config.write().await;
        *config = new_config;

        tracing::info!("Configuration reloaded successfully");
        Ok(())
    }
}
```

---

## Future Enhancements

### Short-Term Enhancements (3-6 months)

1. **Advanced Search**
   - Search across all playlists
   - Filter by tags, BPM, key, duration
   - Fuzzy matching

2. **Playlist Management**
   - Create new playlists
   - Add/remove songs
   - Reorder songs
   - Delete playlists

3. **Smart Recommendations**
   - AI-powered song recommendations
   - Similar song discovery
   - Mood-based playlists

4. **Queue Management**
   - Add to queue
   - View queue
   - Reorder queue
   - Clear queue

### Medium-Term Enhancements (6-12 months)

1. **Multi-User Support**
   - Multiple user profiles
   - User-specific playlists
   - Session isolation

2. **SSE Transport**
   - Remote server access
   - Web-based clients
   - Authentication tokens

3. **Websocket Support for Real-Time Updates**
   - Live playback state updates
   - Playlist change notifications
   - Real-time sync across clients

4. **Analytics and Metrics**
   - Listening history
   - Popular songs
   - Usage statistics
   - Performance metrics

5. **Lyrics Integration**
   - Fetch and display lyrics
   - Synchronized lyrics during playback
   - Lyrics search

### Long-Term Enhancements (12+ months)

1. **Udio API Integration**
   - If/when Udio releases an official API, migrate from browser automation
   - Direct API calls for improved performance and reliability

2. **Mobile Support**
   - iOS/Android apps using MCP
   - Mobile-optimized UI

3. **Voice Control**
   - Voice commands for playback
   - Natural language queries

4. **Integration with Other Services**
   - Spotify/Apple Music playlist sync
   - Export playlists
   - Cross-platform management

5. **AI-Enhanced Features**
   - Automatic playlist generation
   - Mood detection
   - Smart shuffle algorithms

---

## Dependencies and Risks

### Critical Dependencies

| Dependency | Type | Risk Level | Mitigation |
|------------|------|------------|------------|
| Udio.com availability | External Service | High | Cache fallback, retry logic |
| Browser (Chrome/Chromium) | System | Medium | Multi-browser support, version detection |
| OS Keychain | System | Low | Fallback to encrypted file storage |
| Udio DOM structure | External | High | Configurable selectors, auto-update |
| Network connectivity | Infrastructure | Medium | Offline mode with cached data |

### Technical Risks

#### Risk 1: Udio UI Changes
**Impact:** High - Browser automation breaks
**Probability:** High - Web apps change frequently
**Mitigation:**
- Configurable selectors in external file
- Multiple fallback selectors
- Automated selector validation tests
- Community-maintained selector updates
- Clear error messages for debugging

#### Risk 2: Authentication Issues
**Impact:** High - Cannot access private playlists
**Probability:** Medium - 2FA, session expiry
**Mitigation:**
- Support for public playlists (no auth needed)
- Session persistence and refresh
- Interactive 2FA prompts
- Clear authentication status reporting

#### Risk 3: Rate Limiting
**Impact:** Medium - Reduced functionality
**Probability:** Medium - Udio may rate limit automated access
**Mitigation:**
- Aggressive caching
- Request throttling
- Exponential backoff
- User education on limits

#### Risk 4: Browser Detection
**Impact:** Medium - Udio detects automation
**Probability:** Low-Medium - Many sites block bots
**Mitigation:**
- Stealth mode configuration
- Realistic user agent and behaviors
- Human-like delays
- Cookie and session management

#### Risk 5: Cross-Platform Compatibility
**Impact:** Medium - Works on some OS but not others
**Probability:** Low - Well-tested tools
**Mitigation:**
- Comprehensive testing on Linux, macOS, Windows
- CI/CD with multi-platform tests
- Platform-specific configuration options
- Clear system requirements documentation

### Operational Risks

#### Risk 1: User Credential Security
**Impact:** Critical - Credential compromise
**Probability:** Low - With proper safeguards
**Mitigation:**
- OS keychain integration (encrypted by OS)
- No plaintext password storage
- No password logging
- Security audit of credential handling code
- Clear user guidelines

#### Risk 2: Performance Degradation
**Impact:** Medium - Slow response times
**Probability:** Medium - Browser overhead
**Mitigation:**
- Browser instance pooling
- Aggressive caching
- Async operations
- Performance monitoring and alerts
- Configuration tuning options

---

## Appendices

### Appendix A: Udio DOM Structure (Example)

**Note:** This is hypothetical and must be updated based on actual inspection of Udio's website.

```html
<!-- Playlist Page -->
<div class="playlist-container" data-playlist-id="abc123">
  <header class="playlist-header">
    <h1 class="playlist-title">ToPlay</h1>
    <div class="playlist-meta">
      <span class="song-count">25 songs</span>
      <span class="total-duration">1:30:00</span>
    </div>
  </header>

  <div class="songs-list">
    <div class="song-item" data-song-id="song_1">
      <button class="play-button" data-action="play" data-song-id="song_1">
        <svg>...</svg>
      </button>
      <div class="song-info">
        <h3 class="song-title">Summer Vibes</h3>
        <span class="song-artist">AI Artist</span>
      </div>
      <span class="song-duration">3:30</span>
      <div class="song-tags">
        <span class="tag">pop</span>
        <span class="tag">upbeat</span>
      </div>
    </div>
    <!-- More song items -->
  </div>
</div>

<!-- Player Controls -->
<div class="player-bar">
  <div class="player-controls">
    <button class="btn-previous">⏮</button>
    <button class="btn-play-pause" data-state="paused">▶</button>
    <button class="btn-next">⏭</button>
  </div>
  <div class="player-progress">
    <span class="current-time">0:00</span>
    <div class="progress-bar">
      <div class="progress-fill" style="width: 0%"></div>
    </div>
    <span class="total-time">3:30</span>
  </div>
  <div class="player-volume">
    <button class="btn-mute">🔊</button>
    <input type="range" class="volume-slider" min="0" max="100" value="80">
  </div>
</div>
```

### Appendix B: Example MCP Client Configuration

**Claude Desktop Configuration:**
```json
{
  "mcpServers": {
    "udio": {
      "command": "/path/to/udio-mcp-server",
      "args": ["--config", "/path/to/config.toml"],
      "env": {
        "RUST_LOG": "info"
      }
    }
  }
}
```

**Windows Configuration:**
```json
{
  "mcpServers": {
    "udio": {
      "command": "C:\\Program Files\\UdioMCP\\udio-mcp-server.exe",
      "args": ["--config", "C:\\Users\\Username\\.config\\udio-mcp\\config.toml"]
    }
  }
}
```

### Appendix C: Selector Configuration Example

**config/selectors.toml:**
```toml
version = "1.0.0"
last_verified = "2025-01-13"
udio_version_tested = "2025-01-10"

[playlist]
container = [".playlist-container", "[data-playlist]", ".library-content"]
header = [".playlist-header", "header"]
title = [".playlist-title", "h1"]
song_count = [".song-count", ".meta-count"]

[song]
item = [".song-item", "[data-song]", ".track-row"]
title = [".song-title", ".track-name", "h3"]
artist = [".song-artist", ".artist-name"]
duration = [".song-duration", ".duration", ".track-length"]
play_button = ["[data-action='play']", ".play-button", ".btn-play"]
tags = [".song-tags .tag", ".tags .tag", ".genre-tag"]

[player]
controls = [".player-bar", ".playback-controls", "#player"]
play_pause_button = [".btn-play-pause", "[data-action='play-pause']"]
next_button = [".btn-next", "[data-action='next']"]
previous_button = [".btn-previous", "[data-action='previous']"]
progress_bar = [".progress-bar", ".seek-bar"]
current_time = [".current-time", ".time-current"]
total_time = [".total-time", ".time-total", ".duration"]

[auth]
login_email = ["input[type='email']", "input[name='email']", "#email"]
login_password = ["input[type='password']", "input[name='password']", "#password"]
login_submit = ["button[type='submit']", ".btn-login", ".submit-button"]
```

### Appendix D: Example API Responses

**list_playlist_songs Response:**
```json
{
  "playlist": {
    "id": "playlist_abc123",
    "name": "ToPlay",
    "description": "My favorite AI-generated tracks",
    "song_count": 25,
    "total_duration_seconds": 5400,
    "is_public": false,
    "created_at": "2025-01-01T00:00:00Z",
    "updated_at": "2025-01-13T10:30:00Z"
  },
  "songs": [
    {
      "id": "song_123",
      "title": "Summer Vibes",
      "artist": "AI Artist",
      "duration_seconds": 210,
      "url": "https://www.udio.com/songs/song_123",
      "cover_art_url": "https://cdn.udio.com/covers/song_123.jpg",
      "created_at": "2025-01-10T14:30:00Z",
      "tags": ["pop", "upbeat", "summer"],
      "bpm": 120,
      "key": "C Major"
    },
    {
      "id": "song_456",
      "title": "Midnight Jazz",
      "artist": null,
      "duration_seconds": 180,
      "url": "https://www.udio.com/songs/song_456",
      "cover_art_url": null,
      "created_at": "2025-01-08T20:15:00Z",
      "tags": ["jazz", "ambient", "nighttime"],
      "bpm": 90,
      "key": "D Minor"
    }
  ],
  "pagination": {
    "total": 25,
    "offset": 0,
    "limit": 50,
    "has_more": false
  }
}
```

### Appendix E: Development Roadmap Summary

**Phase 1 (Week 1-2):** Foundation & MCP Protocol
**Phase 2 (Week 3-4):** Browser Automation
**Phase 3 (Week 5):** Authentication
**Phase 4 (Week 6-7):** Playlist Operations
**Phase 5 (Week 8):** Playback Control
**Phase 6 (Week 9):** Resources & Prompts
**Phase 7 (Week 10-11):** Testing & Polish
**Phase 8 (Week 12+):** Advanced Features

**Total Estimated Time:** 11-12 weeks for core functionality, ongoing for enhancements

### Appendix F: References and Resources

- **MCP Specification:** https://modelcontextprotocol.io/specification
- **Rust MCP SDK:** https://github.com/modelcontextprotocol/rust-sdk
- **Chromiumoxide:** https://github.com/mattsse/chromiumoxide
- **Fantoccini:** https://github.com/jonhoo/fantoccini
- **Udio Help Center:** https://help.udio.com/
- **Udio Website:** https://www.udio.com/

---

## Conclusion

This High-Level Design provides a comprehensive blueprint for building a robust, secure, and performant MCP server for Udio music interaction. The design emphasizes:

1. **Type Safety:** Leveraging Rust's strong type system for reliability
2. **Security:** Secure credential management and input validation
3. **Resilience:** Comprehensive error handling and fallback mechanisms
4. **Performance:** Caching, async operations, and resource pooling
5. **Extensibility:** Modular architecture supporting future enhancements
6. **User Experience:** Natural language control through AI assistants

The phased implementation approach ensures steady progress with testable milestones, while the configurable architecture allows adaptation to Udio's evolving platform.

**Next Steps:**
1. Review and approve this design
2. Set up development environment
3. Begin Phase 1 implementation
4. Establish CI/CD pipeline
5. Create initial test suite

**Questions for Product Review:**
1. Priority of public vs. authenticated playlist support?
2. Acceptable cache staleness for playlist data?
3. Required performance SLAs?
4. Support for Windows, macOS, Linux - all three or subset?
5. Initial target users (developers, power users, general audience)?

---

**Document History:**
- v1.0 (2025-01-13): Initial design document created

**Approvals:**
- [ ] Technical Lead
- [ ] Product Manager
- [ ] Security Review
- [ ] Architecture Review

**Status:** Awaiting Review
